<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xiondoc PUBLIC "-//Kreative//DTD XIONDoc 1.2//EN" "xiondoc-1.2.dtd">
<documentationset>

<summary>
	This is the official documentation for the XION scripting language
	and the OpenXION implementation. XION is a modern xTalk language
	based on the original HyperTalk. It is easy to learn and has the
	most English-like syntax of any programming language.
</summary>
<description>
	This is the official documentation for the XION scripting language
	and the OpenXION implementation. XION is a modern xTalk language
	based on the original HyperTalk. It is easy to learn and has the
	most English-like syntax of any programming language.
</description>
<description>
	This manual describes every vocabulary term in XION and OpenXION
	in detail. It is intended to be used as a comprehensive reference
	for XION programmers. If you are just getting started with XION,
	the documentation may seem overwhelming at first, but over time
	you will come to appreciate its breadth. For an introduction to
	XION programming, the independent site openxion.org has a good
	tutorial and is available to help you.
</description>
<description>
	A particular implementation of XION is called a dialect. OpenXION is one
	such dialect. In addition to standard XION features, OpenXION provides
	expandability through the use of modules. Dialects and modules are
	listed at the top left. Below that is a list of types of vocabulary
	terms, which you can use to narrow down the vocabulary you are looking
	for, as well as some appendices for quick reference.
</description>

<dialect>
	<name>xn1</name>
	<title>XION Scripting Language Standard</title>
	<vers>1.0</vers>
	<summary>
		This is the official documentation for the XION Scripting
		Language Standard. XION is a modern xTalk language based
		on the original HyperTalk. It is easy to learn and has the
		most English-like syntax of any programming language.
	</summary>
	<description>
		This is the official documentation for the XION Scripting
		Language Standard. XION is a modern xTalk language based
		on the original HyperTalk. It is easy to learn and has the
		most English-like syntax of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxnb1</name>
	<title>OpenXION</title>
	<vers>1.0</vers>
	<summary>
		This is the official documentation for the core functionality
		of version 1.0 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the core functionality
		of version 1.0 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxn1</name>
	<title>OpenXION Standard Module</title>
	<vers>1.0</vers>
	<summary>
		This is the official documentation for the standard functionality
		of version 1.0 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the standard functionality
		of version 1.0 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxne1</name>
	<title>OpenXION Extended Module</title>
	<vers>1.0</vers>
	<summary>
		This is the official documentation for the nonstandard functionality
		of version 1.0 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the nonstandard functionality
		of version 1.0 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxnb11</name>
	<title>OpenXION</title>
	<vers>1.1</vers>
	<summary>
		This is the official documentation for the core functionality
		of version 1.1 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the core functionality
		of version 1.1 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxn11</name>
	<title>OpenXION Standard Module</title>
	<vers>1.1</vers>
	<summary>
		This is the official documentation for the standard functionality
		of version 1.1 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the standard functionality
		of version 1.1 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxne11</name>
	<title>OpenXION Extended Module</title>
	<vers>1.1</vers>
	<summary>
		This is the official documentation for the nonstandard functionality
		of version 1.1 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the nonstandard functionality
		of version 1.1 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxnb12</name>
	<title>OpenXION</title>
	<vers>1.2</vers>
	<summary>
		This is the official documentation for the core functionality
		of version 1.2 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the core functionality
		of version 1.2 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxn12</name>
	<title>OpenXION Standard Module</title>
	<vers>1.2</vers>
	<summary>
		This is the official documentation for the standard functionality
		of version 1.2 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the standard functionality
		of version 1.2 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxne12</name>
	<title>OpenXION Extended Module</title>
	<vers>1.2</vers>
	<summary>
		This is the official documentation for the nonstandard functionality
		of version 1.2 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the nonstandard functionality
		of version 1.2 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>oxna12</name>
	<title>OpenXION Audio Module</title>
	<vers>1.2</vers>
	<summary>
		This is the official documentation for the nonstandard audio-related
		functionality of version 1.2 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		This is the official documentation for the nonstandard audio-related
		functionality of version 1.2 of OpenXION. OpenXION is the reference
		implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</description>
</dialect>

<dialect>
	<name>hyp</name>
	<title>HyperTalk</title>
	<vers>2.2</vers>
	<summary>
		This is the official documentation for the parts of OpenXION
		that were originally present in HyperTalk. Only vocabulary terms
		available in both OpenXION and HyperTalk are listed here.
	</summary>
	<description>
		This is the official documentation for the parts of OpenXION
		that were originally present in HyperTalk. Only vocabulary terms
		available in both OpenXION and HyperTalk are listed here.
	</description>
</dialect>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">if</name>
	<precedence>unary</precedence>
	<syntax>if {condition} then {true-expression} else {false-expression}</syntax>
	<syntax-note>
		{Condition} yields a [[dt:boolean]].
		{True-expression} and {false-expression} yield any [[dt:variant]]s.
	</syntax-note>
	<description-short>Conditional expressions</description-short>
	<description>
		The [[*]] operator creates a conditional expression.
		If the condition given in the [[if]] clause is true,
		the entire expression evaluates to the value given in
		the [[then]] clause. If the condition is false, the
		entire expression evaluates to the value given in the
		[[else]] clause.
	</description>
	<note>
		The [[*]] operator is short-circuited.
		If the condition given in the [[if]] clause is true, only
		the expression given in the [[then]] clause is evaluated.
		If the condition given in the [[if]] clause is false, only
		the expression given in the [[else]] clause is evaluated.
		Never are both expressions evaluated.
		(This has considerable implications if either expression
		calls a function that has side-effects.)
	</note>
	<see-also>[[cs:if]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">new</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">a new</name>
	<precedence>unary</precedence>
	<syntax>[[*]] {type}</syntax>
	<description-short>Construction of user-defined objects</description-short>
	<description>
		The [[*]] operator constructs a new instance of a user-defined object.
	</description>
	<see-also>[[cm:create]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">−</name>
	<precedence>unary</precedence>
	<syntax>[[*]] {factor}</syntax>
	<syntax-note>{Factor} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].</syntax-note>
	<description-short>Negation for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the negation of the given value.
		If the given value was positive, the evaluated value will be negative,
		and vice versa.
	</description>
	<note>
		The data type of the evaluated value will be the same as the data type of the given value.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">not</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">!</name>
	<precedence>unary</precedence>
	<syntax>[[*]] {factor}</syntax>
	<syntax-note>{Factor} yields a [[dt:boolean]].</syntax-note>
	<description-short>Logical negation for boolean values</description-short>
	<description>
		The [[*]] operator evaluates to the logical negation of the given value.
		If the given value is [[cn:true]], the evaluated value will be [[cn:false]],
		and vice versa.
	</description>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">bitnot</name>
	<precedence>unary</precedence>
	<syntax>[[*]] {factor}</syntax>
	<syntax-note>{Factor} yields an [[dt:integer]].</syntax-note>
	<description-short>Bitwise negation</description-short>
	<description>
		The [[*]] operator evaluates to the bitwise NOT of the given value.
		Each bit in the resulting value will be opposite the corresponding bit
		in the given value.
	</description>
	<note>
		The expression [[bitnot ]]{x} is equivalent to [[-]]{x}[[-1]] when
		{x} is an [[dt:integer]].
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">there is an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">there is a</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">there's an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">there's a</name>
	<precedence>unary</precedence>
	<syntax>[[*]] {factor}</syntax>
	<syntax-note>
		{Factor} is a descriptor.
	</syntax-note>
	<description-short>Boolean test for existence</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if a variant with the given
		descriptor exists, or [[cn:false]] if no variant with the given descriptor
		exists.
	</description>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">there is not an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">there is not a</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">there is no</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">there's no</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">there isn't an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">there isn't a</name>
	<precedence>unary</precedence>
	<syntax>[[*]] {factor}</syntax>
	<syntax-note>
		{Factor} yields a descriptor.
	</syntax-note>
	<description-short>Boolean test for existence</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:false]] if a variant with the given
		descriptor exists, or [[cn:true]] if no variant with the given descriptor
		exists.
	</description>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">^</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">**</name>
	<precedence>exponentiation</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Exponentiation for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the exponentiation of the two given values.
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
	<note>
		The [[*]] operator has mathematically correct associativity but mathematically {incorrect} precedence.
		The expression [[2^3^2]] evaluates to the mathematically correct 512 ([[2^(3^2)]])
		rather than the mathematically incorrect 64 ([[(2^3)^2]]); however,
		the expression [[-2^2]] evaluates to the mathematically incorrect 4 ([[(-2)^2]])
		rather than the mathematically correct -4 ([[-(2^2)]]).
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">*</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">·</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">×</name>
	<precedence>multiplication</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Multiplication for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the product of the two given values.
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">/</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">÷</name>
	<precedence>multiplication</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Division for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the quotient of the two given values.
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">quot</name>
	<precedence>multiplication</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Division for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the truncated quotient of the two given values.
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
	<note>
		The expression {x}[[ quot ]]{y} is equivalent to [[trunc(]]{x}[[/]]{y}[[)]].
	</note>
	<see-also>[[op:div]], [[fn:trunc]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">%</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">rem</name>
	<precedence>multiplication</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Modulus for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the remainder after division of the two given values.
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
	<note>
		The expression {x}[[ rem ]]{y} is equivalent to {x}[[ - ]]{y}[[ * trunc(]]{x}[[/]]{y}[[)]].
	</note>
	<see-also>[[op:mod]], [[fn:trunc]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">div</name>
	<precedence>multiplication</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Division for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the floor of the quotient of the two given values.
		(In HyperTalk, the [[*]] operator evaluates to the truncated quotient instead.)
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
	<note>
		In XION, the expression {x}[[ div ]]{y} is equivalent to [[floor(]]{x}[[/]]{y}[[)]].
	</note>
	<note>
		In HyperTalk, the expression {x}[[ div ]]{y} is equivalent to [[trunc(]]{x}[[/]]{y}[[)]].
		What HyperTalk calls the [[op:div]] operator is implemented in XION as the [[op:quot]] operator instead.
		This does not change the value of the operator for positive values, but does change the value of the operator for negative values.
	</note>
	<see-also>[[op:quot]], [[fn:floor]], [[fn:trunc]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">mod</name>
	<precedence>multiplication</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Modulus for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the modulus of the two given values.
		(In HyperTalk, the [[*]] operator evaluates to the remainder after division instead.)
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
	<note>
		In XION, the expression {x}[[ mod ]]{y} is equivalent to {x}[[ - ]]{y}[[ * floor(]]{x}[[/]]{y}[[)]].
	</note>
	<note>
		In HyperTalk, the expression {x}[[ mod ]]{y} is equivalent to {x}[[ - ]]{y}[[ * trunc(]]{x}[[/]]{y}[[)]].
		What HyperTalk calls the [[op:mod]] operator is implemented in XION as the [[op:rem]] operator instead.
		This does not change the value of the operator for positive values, but does change the value of the operator for negative values.
	</note>
	<see-also>[[op:rem]], [[fn:floor]], [[fn:trunc]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">+</name>
	<precedence>addition</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Addition for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the sum of the two given values.
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">-</name>
	<precedence>addition</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description-short>Subtraction for numbers</description-short>
	<description>
		The [[*]] operator evaluates to the difference between the two given values.
	</description>
	<note>
		If either given value is a [[dt:complex]], the evaluated value will be a [[dt:complex]].
		Otherwise, the evaluated value will be a [[dt:number]].
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">&lt;&lt;</name>
	<precedence>bit shift</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s.</syntax-note>
	<description-short>Bitwise shift</description-short>
	<description>
		The [[*]] operator shifts a given value a specified number of bits to the left.
	</description>
	<note>
		The expression {x}[[ &lt;&lt; ]]{y} is more or less equivalent to {x}[[ * 2^]]{y} when
		{x} and {y} are integers, provided the result is in the range of the [[dt:integer]] type.
	</note>
	<note>
		In OpenXION, since the [[dt:integer]] type has arbitrary range, no bits will ever be lost, nor will the value ever change sign.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">&gt;&gt;</name>
	<precedence>bit shift</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s.</syntax-note>
	<description-short>Bitwise shift</description-short>
	<description>
		The [[*]] operator shifts a given value a specified number of bits to the right,
		filling in the missing bits with the highest bit. In other words, the sign is
		preserved using sign extension.
	</description>
	<note>
		The expression {x}[[ &gt;&gt; ]]{y} is more or less equivalent to [[floor(]]{x}[[ / 2^]]{y}[[)]] when
		{x} and {y} are integers.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">&gt;&gt;&gt;</name>
	<precedence>bit shift</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s.</syntax-note>
	<description-short>Bitwise shift</description-short>
	<description>
		The [[*]] operator shifts a given value a specified number of bits to the right,
		filling in the missing bits with zeroes. In other words, no sign extension is used.
	</description>
	<note>
		The expression {x}[[ &gt;&gt;&gt; ]]{y} is more or less equivalent to [[floor(]]{x}[[ / 2^]]{y}[[)]] when
		{x} and {y} are positive integers.
	</note>
	<note>
		In OpenXION, since the [[dt:integer]] type has arbitrary range, this operator a synonym of [[op:&gt;&gt;]].
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">bitand</name>
	<precedence>bitwise and</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s.</syntax-note>
	<description-short>Bitwise AND</description-short>
	<description>
		The [[*]] operator evaluates to the bitwise AND of the two given values.
		Each bit in the evaluated value will be set only if both of the corresponding bits
		from each of the given values is set.
	</description>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">bitxor</name>
	<precedence>bitwise xor</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s.</syntax-note>
	<description-short>Bitwise XOR</description-short>
	<description>
		The [[*]] operator evaluates to the bitwise exclusive OR of the two given values.
		Each bit in the evaluated value will be set only if only one of the corresponding bits
		from each of the given values is set.
	</description>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">bitor</name>
	<precedence>bitwise or</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:integer]]s.</syntax-note>
	<description-short>Bitwise OR</description-short>
	<description>
		The [[*]] operator evaluates to the bitwise OR of the two given values.
		Each bit in the evaluated value will be set if either or both of the corresponding bits
		from each of the given values is set.
	</description>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">&amp;</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">||</name>
	<precedence>string concatenation</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Concatenation for strings</description-short>
	<description>
		The [[*]] operator evaluates to the concatenation of the two given strings.
	</description>
	<see-also>[[op:&amp;&amp;]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">&amp;&amp;</name>
	<precedence>string concatenation</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Concatenation for strings</description-short>
	<description>
		The [[*]] operator evaluates to the concatenation of the two given strings with a space between the two strings.
	</description>
	<see-also>[[op:&amp;]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">::</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">:</name>
	<precedence>list concatenation</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Concatenation for lists</description-short>
	<description>
		The [[*]] operator evaluates to the concatenation of the two given lists.
		If either given value is a single value rather than a list,
		it will be converted to a list of one value before being concatenated.
	</description>
	<see-also>[[op:,]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">&lt;</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">comes before</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is less than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is smaller than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is fewer than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is before</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator compares the two given values.
		If the first value is less than the second, the [[*]] operator evaluates to [[cn:true]].
		If the first value is greater than or equal to the second, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		If both given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If both given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">&gt;</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">comes after</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is greater than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is bigger than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is more than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is after</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator compares the two given values.
		If the first value is greater than the second, the [[*]] operator evaluates to [[cn:true]].
		If the first value is less than or equal to the second, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		If both given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If both given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">≤</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">&lt;=</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">=&lt;</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not greater than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not bigger than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not more than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not after</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't greater than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't bigger than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't more than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't after</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator compares the two given values.
		If the first value is less than or equal to the second, the [[*]] operator evaluates to [[cn:true]].
		If the first value is greater than the second, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		If both given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If both given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">≥</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">=&gt;</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">&gt;=</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not less than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not smaller than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not fewer than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not before</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't less than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't smaller than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't fewer than</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't before</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator compares the two given values.
		If the first value is greater than or equal to the second, the [[*]] operator evaluates to [[cn:true]].
		If the first value is less than the second, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		If both given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If both given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">lt</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator compares the two given values as strings.
		If the first string is less than the second, the [[*]] operator evaluates to [[cn:true]].
		If the first string is greater than or equal to the second, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">gt</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator
	</description>
	<description>
		The [[*]] operator compares the two given values as strings.
		If the first string is greater than the second, the [[*]] operator evaluates to [[cn:true]].
		If the first string is less than or equal to the second, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">le</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator compares the two given values as strings.
		If the first string is less than or equal to the second, the [[*]] operator evaluates to [[cn:true]].
		If the first string is greater than the second, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">ge</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator compares the two given values as strings.
		If the first string is greater than or equal to the second, the [[*]] operator evaluates to [[cn:true]].
		If the first string is less than the second, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">between</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is between</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression} and {expression}</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} leftinclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} left-inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} left inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} rightinclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} right-inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} right inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} exclusive</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator compares the given value on the left to the two given values on the right.
		If the first given value falls between the second and third, the [[*]] operator evaluates to [[cn:true]].
		Otherwise the [[*]] operator evaluates to [[cn:false]].
	</description>
	<description>
		The [[inclusive]], [[left-inclusive]], [[right-inclusive]], and [[exclusive]] options specify the [[*]] operator's
		behavior when the first value is equal to the second or third. If the first value is equal to the second,
		[[*]] will evaluate to [[cn:true]] only if [[inclusive]] or [[left-inclusive]] is specified. If the first value
		is equal to the third, [[*]] will evaluate to [[cn:true]] only if [[inclusive]] or [[right-inclusive]] is specified.
		If none of these options is specified, [[inclusive]] is assumed to be the default.
	</description>
	<note>
		If all given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If all given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not between</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't between</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">not between</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression} and {expression}</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} leftinclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} left-inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} left inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} rightinclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} right-inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} right inclusive</syntax>
	<syntax>{expression} [[*]] {expression} and {expression} exclusive</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator compares the given value on the left to the two given values on the right.
		If the first given value falls between the second and third, the [[*]] operator evaluates to [[cn:false]].
		Otherwise the [[*]] operator evaluates to [[cn:true]].
	</description>
	<description>
		The [[inclusive]], [[left-inclusive]], [[right-inclusive]], and [[exclusive]] options specify the [[*]] operator's
		behavior when the first value is equal to the second or third. If the first value is equal to the second,
		[[*]] will evaluate to [[cn:false]] only if [[inclusive]] or [[left-inclusive]] is specified. If the first value
		is equal to the third, [[*]] will evaluate to [[cn:false]] only if [[inclusive]] or [[right-inclusive]] is specified.
		If none of these options is specified, [[inclusive]] is assumed to be the default.
	</description>
	<note>
		If all given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If all given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">contains</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the string to the left of the operator
		contains the string to the right of the operator as a substring.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csoffset]] function.
	</note>
	<see-also>[[op:is in]], [[op:starts with]], [[op:ends with]]</see-also>
	<see-also>[[op:does not contain]], [[op:is not in]], [[op:does not start with]], [[op:does not end with]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">begins with</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">starts with</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the string to the left of the operator
		starts with the string to the right of the operator.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csoffset]] function.
	</note>
	<see-also>[[op:contains]], [[op:is in]], [[op:ends with]]</see-also>
	<see-also>[[op:does not contain]], [[op:is not in]], [[op:does not start with]], [[op:does not end with]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">ends with</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the string to the left of the operator
		ends with the string to the right of the operator.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csoffset]] function.
	</note>
	<see-also>[[op:contains]], [[op:is in]], [[op:starts with]]</see-also>
	<see-also>[[op:does not contain]], [[op:is not in]], [[op:does not start with]], [[op:does not end with]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is in</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is of</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the string to the right of the operator
		contains the string to the left of the operator as a substring.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csoffset]] function.
	</note>
	<see-also>[[op:contains]], [[op:starts with]], [[op:ends with]]</see-also>
	<see-also>[[op:does not contain]], [[op:is not in]], [[op:does not start with]], [[op:does not end with]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is within</name>
	<precedence>relational</precedence>
	<syntax>{left-expression} [[*]] {right-expression}</syntax>
	<syntax-note>{Left-expression} yields a [[dt:point]] or a [[dt:rectangle]]. {Right-expression} yields a [[dt:rectangle]].</syntax-note>
	<description-short>Boolean test for point within rectangle</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the [[dt:rectangle]] specified
		on the right of the operator contains the [[dt:point]] specified on the left,
		or intersects the [[dt:rectangle]] specified on the left.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<see-also>[[op:is not within]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is an element of</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is an element in</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {list}</syntax>
	<description-short>Comparison for lists</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if any of the items in the given list
		are equal to the given single value.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<see-also>[[op:is precisely an element of]], [[op:is not an element of]], [[op: is not precisely an element of]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is precisely an element of</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is precisely an element in</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {list}</syntax>
	<description-short>Comparison for lists</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if any of the items in the given list
		are the same type as and identical to the given single value.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<see-also>[[op:is an element of]], [[op:is not an element of]], [[op: is not precisely an element of]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">does not contain</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">doesn't contain</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the string to the left of the operator
		{does not} contain the string to the right of the operator as a substring.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csoffset]] function.
	</note>
	<see-also>[[op:is not in]], [[op:does not start with]], [[op:does not end with]]</see-also>
	<see-also>[[op:contains]], [[op:is in]], [[op:starts with]], [[op:ends with]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">does not begin with</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">does not start with</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">doesn't begin with</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">doesn't start with</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the string to the left of the operator
		{does not} start with the string to the right of the operator.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csoffset]] function.
	</note>
	<see-also>[[op:does not contain]], [[op:is not in]], [[op:does not end with]]</see-also>
	<see-also>[[op:contains]], [[op:is in]], [[op:starts with]], [[op:ends with]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">does not end with</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">doesn't end with</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the string to the left of the operator
		{does not} end with the string to the right of the operator.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csoffset]] function.
	</note>
	<see-also>[[op:does not contain]], [[op:is not in]], [[op:does not start with]]</see-also>
	<see-also>[[op:contains]], [[op:is in]], [[op:starts with]], [[op:ends with]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is not in</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is not of</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't in</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't of</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the string to the right of the operator
		{does not} contain the string to the left of the operator as a substring.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csoffset]] function.
	</note>
	<see-also>[[op:does not contain]], [[op:does not start with]], [[op:does not end with]]</see-also>
	<see-also>[[op:contains]], [[op:is in]], [[op:starts with]], [[op:ends with]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is not within</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't within</name>
	<precedence>relational</precedence>
	<syntax>{left-expression} [[*]] {right-expression}</syntax>
	<syntax-note>{Left-expression} yields a [[dt:point]] or a [[dt:rectangle]]. {Right-expression} yields a [[dt:rectangle]].</syntax-note>
	<description-short>Boolean test for point within rectangle</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the [[dt:rectangle]] specified
		on the right of the operator {does not} contain the [[dt:point]] specified on the left,
		or {does not} intersect the [[dt:rectangle]] specified on the left.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<see-also>[[op:is within]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not an element of</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not an element in</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't an element of</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't an element in</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {list}</syntax>
	<description-short>Comparison for lists</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if none of the items in the given list
		are equal to the given single value.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<see-also>[[op:is an element of]], [[op:is precisely an element of]], [[op: is not precisely an element of]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not precisely an element of</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not precisely an element in</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't precisely an element of</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't precisely an element in</name>
	<precedence>relational</precedence>
	<syntax>{expression} [[*]] {list}</syntax>
	<description-short>Comparison for lists</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if none of the items in the given list
		are the same type as and identical to the given single value.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<see-also>[[op:is an element of]], [[op:is precisely an element of]], [[op: is not an element of]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is a</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isa</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">instanceof</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">are</name>
	<precedence>polymorphic</precedence>
	<syntax>{expression} [[*]] {type}</syntax>
	<description-short>Comparison for types</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the given value can be converted to the given type.
		If the given value cannot be converted to the given type, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		In HyperTalk, you can only use [[*]] to test if some value is an [[dt:integer]], a [[dt:number]],
		a [[dt:date]], a [[dt:point]], or a [[dt:rectangle]]. However, the test for a [[dt:date]] will
		accept just about any string to the point of being nearly useless, and the tests for [[dt:point]]
		and [[dt:rectangle]] are broken: if the value is not a comma-delimited list of integers, the
		expression will trigger an "Expected integer here" script error instead of evaluating to [[cn:false]].
		XION will only consider something a [[dt:date]] if it can actually be converted to one, and
		will never trigger a script error when evaluating the [[*]] operator.
	</note>
	<see-also>[[op:is not a]], [[op:is precisely a]], [[op:is not precisely a]], [[op:as a]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">are precisely</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is precisely an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is precisely a</name>
	<precedence>polymorphic</precedence>
	<syntax>{expression} [[*]] {type}</syntax>
	<description-short>Comparison for types</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the given value's data type is the given type.
		If the given value's data type is not the given type, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<see-also>[[op:is a]], [[op:is not a]], [[op:is not precisely a]], [[op:as a]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is not an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is not a</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't a</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">are not</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">aren't</name>
	<precedence>polymorphic</precedence>
	<syntax>{expression} [[*]] {type}</syntax>
	<description-short>Comparison for types</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the given value {cannot} be converted to the given type.
		If the given value {can} be converted to the given type, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<note>
		In HyperTalk, you can only use [[*]] to test if some value is not an [[dt:integer]], a [[dt:number]],
		a [[dt:date]], a [[dt:point]], or a [[dt:rectangle]]. However, the test for a [[dt:date]] will
		reject just about any string to the point of being nearly useless, and the tests for [[dt:point]]
		and [[dt:rectangle]] are broken: if the value is not a comma-delimited list of integers, the
		expression will trigger an "Expected integer here" script error instead of evaluating to [[cn:true]].
		XION will always consider something not a [[dt:date]] if it cannot actually be converted to one, and
		will never trigger a script error when evaluating the [[*]] operator.
	</note>
	<see-also>[[op:is a]], [[op:is precisely a]], [[op:is not precisely a]], [[op:as a]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">are not precisely</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">aren't precisely</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not precisely an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not precisely a</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't precisely an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't precisely a</name>
	<precedence>polymorphic</precedence>
	<syntax>{expression} [[*]] {type}</syntax>
	<description-short>Comparison for types</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the given value's data type is {not} the given type.
		If the given value's data type {is} the given type, the [[*]] operator evaluates to [[cn:false]].
	</description>
	<see-also>[[op:is a]], [[op:is not a]], [[op:is precisely a]], [[op:as a]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">as an</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">as a</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">as</name>
	<precedence>polymorphic</precedence>
	<syntax>{expression} [[*]] {type}</syntax>
	<description-short>Comparison for types</description-short>
	<description>
		The [[*]] operator converts the given value to the given data type.
		If the given value cannot be converted to the given data type, a script error is triggered.
	</description>
	<note>
		To avoid triggering a script error, use the [[op:is a]] operator before trying to convert values.
	</note>
	<see-also>[[op:is a]], [[op:is not a]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">=</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">==</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">equals</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is equal to</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is</name>
	<precedence>equivalence</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the given values are equal.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		If both given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If both given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison with the [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function or the [[op:===]] operator.
	</note>
	<see-also>[[op:===]], [[op:eq]], [[op:strcmp]], [[op:csstrcmp]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">===</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is exactly</name>
	<precedence>equivalence</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the given values have the same type and are identical.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		String comparison with the [[*]] operator is case-sensitive. For case-insensitive comparison use the [[op:=]] or [[op:eq]] operator.
	</note>
	<see-also>[[op:=]], [[op:eq]], [[op:strcmp]], [[op:csstrcmp]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">eq</name>
	<precedence>equivalence</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:true]] if the given values are equal as strings.
		Otherwise it evaluates to [[cn:false]].
	</description>
	<note>
		String comparison with the [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function or the [[op:===]] operator.
	</note>
	<see-also>[[op:=]], [[op:===]], [[op:strcmp]], [[op:csstrcmp]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">&lt;&gt;</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">≠≠</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">≠</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">!=</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">does not equal</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">doesn't equal</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not equal to</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">is not</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't equal to</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't</name>
	<precedence>equivalence</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:false]] if the given values are equal.
		Otherwise it evaluates to [[cn:true]].
	</description>
	<note>
		If both given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If both given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison with the [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function or the [[op:!==]] operator.
	</note>
	<see-also>[[op:!==]], [[op:ne]], [[op:strcmp]], [[op:csstrcmp]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">!==</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">≠≠≠</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">is not exactly</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">isn't exactly</name>
	<precedence>equivalence</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:false]] if the given values have the same type and are identical.
		Otherwise it evaluates to [[cn:true]].
	</description>
	<note>
		String comparison with the [[*]] operator is case-sensitive. For case-insensitive comparison use the [[op:!=]] or [[op:ne]] operator.
	</note>
	<see-also>[[op:!=]], [[op:ne]], [[op:strcmp]], [[op:csstrcmp]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">ne</name>
	<precedence>equivalence</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to [[cn:false]] if the given values are equal as strings.
		Otherwise it evaluates to [[cn:true]].
	</description>
	<note>
		String comparison with the [[*]] operator is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function or the [[op:!==]] operator.
	</note>
	<see-also>[[op:!=]], [[op:!==]], [[op:strcmp]], [[op:csstrcmp]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">&lt;=&gt;</name>
	<precedence>equivalence</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for numbers or strings</description-short>
	<description>
		The [[*]] operator evaluates to the comparison of the two given values.
		The evaluated value will be negative if the first given value is less than the second given value,
		positive if the first is greater than the second, and zero if the first is equal to the second.
	</description>
	<note>
		If both given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If both given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
	<see-also>[[op:cmp]], [[fn:strcmp]], [[fn:csstrcmp]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">cmp</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">compared to</name>
	<precedence>equivalence</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<description-short>Comparison for strings</description-short>
	<description>
		The [[*]] operator evaluates to the comparison of the two given values as strings.
		The evaluated value will be negative if the first given value is less than the second given value,
		positive if the first is greater than the second, and zero if the first is equal to the second.
	</description>
	<note>
		String comparison is case-insensitive. For case-sensitive comparison use the [[fn:csstrcmp]] function.
	</note>
	<see-also>[[op:&lt;=&gt;]], [[fn:strcmp]], [[fn:csstrcmp]]</see-also>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">and</name>
	<precedence>boolean and</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:boolean]]s.</syntax-note>
	<description-short>Logical for boolean values</description-short>
	<description>
		The [[*]] operator evaluates to the logical AND of the given boolean values.
		Both values must be [[cn:true]] for the expression to evaluate to [[cn:true]].
		If either value is [[cn:false]], the expression will evaluate to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is {not} short-circuited. Both expressions will be evaluated
		to determine the truth value of the whole expression.
		(This has considerable implications if either expression calls a function that has side-effects.
		For a short-circuited version of the [[*]] operator, use the [[op:&amp;&amp;&amp;]] operator.)
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">&amp;&amp;&amp;</name>
	<precedence>boolean and</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:boolean]]s.</syntax-note>
	<description-short>Logical for boolean values</description-short>
	<description>
		The [[*]] operator evaluates to the logical AND of the given boolean values.
		Both values must be [[cn:true]] for the expression to evaluate to [[cn:true]].
		If either value is [[cn:false]], the expression will evaluate to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is short-circuited.
		If the first expression is [[cn:false]], the second expression will not be evaluated.
		Only when the first expression is [[cn:true]] will the second expression be evaluated
		to determine the truth value of the whole expression.
		(This has considerable implications if either expression calls a function that has side-effects.
		For a non-short-circuited version of the [[*]] operator, use the [[op:and]] operator.)
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">^^^</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">xor</name>
	<precedence>boolean xor</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:boolean]]s.</syntax-note>
	<description-short>Logical for boolean values</description-short>
	<description>
		The [[*]] operator evaluates to the logical exclusive OR of the given boolean values.
		Exactly one of the given values must be [[cn:true]] for the expression to evaluate to [[cn:true]].
		If both values are [[cn:true]] or both values are [[cn:false]], the expression will evaluate to [[cn:false]].
	</description>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">or</name>
	<precedence>boolean or</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:boolean]]s.</syntax-note>
	<description-short>Logical for boolean values</description-short>
	<description>
		The [[*]] operator evaluates to the logical OR of the given boolean values.
		Either one value or both values must be [[cn:true]] for the expression to evaluate to [[cn:true]].
		If both values are [[cn:false]], the expression will evaluate to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is {not} short-circuited. Both expressions will be evaluated
		to determine the truth value of the whole expression.
		(This has considerable implications if either expression calls a function that has side-effects.
		For a short-circuited version of the [[*]] operator, use the [[op:|||]] operator.)
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">|||</name>
	<precedence>boolean or</precedence>
	<syntax>{expression} [[*]] {expression}</syntax>
	<syntax-note>Both {expression}s yield [[dt:boolean]]s.</syntax-note>
	<description-short>Logical for boolean values</description-short>
	<description>
		The [[*]] operator evaluates to the logical OR of the given boolean values.
		Either one value or both values must be [[cn:true]] for the expression to evaluate to [[cn:true]].
		If both values are [[cn:false]], the expression will evaluate to [[cn:false]].
	</description>
	<note>
		The [[*]] operator is short-circuited.
		If the first expression is [[cn:true]], the second expression will not be evaluated.
		Only when the first expression is [[cn:false]] will the second expression be evaluated
		to determine the truth value of the whole expression.
		(This has considerable implications if either expression calls a function that has side-effects.
		For a non-short-circuited version of the [[*]] operator, use the [[op:or]] operator.)
	</note>
</operator>

<operator>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">,</name>
	<precedence>list construction</precedence>
	<syntax>{expression} [[*]] {expression} [[*]] {expression} [[*]] {expression} ...</syntax>
	<description-short>Construction of lists</description-short>
	<description>
		The [[*]] operator is used to create a list. The [[*]] operator delimits
		the elements that will eventually be put into the list. The expression
		will evaluate to the constructed list.
	</description>
	<see-also>[[op::]]</see-also>
</operator>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">to create</name>
	<syntax>[[to create]]\\[[  ]]{statementList}\\[[end create]]</syntax>
	<description>
		The [[*]] handler defines the behavior of a user-defined object when it is created.
		When a script requests the creation of a user-defined object, the object is created,
		then the object is assigned a number, an id, and a name, then the statements in the [[*]]
		handler are executed.
	</description>
	<note>
		This structure is only valid inside an [[cs:object type]] structure.
	</note>
	<see-also>[[cs:object type]], [[cm:create]], [[op:new]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">to delete</name>
	<syntax>[[to delete]]\\[[  ]]{statementList}\\[[end delete]]</syntax>
	<description>
		The [[*]] handler defines the behavior of a user-defined object when it is deleted.
		When a script requests the deletion of a user-defined object, the statements in the
		[[*]] handler are executed, then the object is destroyed, then other objects are
		assigned new numbers.
	</description>
	<note>
		This structure is only valid inside an [[cs:object type]] structure.
	</note>
	<see-also>[[cs:object type]], [[cm:delete]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">to get contents</name>
	<syntax>[[to get contents]]\\[[  ]]{statementList}\\[[end get]]</syntax>
	<description>
		The [[*]] handler defines the behavior of a user-defined object when its contents
		are accessed or it is converted to a string. When a script requests the contents
		of a user-defined object, or converts the object to a string, the statements in the
		[[*]] handler are executed, and the return value of the handler becomes the resulting
		string.
	</description>
	<description>
		If no [[*]] handler is defined for a user-defined object type, objects of that type
		cannot be accessed as containers, and converting an object of that type to a string results
		in a descriptor for that object.
	</description>
	<note>
		This structure is only valid inside an [[cs:object type]] structure.
	</note>
	<see-also>[[cs:object type]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">to put contents</name>
	<syntax>[[to put ]]{variableName}[[ into contents]]\\[[  ]]{statementList}\\[[end put]]</syntax>
	<syntax>[[to put ]]{variableName}[[ before contents]]\\[[  ]]{statementList}\\[[end put]]</syntax>
	<syntax>[[to put ]]{variableName}[[ after contents]]\\[[  ]]{statementList}\\[[end put]]</syntax>
	<description>
		The [[*]] handler defines the behavior of a user-defined object when its contents
		are modified by the [[cm:put]] command. When a script modifies the contents of a
		user-defined object, the statements in the [[*]] handler are executed. The value
		being put into, before, or after the object's contents is passed through the local
		variable {variableName}.
	</description>
	<description>
		If no [[*]] handler is defined for a user-defined object type, objects of that type
		cannot be modified as containers.
	</description>
	<note>
		Unlike parameters to an [[cs:on]] or a [[cs:function]] handler, which are converted
		to [[dt:string]]s unless declared otherwise, the parameter to a [[*]] handler is
		kept as-is, as if declared as a [[dt:variant]].
	</note>
	<note>
		This structure is only valid inside an [[cs:object type]] structure.
	</note>
	<see-also>[[cs:object type]], [[cm:put]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">to get</name>
	<syntax>[[to get ]]{propertyName}\\[[  ]]{statementList}\\[[end get]]</syntax>
	<description>
		The [[*]] handler defines the behavior of a user-defined object when property
		{propertyName} is accessed. When a script requests [[the ]]{propertyName}[[ of]]
		a user-defined object, the statements in the corresponding [[*]] handler are
		executed, and the return value of the handler becomes the value of the property.
	</description>
	<note>
		This structure is only valid inside an [[cs:object type]] structure.
	</note>
	<see-also>[[cs:object type]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">to set</name>
	<syntax>[[to set ]]{propertyName}[[ to ]]{variableName}\\[[  ]]{statementList}\\[[end set]]</syntax>
	<description>
		The [[*]] handler defines the behavior of a user-defined object when property
		{propertyName} is changed. When a script sets [[the ]]{propertyName}[[ of]] a
		user-defined object, the statements in the corresponding [[*]] handler are
		executed. The new value of the property is passed through the local variable
		{variableName}.
	</description>
	<note>
		Unlike parameters to an [[cs:on]] or a [[cs:function]] handler, which are converted
		to [[dt:string]]s unless declared otherwise, the parameter to a [[*]] handler is
		kept as-is, as if declared as a [[dt:variant]].
	</note>
	<note>
		This structure is only valid inside an [[cs:object type]] structure.
	</note>
	<see-also>[[cs:object type]], [[cm:set]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">object type</name>
	<syntax>[[object type ]]{typeNames}\\[[  ]]{handlerList}\\[[end ]]{firstTypeName}</syntax>
	<syntax>[[object type ]]{typeNames}[[ extends ]]{parentTypeName}\\[[  ]]{handlerList}\\[[end ]]{firstTypeName}</syntax>
	<syntax-note>
		{TypeNames} is a series of data type names, in which every name except the first
		is prefixed with the keyword [[cs:aka]] for a singular synonym or the keyword [[cs:pl]]
		for a plural name or synonym. Names can be more than one word long:
	</syntax-note>
	<syntax-note>[[object type fraction aka rational number pl fractions pl rational numbers]]</syntax-note>
	<syntax-note>
		{ParentTypeName} is the name of a data type to inherit handlers and properties from.
		{HandlerList} is a series of [[cs:on]], [[cs:function]], [[cs:to create]], [[cs:to delete]],
		[[cs:to get contents]], [[cs:to put contents]], [[cs:to get]], and/or [[cs:to set]] structures.
		{FirstTypeName} must be the first name that appears in {typeNames}.
	</syntax-note>
	<description>
		The [[*]] structure creates a new user-defined object type. The behavior
		of the created object type is defined by the handlers in {handlerList}.
	</description>
	<note>
		Attempting to create a new user-defined object type with the name of an existing
		data type (including object types previously defined with [[*]]) has no effect.
		No script error is triggered, and the data type maintains its previously defined behavior.
	</note>
	<see-also>
		[[cs:on]], [[cs:function]], [[cs:to create]], [[cs:to delete]],
		[[cs:to get contents]], [[cs:to put contents]], [[cs:to get]], [[cs:to set]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">aka</name>
	<description>
		The [[*]] keyword is part of the [[cs:object type]] structure.
		It identifies a singular synonym for a user-defined object type.
		See the description for [[cs:object type]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">pl</name>
	<description>
		The [[*]] keyword is part of the [[cs:object type]] structure.
		It identifies a plural name or synonym for a user-defined object type.
		See the description for [[cs:object type]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">extends</name>
	<description>
		The [[*]] keyword is part of the [[cs:object type]] structure.
		It identifies a parent data type for a user-defined object type.
		See the description for [[cs:object type]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">on</name>
	<syntax>[[on ]]{messageName}[[ ]]{parameterList}\\[[  ]]{statementList}\\[[end ]]{messageName}</syntax>
	<description>
		The [[*]] keyword identifies a message handler. Message handlers are written to define
		your own commands or modify or redefine what happens in response to a built-in command.
	</description>
	<description>
		When a message called {messageName} is sent to an object, the XION interpreter
		checks that object's script to see if it has a message handler called {messageName}.
		If it does, the object responds according to that handler, and the message is sent
		no further (unless the script has a [[cs:pass]] statement). If the object has no
		handler named {messageName}, the interpreter passes the message to the next object in
		the hierarchy.
	</description>
	<description>
		The statements in a handler execute until an [[cs:end]], [[cs:exit]], [[cs:pass]],
		[[cs:return]], or [[cs:throw]] keyword is reached. The return value of a message
		handler, if any, is accessible through the built-in function [[fn:result]].
	</description>
	<description>
		The optional {parameterList} allows the message handler to receive some values sent
		along with the message. This list is a series of local variable names separated by
		commas, each optionally followed by a data type and/or default value:
	</description>
	<description>
		{variableName}[[ as ]]{dataType}[[ is ]]{defaultValue}
	</description>
	<description>
		When the handler executes, each value is put into the parameter variable that
		appears in the corresponding position. If no value is specified for a parameter
		variable, the default value for that parameter variable (or [[cn:empty]] if no
		default value is specified) is put into that parameter variable.
	</description>
	<description>
		The default data type of a parameter if none is specified is [[dt:string]].
		Other data types, particularly [[dt:variant]], behave in a manner
		incompatible with HyperTalk, but that may be desirable.
		Specifically, passing a container to a handler with a parameter
		declared as [[dt:variant]] will pass the container itself to the handler,
		while passing a container to a handler with a parameter declared as
		[[dt:string]] will pass only that container's {contents}.
	</description>
	<note>
		HyperTalk does not support [[as]] or [[is]] in the parameter list.
		All parameter variables in HyperTalk are implicitly declared as
		[[dt:string]] with a default value of [[cn:empty]].
	</note>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">function</name>
	<syntax>[[function ]]{functionName}[[ ]]{parameterList}\\[[  ]]{statementList}\\[[end ]]{functionName}</syntax>
	<description>
		The [[*]] keyword identifies a function handler. Function handlers are written to define
		your own functions. Functions defined with function handlers must be called using parentheses
		rather than the [[kw:the]], [[kw:of]], or [[kw:in]] keywords.
	</description>
	<description>
		When a function called {functionName} is evaluated, the XION interpreter checks the script
		of the topmost object in the hierarchy to see if it has a function handler called {functionName}.
		If it does, the function handler executes, and the function call is sent no further (unless the
		script has a [[cs:pass]] statement). If the object has no handler named {functionName},
		the interpreter passes the function call to the next object in the hierarchy.
	</description>
	<description>
		The statements in a handler execute until an [[cs:end]], [[cs:exit]], [[cs:pass]],
		[[cs:return]], or [[cs:throw]] keyword is reached. The return value of a function
		handler becomes the value of the function where the function was originally called.
	</description>
	<description>
		The optional {parameterList} allows the function handler to receive some values sent
		along with the function call. This list is a series of local variable names separated by
		commas, each optionally followed by a data type and/or default value:
	</description>
	<description>
		{variableName}[[ as ]]{dataType}[[ is ]]{defaultValue}
	</description>
	<description>
		When the handler executes, each value is put into the parameter variable that
		appears in the corresponding position. If no value is specified for a parameter
		variable, the default value for that parameter variable (or [[cn:empty]] if no
		default value is specified) is put into that parameter variable.
	</description>
	<description>
		The default data type of a parameter if none is specified is [[dt:string]].
		Other data types, particularly [[dt:variant]], behave in a manner
		incompatible with HyperTalk, but that may be desirable.
		Specifically, passing a container to a handler with a parameter
		declared as [[dt:variant]] will pass the container itself to the handler,
		while passing a container to a handler with a parameter declared as
		[[dt:string]] will pass only that container's {contents}.
	</description>
	<note>
		User-defined functions are always followed by parentheses.
		Unlike built-in functions, user-defined functions cannot be called
		with [[kw:the]], [[kw:of]], or [[kw:in]].
	</note>
	<note>
		HyperTalk does not support [[as]] or [[is]] in the parameter list.
		All parameter variables in HyperTalk are implicitly declared as
		[[dt:string]] with a default value of [[cn:empty]].
	</note>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">repeat for each</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">repeat foreach</name>
	<syntax>[[*]] {variableName}[[ in ]]{expression}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax-note>{Expression} yields a [[dt:list]].</syntax-note>
	<description>
		The [[*]] structure causes all the statements inside to execute in a loop
		with as many iterations as there are elements in the list, with the specified
		variable containing the first element of the list during the first iteration,
		the second element of the list during the second iteration, and so on.
	</description>
	<example>[[*]] x in (1,2,3,4,5,6,7,8,9,10)\\  put x\\end repeat</example>
	<example>[[*]] x in words of "1 2 3 4 5 6 7 8 9 10"\\  put x\\end repeat</example>
	<see-also>
		[[cs:repeat for]], [[cs:repeat until]],
		[[cs:repeat while]], [[cs:repeat with]], [[cs:repeat]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">repeat for</name>
	<syntax>[[repeat for ]]{number}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat for ]]{number}[[ times]]\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax-note>{Number} yields a non-negative [[dt:integer]] specifying how many times the loop is executed.</syntax-note>
	<description>
		The [[*]] structure causes all the statements inside to execute in a loop
		with the specified number of iterations.
	</description>
	<example>put one into x\\repeat for 10 times\\  put x\\  add 1 to x\\end repeat</example>
	<see-also>
		[[cs:repeat for each]], [[cs:repeat foreach]], [[cs:repeat until]],
		[[cs:repeat while]], [[cs:repeat with]], [[cs:repeat]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">repeat until</name>
	<syntax>[[repeat until ]]{condition}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax-note>{Condition} is an expression that always yields [[cn:true]] or [[cn:false]].</syntax-note>
	<description>
		The [[*]] structure causes all the statements inside to execute in a loop
		repeated as long as the condition is [[cn:false]]. The condition is checked
		following each iteration of the loop. The statements inside are executed
		at least once.
	</description>
	<example>put one into x\\repeat until x > 10\\  put x\\  add 1 to x\\end repeat</example>
	<see-also>
		[[cs:repeat for each]], [[cs:repeat foreach]], [[cs:repeat for]],
		[[cs:repeat while]], [[cs:repeat with]], [[cs:repeat]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">repeat while</name>
	<syntax>[[repeat while ]]{condition}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax-note>{Condition} is an expression that always yields [[cn:true]] or [[cn:false]].</syntax-note>
	<description>
		The [[*]] structure causes all the statements inside to execute in a loop
		repeated as long as the condition is [[cn:true]]. The condition is checked
		preceding each iteration of the loop. The statements inside are not executed
		if the condition is [[cn:false]] at the beginning of the loop.
	</description>
	<example>put one into x\\repeat while x &lt;= 10\\  put x\\  add 1 to x\\end repeat</example>
	<see-also>
		[[cs:repeat for each]], [[cs:repeat foreach]], [[cs:repeat for]],
		[[cs:repeat until]], [[cs:repeat with]], [[cs:repeat]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">repeat with</name>
	<syntax>[[repeat with ]]{variable}[[ = ]]{start}[[ to ]]{finish}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat with ]]{variable}[[ = ]]{start}[[ to ]]{finish}[[ step ]]{increment}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat with ]]{variable}[[ = ]]{start}[[ down to ]]{finish}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat with ]]{variable}[[ = ]]{start}[[ down to ]]{finish}[[ step ]]{decrement}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat with ]]{variable}[[ = ]]{start}[[ downto ]]{finish}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat with ]]{variable}[[ = ]]{start}[[ downto ]]{finish}[[ step ]]{decrement}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax-note>
		{Variable} is a variable name or an expression yielding a variable name.
		{Start}, {finish}, {increment}, and {decrement} yield [[dt:number]]s.
	</syntax-note>
	<description>
		The [[*]] structure causes all the statements inside to execute in a loop
		in which {variable} contains the value {start} at the beginning of the loop
		and is incremented by {increment} (or decremented by {decrement}) with each
		iteration of the loop. Execution ends when {variable} contains the value {finish}.
		If no {increment} (or {decrement}) is given, it is assumed to be 1.
	</description>
	<example>repeat with x = 1 to 10\\  put x\\end repeat</example>
	<note>
		{Variable} can be any expression as long as it yields a valid variable name.
		In the following example, the variable actually used is called [[a]]:\\\\
		[[put "a b c" into x\\repeat with word 1 of x = 1 to 10\\  put a\\end repeat]]
	</note>
	<note>
		HyperTalk does not support the [[downto]] keyword. Use [[down to]] instead.
	</note>
	<note>
		HyperTalk does not support the [[step]] keyword, and only allows integer values.
		XION allows any real numeric value.
	</note>
	<see-also>
		[[cs:repeat for each]], [[cs:repeat foreach]], [[cs:repeat for]],
		[[cs:repeat until]], [[cs:repeat while]], [[cs:repeat]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">repeat</name>
	<syntax>[[repeat]]\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat forever]]\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat ]]{number}\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax>[[repeat ]]{number}[[ times]]\\[[  ]]{statementList}\\[[end repeat]]</syntax>
	<syntax-note>{Number} yields a non-negative [[dt:integer]] specifying how many times the loop is executed.</syntax-note>
	<description>
		The [[*]] structure without a number causes all the statements inside to execute in a loop
		until an [[cs:exit]], [[cs:pass]], [[cs:return]], or [[cs:throw]] keyword is reached.
		The [[*]] structure with a number causes all the statements inside to execute in a loop
		with the specified number of iterations.
	</description>
	<example>put zero into x\\repeat forever\\  add 1 to x\\  put x\\  if x is ten then exit repeat\\end repeat</example>
	<example>put one into x\\repeat 10\\  put x\\  add 1 to x\\end repeat</example>
	<see-also>
		[[cs:repeat for each]], [[cs:repeat foreach]], [[cs:repeat for]],
		[[cs:repeat until]], [[cs:repeat while]], [[cs:repeat with]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">if</name>
	<syntax>[[if ]]{condition}[[ then ]]{statement}</syntax>
	<syntax>[[if ]]{condition}\\[[then ]]{statement}</syntax>
	<syntax>[[if ]]{condition}[[ then]]\\[[  ]]{statementList}\\[[end if]]</syntax>
	<syntax>[[if ]]{condition}[[ then ]]{statement}[[ else ]]{statement}</syntax>
	<syntax>[[if ]]{condition}\\[[then ]]{statement}[[ else ]]{statement}</syntax>
	<syntax>[[if ]]{condition}\\[[then ]]{statement}\\[[else ]]{statement}</syntax>
	<syntax>[[if ]]{condition}[[ then]]\\[[  ]]{statementList}\\[[else ]]{statement}</syntax>
	<syntax>[[if ]]{condition}[[ then]]\\[[  ]]{statementList}\\[[else]]\\[[  ]]{statementList}\\[[end if]]</syntax>
	<syntax-note>{Condition} yields [[cn:true]] or [[cn:false]].</syntax-note>
	<description>
		The [[*]] structure tests for the specified condition and, if the condition
		is [[cn:true]], executes the statement or series of statements that follow.
		If the condition is [[cn:false]] and an [[else]] keyword is specified,
		the [[*]] structure executes the statement or series of statements that follow
		the [[else]] keyword instead.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">then</name>
	<description>
		The [[*]] keyword is part of the [[cs:if]] control structure.
		See the description for [[cs:if]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">else</name>
	<description>
		The [[*]] keyword is part of the [[cs:if]] control structure.
		See the description for [[cs:if]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">switch</name>
	<syntax>[[switch ]]{expression}\\[[case ]]{expression}\\[[  ]]{statementList}\\[[case ]]{expression}\\[[  ]]{statementList}\\...\\[[end switch]]</syntax>
	<syntax>[[switch ]]{expression}\\[[case ]]{expression}\\[[  ]]{statementList}\\[[case ]]{expression}\\[[  ]]{statementList}\\...\\[[default]]\\[[  ]]{statementList}\\[[end switch]]</syntax>
	<description>
		The [[*]] structure evaluates the specified expression and executes
		the series of statements underneath the corresponding [[cs:case]] clause
		with the same value. If no corresponding [[cs:case]] clause is found,
		the [[*]] structure executes the series of statements underneath the
		[[cs:default]] clause, if it exists.
	</description>
	<example>switch x\\case 1\\  put "x is 1"\\case 2\\  put "x is 2"\\case 3\\  put "x is 3"\\default\\  put "x is something else"\\end switch</example>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">case</name>
	<description>
		The [[*]] keyword is part of the [[cs:switch]] control structure.
		See the description for [[cs:switch]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">default</name>
	<description>
		The [[*]] keyword is part of the [[cs:switch]] control structure.
		See the description for [[cs:switch]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">tell</name>
	<syntax>[[tell ]]{object}[[ to ]]{statement}</syntax>
	<syntax>[[tell ]]{object}\\[[  ]]{statementList}\\[[end tell]]</syntax>
	<syntax-note>{Object} yields a variant that can respond to messages.</syntax-note>
	<description>
		The [[*]] structure executes the statement or statements that follow
		as messages sent to the specified object.
		Unlike the [[cs:pass]] statement, [[cs:tell]] returns to the handler
		or script containing the [[*]] structure after the messages have been
		intercepted.
	</description>
	<see-also>[[cs:send]], [[cs:pass]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">try</name>
	<syntax>[[try]]\\[[  ]]{statementList}\\[[catch ]]{variable}\\[[  ]]{statementList}\\[[end try]]</syntax>
	<syntax>[[try]]\\[[  ]]{statementList}\\[[catch ]]{variable}\\[[  ]]{statementList}\\[[finally]]\\[[  ]]{statementList}\\[[end try]]</syntax>
	<syntax>[[try]]\\[[  ]]{statementList}\\[[finally]]\\[[  ]]{statementList}\\[[end try]]</syntax>
	<description>
		The [[*]] structure attempts to execute the following statements.
		If a script error is triggered, instead of interrupting the script,
		the statements under the [[cs:catch]] clause, if specified, are executed.
		The text of the error message is stored in the specified {variable}.
		The statements under the [[cs:finally]] clause, if specified,
		are always executed regardless of whether or not a script error
		is triggered.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">catch</name>
	<description>
		The [[*]] keyword is part of the [[cs:try]] control structure.
		See the description for [[cs:try]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">finally</name>
	<description>
		The [[*]] keyword is part of the [[cs:try]] control structure.
		See the description for [[cs:try]] for details.
	</description>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">end</name>
	<description>
		The [[*]] keyword marks the end of an [[cs:object type]], [[cs:on]], [[cs:function]],
		[[cs:repeat]], [[cs:if]], [[cs:switch]], [[cs:tell]], or [[cs:try]] structure.
	</description>
	<note>
		If an [[*]] statement is used outside its corresponding structure,
		a script error is triggered.
	</note>
	<see-also>
		[[cs:object type]], [[cs:on]], [[cs:function]], [[cs:repeat]], [[cs:if]], [[cs:switch]], [[cs:tell]], [[cs:try]],
		[[cs:exit]], [[cs:pass]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">const</name>
	<syntax>const {constantName} = {constantValue}</syntax>
	<description>
		The [[*]] statement creates a new user-defined constant with the specified name
		and value.
	</description>
	<note>
		Attempting to create a new user-defined constant with the name of an existing
		constant (including constants previously defined with [[*]]) has no effect.
		No script error is triggered, and the constant maintains its previously defined value.
	</note>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">do</name>
	<syntax>do {script}</syntax>
	<syntax>do {script} as {scriptingLanguage}</syntax>
	<description>
		The [[*]] statement causes the XION interpreter to execute the specified
		string as an XION script. The string is executed as though it were inserted
		in place of the [[*]] statement.
	</description>
	<description>
		The [[as ]]{scriptingLanguage} form causes the XION interpreter to execute
		the specified string as a script in some other scripting language.
		HyperTalk supports AppleScript as well as any OSA-compliant scripting component.
		OpenXION supports AppleScript on Mac OS X, VBScript on Windows, and [[bash]],
		Perl, PHP, Python, and Ruby on Mac OS X and other systems other than Windows.
		The XION Scripting Language Standard does not require support for any
		particular external language; only support for the syntax.
	</description>
	<security>
		To execute arbitrary XION code, OpenXION's security settings must allow the [[DO_AND_VALUE]] security key.
		To execute code in other scripting languages, OpenXION's security settings must allow the [[EXTERNAL_SCRIPTS]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[fn:value]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">exit</name>
	<syntax>exit repeat</syntax>
	<syntax>exit if</syntax>
	<syntax>exit switch</syntax>
	<syntax>exit tell</syntax>
	<syntax>exit try</syntax>
	<syntax>exit {handlerName}</syntax>
	<syntax>exit to {object}</syntax>
	<syntax>exit to {object} with error {errorMessage}</syntax>
	<syntax-note>
		{HandlerName} is the name of the handler containing the [[*]] statement.
		{Object} yields the [[dt:interpreter]]. {ErrorMessage} yields any [[dt:string]].
	</syntax-note>
	<description>
		The [[*]] statement sends control to the end of the specified structure,
		ending execution of the control structure. Any statements not yet executed
		in the specified control structure are ignored, and execution continues
		after the [[cs:end]] of the control structure. The [[exit ]]{handlerName}
		form ends execution of an [[cs:on]] or [[cs:function]] structure.
	</description>
	<description>
		The [[exit to ]]{object} form causes the currently executing script to stop
		executing. No more statements are executed after an [[exit to ]]{object}, ever.
		The [[with error]] parameter allows extra information to be passed back to
		whatever initiated the execution of the script. OpenXION currently ignores
		this parameter.
	</description>
	<note>
		If an [[*]] statement is used outside its corresponding structure,
		a script error is triggered.
	</note>
	<see-also>
		[[cs:on]], [[cs:function]], [[cs:repeat]], [[cs:if]], [[cs:switch]], [[cs:tell]], [[cs:try]],
		[[cs:end]], [[cs:pass]]
	</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">global</name>
	<syntax>global {variableList}</syntax>
	<syntax-note>
		{VariableList} is a series of one or more variable names separated by
		commas, each optionally followed by a data type and/or initial value:
	</syntax-note>
	<syntax-note>{variableName}[[ as ]]{dataType}[[ is ]]{initialValue}</syntax-note>
	<description>
		The [[*]] keyword declares a given variable name as a global variable
		whose contents are available to any invocation of any handler in any object.
		If the variable has not already been declared or used, it is created to
		hold a value of the specified data type and initialized to the specified
		initial value. If the variable has been declared or used before, its contents
		remain unchanged.
	</description>
	<description>
		Changing the value of a global variable anywhere changes its value everywhere.
		The [[*]] keyword must be used in each handler or script in which the global
		variable is used.
	</description>
	<note>
		The following table illustrates the four different {variable scopes},
		[[cs:global]], [[cs:local]], [[cs:shared]], and [[cs:static]]:\\\\
		::TABLE
		[[cs:global]] :: is accessible to :: {any}  :: invocation of :: {any}  :: handler in :: {any}  :: object
		........................................................................................................
		[[cs:shared]] :: is accessible to :: {any}  :: invocation of :: {any}  :: handler in :: {this} :: object
		........................................................................................................
		[[cs:static]] :: is accessible to :: {any}  :: invocation of :: {this} :: handler in :: {this} :: object
		........................................................................................................
		[[cs:local]]  :: is accessible to :: {this} :: invocation of :: {this} :: handler in :: {this} :: object
		ELBAT::
	</note>
	<note>
		The default data type if none is specified is [[dt:string]].
		Other data types, particularly [[dt:variant]], behave in a manner
		incompatible with HyperTalk, but that may be desirable.
		Specifically, [[cm:put]]ting a container into a variable declared as
		[[dt:variant]] will put the container itself into the variable,
		while [[cm:put]]ting a container into a variable declared as
		[[dt:string]] will put the {contents} into the variable.
	</note>
	<note>
		The initial value of a variable, if not specified, is [[cn:empty]].
	</note>
	<note>
		HyperTalk does not support [[as]] or [[is]] in the variable list.
		All variables in HyperTalk are implicitly declared as
		[[dt:string]] with a default value of [[cn:empty]].
	</note>
	<see-also>[[cs:local]], [[cs:shared]], [[cs:static]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">local</name>
	<syntax>local {variableList}</syntax>
	<syntax-note>
		{VariableList} is a series of one or more variable names separated by
		commas, each optionally followed by a data type and/or initial value:
	</syntax-note>
	<syntax-note>{variableName}[[ as ]]{dataType}[[ is ]]{initialValue}</syntax-note>
	<description>
		The [[*]] keyword declares a given variable name as a local variable
		whose contents are available only to the current invocation of this
		particular handler in this particular object.
		If the variable has not already been declared or used, it is created to
		hold a value of the specified data type and initialized to the specified
		initial value. If the variable has been declared or used before, its contents
		remain unchanged.
	</description>
	<note>
		The following table illustrates the four different {variable scopes},
		[[cs:global]], [[cs:local]], [[cs:shared]], and [[cs:static]]:\\\\
		::TABLE
		[[cs:global]] :: is accessible to :: {any}  :: invocation of :: {any}  :: handler in :: {any}  :: object
		........................................................................................................
		[[cs:shared]] :: is accessible to :: {any}  :: invocation of :: {any}  :: handler in :: {this} :: object
		........................................................................................................
		[[cs:static]] :: is accessible to :: {any}  :: invocation of :: {this} :: handler in :: {this} :: object
		........................................................................................................
		[[cs:local]]  :: is accessible to :: {this} :: invocation of :: {this} :: handler in :: {this} :: object
		ELBAT::
	</note>
	<note>
		The default data type if none is specified is [[dt:string]].
		Other data types, particularly [[dt:variant]], behave in a manner
		incompatible with HyperTalk, but that may be desirable.
		Specifically, [[cm:put]]ting a container into a variable declared as
		[[dt:variant]] will put the container itself into the variable,
		while [[cm:put]]ting a container into a variable declared as
		[[dt:string]] will put the {contents} into the variable.
	</note>
	<note>
		The initial value of a variable, if not specified, is [[cn:empty]].
	</note>
	<see-also>[[cs:global]], [[cs:shared]], [[cs:static]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">shared</name>
	<syntax>shared {variableList}</syntax>
	<syntax-note>
		{VariableList} is a series of one or more variable names separated by
		commas, each optionally followed by a data type and/or initial value:
	</syntax-note>
	<syntax-note>{variableName}[[ as ]]{dataType}[[ is ]]{initialValue}</syntax-note>
	<description>
		The [[*]] keyword declares a given variable name as a shared variable
		whose contents are available to any invocation of any handler in this
		particular object.
		If the variable has not already been declared or used, it is created to
		hold a value of the specified data type and initialized to the specified
		initial value. If the variable has been declared or used before, its contents
		remain unchanged.
	</description>
	<description>
		Changing the value of a shared variable anywhere changes its value for this
		particular object.
		The [[*]] keyword must be used in each handler or script in which the shared
		variable is used.
	</description>
	<note>
		The following table illustrates the four different {variable scopes},
		[[cs:global]], [[cs:local]], [[cs:shared]], and [[cs:static]]:\\\\
		::TABLE
		[[cs:global]] :: is accessible to :: {any}  :: invocation of :: {any}  :: handler in :: {any}  :: object
		........................................................................................................
		[[cs:shared]] :: is accessible to :: {any}  :: invocation of :: {any}  :: handler in :: {this} :: object
		........................................................................................................
		[[cs:static]] :: is accessible to :: {any}  :: invocation of :: {this} :: handler in :: {this} :: object
		........................................................................................................
		[[cs:local]]  :: is accessible to :: {this} :: invocation of :: {this} :: handler in :: {this} :: object
		ELBAT::
	</note>
	<note>
		The default data type if none is specified is [[dt:string]].
		Other data types, particularly [[dt:variant]], behave in a manner
		incompatible with HyperTalk, but that may be desirable.
		Specifically, [[cm:put]]ting a container into a variable declared as
		[[dt:variant]] will put the container itself into the variable,
		while [[cm:put]]ting a container into a variable declared as
		[[dt:string]] will put the {contents} into the variable.
	</note>
	<note>
		The initial value of a variable, if not specified, is [[cn:empty]].
	</note>
	<see-also>[[cs:global]], [[cs:local]], [[cs:static]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">static</name>
	<syntax>static {variableList}</syntax>
	<syntax-note>
		{VariableList} is a series of one or more variable names separated by
		commas, each optionally followed by a data type and/or initial value:
	</syntax-note>
	<syntax-note>{variableName}[[ as ]]{dataType}[[ is ]]{initialValue}</syntax-note>
	<description>
		The [[*]] keyword declares a given variable name as a static variable
		whose contents are available to any invocation of this particular handler
		in this particular object.
		If the variable has not already been declared or used, it is created to
		hold a value of the specified data type and initialized to the specified
		initial value. If the variable has been declared or used before, its contents
		remain unchanged.
	</description>
	<note>
		The following table illustrates the four different {variable scopes},
		[[cs:global]], [[cs:local]], [[cs:shared]], and [[cs:static]]:\\\\
		::TABLE
		[[cs:global]] :: is accessible to :: {any}  :: invocation of :: {any}  :: handler in :: {any}  :: object
		........................................................................................................
		[[cs:shared]] :: is accessible to :: {any}  :: invocation of :: {any}  :: handler in :: {this} :: object
		........................................................................................................
		[[cs:static]] :: is accessible to :: {any}  :: invocation of :: {this} :: handler in :: {this} :: object
		........................................................................................................
		[[cs:local]]  :: is accessible to :: {this} :: invocation of :: {this} :: handler in :: {this} :: object
		ELBAT::
	</note>
	<note>
		The default data type if none is specified is [[dt:string]].
		Other data types, particularly [[dt:variant]], behave in a manner
		incompatible with HyperTalk, but that may be desirable.
		Specifically, [[cm:put]]ting a container into a variable declared as
		[[dt:variant]] will put the container itself into the variable,
		while [[cm:put]]ting a container into a variable declared as
		[[dt:string]] will put the {contents} into the variable.
	</note>
	<note>
		The initial value of a variable, if not specified, is [[cn:empty]].
	</note>
	<see-also>[[cs:global]], [[cs:local]], [[cs:shared]]</see-also>
</structure>

<structure>
	<name dialects="oxnb11,oxnb12">include</name>
	<syntax>include {scriptName}</syntax>
	<syntax>include {scriptName} once</syntax>
	<syntax>include {scriptName} with dialog</syntax>
	<syntax>include {scriptName} once with dialog</syntax>
	<syntax>include {scriptName} without dialog</syntax>
	<syntax>include {scriptName} once without dialog</syntax>
	<syntax-note>
		{ScriptName} yields the name or path of an XION script file.
	</syntax-note>
	<description>
		The [[*]] statement executes the statements contained in an XION script file.
		If the script file cannot be found, the user will be asked to locate it,
		unless the [[without dialog]] keyword is used. If the script file cannot be
		found and the user cancels or the [[without dialog]] keyword is used,
		nothing happens.
		(For a version that triggers a script error, see [[cs:require]].)
		If the [[once]] keyword is used and the script has been executed before,
		it will not be executed again.
	</description>
	<description>
		In OpenXION, the locations searched for included scripts are determined by
		the [[pr:includePaths]] property.
	</description>
	<note>
		The [[*]] statement as described here is specific to OpenXION.
	</note>
	<see-also>[[cs:require]], [[pr:includePaths]], [[fn:includePath]], [[fn:includeFile]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">next</name>
	<syntax>next repeat</syntax>
	<syntax>next case</syntax>
	<description>
		The [[next repeat]] statement sends control to the top of the next iteration
		of the loop. Any statements not yet executed in the current iteration are ignored.
	</description>
	<description>
		The [[next case]] statement sends control to the next [[cs:case]] clause of a
		[[cs:switch]] structure, regardless of the value associated with the [[cs:case]]
		clause. Any statements not yet executed in the current [[cs:case]] are ignored.
	</description>
	<description>
		If a [[*]] statement is used outside its corresponding structure,
		a script error is triggered.
	</description>
	<example>repeat 20\\  put random(9) into tempVar\\  if tempVar mod 2 = 0 then next repeat\\  put tempVar\\end repeat</example>
	<example>switch x\\case 1\\  next case\\case 2\\  next case\\case 3\\  put "x is 1, 2, or 3"\\case 4\\  put "x is 4"\\  next case\\  put "this is never printed"\\case 5\\  put "x is 4 or 5"\\default\\  put "x is something else"\\end switch</example>
	<note>
		HyperTalk does not support [[cs:switch]], therefore it does not support [[next case]].
	</note>
	<see-also>[[cs:repeat]], [[cs:switch]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">ordinal</name>
	<syntax>ordinal {ordinalName} = {index}</syntax>
	<syntax-note>{Index} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] statement creates a new user-defined ordinal with the specified name
		and index.
	</description>
	<note>
		Attempting to create a new user-defined ordinal with the name of an existing
		ordinal (including ordinals previously defined with [[*]]) has no effect.
		No script error is triggered, and the ordinal maintains its previously defined index.
	</note>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">pass</name>
	<syntax>pass {handlerName}</syntax>
	<syntax>pass to {object}</syntax>
	<syntax-note>
		{HandlerName} is the name of the handler containing the [[*]] statement.
		{Object} yields a [[dt:variant]] able to respond to messages.
	</syntax-note>
	<description>
		The [[*]] statement ends execution of the handler and sends the entire
		message or function call that initiated execution of the handler to the
		next object in the hierarchy.
	</description>
	<description>
		The [[pass to]] form ends execution of the handler and sends the entire
		message or function call that initiated execution of the handler to the
		specified object instead. The statement [[pass to interpreter]] will
		send the message or function call to the interpreter, bypassing the
		hierarchy completely, resulting in the execution of a built-in command
		or the evaluation of a built-in function.
	</description>
	<note>
		Unlike the [[cs:send]] and [[cs:tell]] structures, [[cs:pass]] never returns
		to the handler or script containing the [[*]] statement.
	</note>
	<note>
		HyperTalk does not support the [[pass to]] form.
	</note>
	<see-also>[[cs:on]], [[cs:function]], [[cs:end]], [[cs:exit]], [[cs:send]], [[cs:tell]]</see-also>
</structure>

<structure>
	<name dialects="oxnb11,oxnb12">require</name>
	<syntax>require {scriptName}</syntax>
	<syntax>require {scriptName} once</syntax>
	<syntax>require {scriptName} with dialog</syntax>
	<syntax>require {scriptName} once with dialog</syntax>
	<syntax>require {scriptName} without dialog</syntax>
	<syntax>require {scriptName} once without dialog</syntax>
	<syntax-note>
		{ScriptName} yields the name or path of an XION script file.
	</syntax-note>
	<description>
		The [[*]] statement executes the statements contained in an XION script file.
		If the script file cannot be found, the user will be asked to locate it,
		unless the [[without dialog]] keyword is used. If the script file cannot be
		found and the user cancels or the [[without dialog]] keyword is used, the
		[[*]] statement triggers a script error.
		(For a version that does not trigger a script error, see [[cs:include]].)
		If the [[once]] keyword is used and the script has been executed before,
		it will not be executed again.
	</description>
	<description>
		In OpenXION, the locations searched for included scripts are determined by
		the [[pr:includePaths]] property.
	</description>
	<note>
		The [[*]] statement as described here is specific to OpenXION.
	</note>
	<see-also>[[cs:include]], [[pr:includePaths]], [[fn:includePath]], [[fn:includeFile]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">return</name>
	<syntax>return {expression}</syntax>
	<description>
		The [[*]] statement ends execution of the handler and sets
		the return value of the message or function call.
	</description>
	<description>
		When it appears within a message handler ([[cs:on]] structure),
		the [[*]] statement places the value of {expression} into the
		built-in function [[fn:result]]. The value of the [[fn:result]]
		function is valid only immediately after a command executes;
		each new statement resets the [[fn:result]].
	</description>
	<description>
		When it appears within a function handler ([[cs:function]] structure),
		the [[*]] statement dictates the returned value of the function.
		The returned value replaces the function in the calling statement.
	</description>
	<note>
		User-defined functions are always followed by parentheses.
		Unlike built-in functions, user-defined functions cannot be called
		with [[kw:the]], [[kw:of]], or [[kw:in]].
	</note>
	<see-also>[[cs:on]], [[cs:function]], [[fn:result]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">send</name>
	<syntax>send {message} to {object}</syntax>
	<syntax>send {message} to {object} with reply</syntax>
	<syntax>send {message} to {object} without reply</syntax>
	<syntax-note>{Object} yields a [[dt:variant]] able to respond to messages.</syntax-note>
	<description>
		The [[*]] statement sends a message directly to a particular object.
		Unlike the [[cs:pass]] statement, [[cs:send]] returns to the handler
		or script containing the [[*]] statement after the message has been
		intercepted.
	</description>
	<security>
		To send a message to [[the ]][[dt:interpreter]], OpenXION's security settings must allow the [[DO_AND_VALUE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cs:tell]], [[cs:pass]]</see-also>
</structure>

<structure>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">throw</name>
	<syntax>throw {errorMessage}</syntax>
	<syntax-note>{ErrorMessage} yields any [[dt:string]].</syntax-note>
	<description>
		The [[*]] statement triggers a script error with the specified error message.
	</description>
</structure>

<structure>
	<name dialects="oxnb1,oxnb11,oxnb12">use</name>
	<syntax>use {moduleName}</syntax>
	<syntax-note>
		{ModuleName} yields the fully-qualified class name of a Java class that extends
		[[com.kreative.openxion.XNModule]].
	</syntax-note>
	<description>
		The [[*]] statement tells the OpenXION interpreter to load the specified module.
		{ModuleName} must yield the fully-qualified Java class name of the module to load.
	</description>
	<note>
		Since the mechanism for loading modules is dependent on the XION implementation,
		the [[*]] statement as described here is specific to OpenXION.
	</note>
	<security>
		To load modules, OpenXION's security settings must allow the [[MODULE_LOAD]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cs:include]], [[cs:require]]</see-also>
</structure>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">me</name>
	<syntax>me</syntax>
	<example>get the short name of me</example>
	<description>
		[[kw:Me]] is a special keyword that always evaluates to the object
		that contains the currently running handler. If there is no such object,
		[[kw:me]] evaluates to [[the ]][[dt:interpreter]] instead.
	</description>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">super</name>
	<syntax>super</syntax>
	<example>tell super to doSomething</example>
	<description>
		[[kw:Super]] is a special keyword that always evaluates to the object
		that contains the currently running handler, but as the data type it extends.
		If there is no such object, [[kw:super]] evaluates to [[the ]][[dt:interpreter]] instead.
	</description>
	<note>
		This keyword only makes sense inside the definition of a user-defined object type.
		Its behavior outside that context is undefined.
	</note>
</keyword>

<keyword>
	<name dialects="oxnb12">__LINE__</name>
	<syntax>__LINE__</syntax>
	<example>put "I am on line" && __LINE__</example>
	<description>
		[[kw:__LINE__]] is a special keyword that is replaced with
		the line number of the line it's on when a script is parsed.
	</description>
	<note>
		If [[kw:__LINE__]] is used inside a string passed to [[cs:do]] or [[fn:value]],
		it will be replaced with the line number of the line it's on inside the string,
		not inside the current script file. If you want the latter, put [[kw:__LINE__]]
		outside the string.
	</note>
	<note>
		[[kw:__LINE__]] is not part of the XION Scripting Language Standard and is
		not portable. It is not available in OpenXION 1.0 or 1.1.
	</note>
</keyword>

<keyword>
	<name dialects="oxnb12">__FILE__</name>
	<syntax>__FILE__</syntax>
	<example>put "I am in" && __FILE__</example>
	<description>
		[[kw:__FILE__]] is a special keyword that is replaced with
		the full path of the file it is in when a script is parsed.
		If the script did not come from a file, the [[kw:__FILE__]]
		keyword is replaced with [[cn:empty]].
	</description>
	<note>
		If [[kw:__FILE__]] is used inside a string passed to [[cs:do]] or [[fn:value]],
		it will be replaced with [[cn:empty]], not the path of the current script file.
		If you want the latter, put [[kw:__FILE__]] outside the string.
	</note>
	<note>
		[[kw:__FILE__]] is not part of the XION Scripting Language Standard and is
		not portable. It is not available in OpenXION 1.0 or 1.1.
	</note>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">short</name>
	<applies-to>Functions and properties</applies-to>
	<syntax>the [[*]] {function-or-property-name}</syntax>
	<syntax>the [[*]] {function-or-property-name} of {variant}</syntax>
	<syntax>[[*]] {function-or-property-name}</syntax>
	<syntax>[[*]] {function-or-property-name} of {variant}</syntax>
	<example>get the [[*]] date</example>
	<description>
		The [[*]] keyword is a modifier that appears before a function call or property descriptor.
		It tells the function or property getter that the resulting value should be in a shortened form.
		The best example of this is the [[fn:date]] function.
	</description>
	<see-also>[[kw:abbreviated]], [[kw:long]], [[kw:English]]</see-also>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">abbr</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">abbrev</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">abbreviated</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">med</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">medium</name>
	<applies-to>Functions and properties</applies-to>
	<syntax>the [[*]] {function-or-property-name}</syntax>
	<syntax>the [[*]] {function-or-property-name} of {variant}</syntax>
	<syntax>[[*]] {function-or-property-name}</syntax>
	<syntax>[[*]] {function-or-property-name} of {variant}</syntax>
	<example>get the [[*]] date</example>
	<description>
		The [[*]] keyword is a modifier that appears before a function call or property descriptor.
		It tells the function or property getter that the resulting value should be in an abbreviated form.
		The best example of this is the [[fn:date]] function.
	</description>
	<see-also>[[kw:short]], [[kw:long]], [[kw:English]]</see-also>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">long</name>
	<applies-to>Functions and properties</applies-to>
	<syntax>the [[*]] {function-or-property-name}</syntax>
	<syntax>the [[*]] {function-or-property-name} of {variant}</syntax>
	<syntax>[[*]] {function-or-property-name}</syntax>
	<syntax>[[*]] {function-or-property-name} of {variant}</syntax>
	<example>get the [[*]] date</example>
	<description>
		The [[*]] keyword is a modifier that appears before a function call or property descriptor.
		It tells the function or property getter that the resulting value should be in a long form.
		The best example of this is the [[fn:date]] function.
	</description>
	<see-also>[[kw:short]], [[kw:abbreviated]], [[kw:English]]</see-also>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">English</name>
	<applies-to>Functions and properties</applies-to>
	<syntax>the [[*]] {function-or-property-name}</syntax>
	<syntax>the [[*]] {function-or-property-name} of {variant}</syntax>
	<syntax>[[*]] {function-or-property-name}</syntax>
	<syntax>[[*]] {function-or-property-name} of {variant}</syntax>
	<example>get the [[*]] date</example>
	<description>
		The [[*]] keyword is a modifier that appears before a function call or property descriptor.
		It tells the function or property getter that the resulting value should be in a long form in U.S. English format.
		The best example of this is the [[fn:date]] function.
	</description>
	<see-also>[[kw:short]], [[kw:abbreviated]], [[kw:long]]</see-also>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">into</name>
	<syntax>put {value} into {container}</syntax>
	<example>put " not " into char 69 of steve</example>
	<description>
		The [[kw:into]] keyword is a preposition used with the [[cm:put]] command
		to determine where the given value goes inside the given container.
		[[kw:Into]] specifies that the given value should replace the existing contents.
	</description>
	<see-also>[[kw:before]], [[kw:after]], [[cm:put]]</see-also>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">before</name>
	<syntax>put {value} before {container}</syntax>
	<example>put "not " before word 12 of steve</example>
	<description>
		The [[kw:before]] keyword is a preposition used with the [[cm:put]] command
		to determine where the given value goes inside the given container.
		[[kw:Before]] specifies that the given value should be placed immediately preceding the existing contents.
	</description>
	<see-also>[[kw:into]], [[kw:after]], [[cm:put]]</see-also>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">after</name>
	<syntax>put {value} after {container}</syntax>
	<example>put " not" after word 11 of steve</example>
	<description>
		The [[kw:after]] keyword is a preposition used with the [[cm:put]] command
		to determine where the given value goes inside the given container.
		[[kw:After]] specifies that the given value should be placed immediately following the existing contents.
	</description>
	<see-also>[[kw:into]], [[kw:before]], [[cm:put]]</see-also>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">to</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">thru</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12">through</name>
	<syntax>{datatype} {index} [[*]] {index}</syntax>
	<syntax>{ordinal} [[*]] {ordinal} {datatype}</syntax>
	<example>get words 12 [[*]] 13 of steve</example>
	<example>get fifth [[*]] ninth files of folder myPath</example>
	<example>get disks 1 [[*]] 4</example>
	<description>
		The [[*]] keyword is used in descriptors to specify a range of indexes or ordinals.
	</description>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">in</name>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">of</name>
	<description>
		The [[*]] keyword is used in several places to describe child-parent relationships
		between objects and arguments to function calls.
	</description>
	<description>
		It is used in chunk expressions: [[char 32 ]][[*]][[ steve]]
	</description>
	<description>
		It is used in descriptors for child objects: [[file "doc.xnd" ]][[*]][[ folder "Documentation"]]
	</description>
	<description>
		It is used in function calls: [[the sqrt ]][[*]][[ sixteen]]
	</description>
	<description>
		It is used in property descriptors: [[the location ]][[*]][[ myRectangle]]
	</description>
	<description>
		It is used in operators: [[steve is an element ]][[*]][[ bill]]
	</description>
	<description>
		It is used in certain control structures: [[repeat for each myElement ]][[*]][[ myList]]
	</description>
	<note>
		The [[kw:in]] and [[kw:of]] keywords are synonyms practically everywhere in both XION and HyperTalk,
		even when it would otherwise make no sense (e.g., [[the sqrt in 4]] or [["e" is of "hello"]]).
	</note>
</keyword>

<keyword>
	<name dialects="xn1,oxnb1,oxnb11,oxnb12,hyp">the</name>
	<description>
		The [[*]] keyword is used in several places.
	</description>
	<description>
		It can be used in descriptors: [[the third word of steve]]
	</description>
	<description>
		It can be used in function calls: [[the sqrt of sixteen]]
	</description>
	<description>
		It can be used in property descriptors: [[the itemDelimiter]]
	</description>
	<note>
		In both XION and HyperTalk, the presence or absence of the [[*]] keyword is
		significant when the expression does not include the keyword [[kw:of]] or [[kw:in]].
		For example, both [[the sqrt of 16]] and [[the date]] are function calls,
		but [[sqrt of 16]] is a function call while [[date]] by itself is a variable.
	</note>
</keyword>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">zero</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">never</name>
	<type>integer</type>
	<value>0</value>
	<example>put zero into theCounter</example>
	<example>beep never</example>
	<description>
		An [[dt:integer]] with the numeric value of zero.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">one</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">once</name>
	<type>integer</type>
	<value>1</value>
	<example>put one into numberOfUniverses</example>
	<example>beep once</example>
	<description>
		An [[dt:integer]] with the numeric value of 1.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">two</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">twice</name>
	<type>integer</type>
	<value>2</value>
	<example>put two into numberOfShoes</example>
	<example>beep twice</example>
	<description>
		An [[dt:integer]] with the numeric value of 2.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">three</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">thrice</name>
	<type>integer</type>
	<value>3</value>
	<example>put three into numberOfDimensions</example>
	<example>beep thrice</example>
	<description>
		An [[dt:integer]] with the numeric value of 3.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">four</name>
	<type>integer</type>
	<value>4</value>
	<example>put four into numberOfSeasons</example>
	<description>
		An [[dt:integer]] with the numeric value of 4.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">five</name>
	<type>integer</type>
	<value>5</value>
	<example>put five into numberOfSenses</example>
	<description>
		An [[dt:integer]] with the numeric value of 5.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">six</name>
	<type>integer</type>
	<value>6</value>
	<example>put six into numberOfQuarks</example>
	<description>
		An [[dt:integer]] with the numeric value of 6.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">seven</name>
	<type>integer</type>
	<value>7</value>
	<example>put seven into numberOfWeekdays</example>
	<description>
		An [[dt:integer]] with the numeric value of 7.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">eight</name>
	<type>integer</type>
	<value>8</value>
	<example>put eight into numberOfGluons</example>
	<description>
		An [[dt:integer]] with the numeric value of 8.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">nine</name>
	<type>integer</type>
	<value>9</value>
	<example>put nine into numberOfInnings</example>
	<description>
		An [[dt:integer]] with the numeric value of 9.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">ten</name>
	<type>integer</type>
	<value>10</value>
	<example>put ten into numberOfCommandments</example>
	<description>
		An [[dt:integer]] with the numeric value of 10.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">eleven</name>
	<type>integer</type>
	<value>11</value>
	<example>put eleven into numberOfCloningAttemptsBeforeThisOne</example>
	<description>
		An [[dt:integer]] with the numeric value of 11.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">twelve</name>
	<type>integer</type>
	<value>12</value>
	<example>put twelve into numberOfMonths</example>
	<description>
		An [[dt:integer]] with the numeric value of 12.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">thirteen</name>
	<type>integer</type>
	<value>13</value>
	<example>put thirteen into numberOfColonies</example>
	<description>
		An [[dt:integer]] with the numeric value of 13.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">fourteen</name>
	<type>integer</type>
	<value>14</value>
	<example>put fourteen into numberOfPoints</example>
	<description>
		An [[dt:integer]] with the numeric value of 14.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">fifteen</name>
	<type>integer</type>
	<value>15</value>
	<example>put fifteen into numberOfMinutes</example>
	<description>
		An [[dt:integer]] with the numeric value of 15.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">sixteen</name>
	<type>integer</type>
	<value>16</value>
	<example>put sixteen into numberOfCandles</example>
	<description>
		An [[dt:integer]] with the numeric value of 16.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">seventeen</name>
	<type>integer</type>
	<value>17</value>
	<example>put seventeen into numberOfSyllables</example>
	<description>
		An [[dt:integer]] with the numeric value of 17.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">eighteen</name>
	<type>integer</type>
	<value>18</value>
	<example>put eighteen into numberOfTammies</example>
	<description>
		An [[dt:integer]] with the numeric value of 18.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">nineteen</name>
	<type>integer</type>
	<value>19</value>
	<example>put nineteen into numberOfBiquadrates</example>
	<description>
		An [[dt:integer]] with the numeric value of 19.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">twenty</name>
	<type>integer</type>
	<value>20</value>
	<example>put twenty into numberOfQuestions</example>
	<description>
		An [[dt:integer]] with the numeric value of 20.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">phi</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">φ</name>
	<type>number</type>
	<value>1.6180339887</value>
	<example>put height * [[*]] into width</example>
	<description>
		A [[dt:number]] with the numeric value of 1.6180339887....
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">euler</name>
	<type>number</type>
	<value>2.7182818284</value>
	<example>put euler ^ myLogarithm into myNumber</example>
	<description>
		A [[dt:number]] with the numeric value of 2.7182818284....
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">pi</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">π</name>
	<type>number</type>
	<value>3.1415926535</value>
	<example>put [[*]] * radius * radius into area</example>
	<example>put 2*[[*]]*r into circumference</example>
	<description>
		A [[dt:number]] with the numeric value of 3.1415926535....
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">inf</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">infinity</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">∞</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">forever</name>
	<type>number</type>
	<value>INF</value>
	<example>if 1 / 0 is [[*]] then beep</example>
	<description>
		A [[dt:number]] representing positive infinity.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">NaN</name>
	<type>number</type>
	<value>NAN</value>
	<example>if 0/0 is NaN then beep</example>
	<description>
		A [[dt:number]] representing the value obtained when
		evaluating an indeterminate form such as 0/0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">empty</name>
	<type>variant</type>
	<value></value>
	<example>put empty into steve</example>
	<description>
		A [[dt:variant]] representing nothing.
	</description>
	<description>
		When used as a [[dt:string]], [[cn:empty]] evaluates to a zero-length string.
	</description>
	<description>
		When used as an [[dt:integer]], a [[dt:number]], or a [[dt:complex]],
		[[cn:empty]] evaluates to the numeric value of zero.
	</description>
	<description>
		When used as a [[dt:binary]], [[cn:empty]] evaluates to a zero-byte stream.
	</description>
	<description>
		When used as a [[dt:list]], [[cn:empty]] evaluates to a list of zero elements.
	</description>
	<description>
		When used as an [[dt:object]], [[cn:empty]] can be used as a placeholder
		for an actual [[dt:object]].
	</description>
	<description>
		The [[cn:empty]] constant cannot be used as any other data type
		besides the types listed above.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">null</name>
	<type>string</type>
	<example>put null into tooHotForHyperCard</example>
	<description>
		A one-length [[dt:string]] consisting solely of ASCII character zero, the null character.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\0]] to indicate a null in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
	<see-also>[[cn:empty]]</see-also>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">backspace</name>
	<type>string</type>
	<example>set the itemDelimiter to backspace</example>
	<description>
		A one-length [[dt:string]] consisting solely of ASCII character 8, the backspace character.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\b]] to indicate a backspace in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">tab</name>
	<type>string</type>
	<example>put tab before line 2 of theText</example>
	<description>
		A one-length [[dt:string]] consisting solely of ASCII character 9, the tab character.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\t]] to indicate a tab in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">linefeed</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">newline</name>
	<type>string</type>
	<example>put [[*]] after line 2 of theText</example>
	<description>
		A one-length [[dt:string]] consisting solely of ASCII character 10, the line feed character or Unix newline character.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\n]] to indicate a line feed or newline in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">formfeed</name>
	<type>string</type>
	<example>put formfeed after theText</example>
	<description>
		A one-length [[dt:string]] consisting solely of ASCII character 12, the form feed character.
		Some programs may use this to indicate a page break.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\f]] to indicate a form feed in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">return</name>
	<type>string</type>
	<example>put return after line 2 of theText</example>
	<description>
		A one-length [[dt:string]] consisting solely of ASCII character 13, the carriage return character or Macintosh line break character.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\r]] to indicate a carriage return in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">escape</name>
	<type>string</type>
	<example>put escape &amp; "[0m"</example>
	<description>
		A one-length [[dt:string]] consisting solely of ASCII character 27, the escape character.
		This character can be used to control output to terminals.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\e]] to indicate an escape character in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">space</name>
	<type>string</type>
	<value> </value>
	<example>put "Hello" &amp; space &amp; "World" into steve</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII space character.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">quote</name>
	<type>string</type>
	<value>&quot;</value>
	<example>put quote &amp; "I think she broke the CD-R drive when she dropped it on the floor," &amp; quote &amp;&amp; "said Smart Claire."</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII quotation mark character (").
	</description>
	<note>
		In XION, you can also use the escape sequence [[\"]] to indicate a quote in a quoted literal.
		In HyperTalk, all backslashes are literal, and quotes cannot be included inside a quoted literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">apostrophe</name>
	<type>string</type>
	<value>&#39;</value>
	<example>put "would" &amp; apostrophe &amp; "ve" &amp;&amp; "could" &amp; apostrophe &amp; "ve" &amp;&amp; "should" &amp; apostrophe &amp; "ve"</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII apostrophe character (').
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">comma</name>
	<type>string</type>
	<value>,</value>
	<example>set the itemDelimiter to comma</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII comma character (,).
		This is used as the default [[pr:itemDelimiter]], as well as the delimiter
		when converting a [[dt:list]] to a [[dt:string]].
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">period</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">fullstop</name>
	<type>string</type>
	<value>.</value>
	<example>put 3 &amp; [[*]] &amp; 14159</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII period or full stop character (.).
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">slash</name>
	<type>string</type>
	<value>/</value>
	<example>put slash &amp; "usr" &amp; slash &amp; "bin" &amp; slash &amp; "perl" into thePath</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII slash character (/).
		This is used as the file path separator on Unix-based systems.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">colon</name>
	<type>string</type>
	<value>:</value>
	<example>put "Macintosh HD" &amp; colon &amp; "Applications" &amp; colon &amp; "HyperCard" into thePath</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII colon character (:).
		This is used as the file path separator on Mac OS Classic systems.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">semicolon</name>
	<type>string</type>
	<value>;</value>
	<example>set the columnDelimiter to semicolon</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII semicolon character (;).
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">backslash</name>
	<type>string</type>
	<value>\</value>
	<example>put "C:" &amp; backslash &amp; "Windows" &amp; backslash &amp; "System32" into thePath</example>
	<description>
		A one-length [[dt:string]] consisting of a single ASCII backslash character (\).
		This is used as the file path separator on Windows systems.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\]][[\]] to indicate a backslash in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">del</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">delete</name>
	<type>string</type>
	<example>set the itemDelimiter to [[*]]</example>
	<description>
		A one-length [[dt:string]] consisting solely of ASCII character 127, the delete character.
	</description>
	<note>
		In XION, you can also use the escape sequence [[\d]] to indicate a delete character in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">linesep</name>
	<type>string</type>
	<value>&#x2028;</value>
	<example>put linesep after line 12 of theText</example>
	<description>
		A one-length [[dt:string]] consisting of a single Unicode line separator character,
		Unicode character [[U+2028]].
	</description>
	<note>
		In XION, you can also use the escape sequence [[\u2028]] to indicate a line separator in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">parasep</name>
	<type>string</type>
	<value>&#x2029;</value>
	<example>put parasep after line 12 of theText</example>
	<description>
		A one-length [[dt:string]] consisting of a single Unicode paragraph separator character,
		Unicode character [[U+2029]].
	</description>
	<note>
		In XION, you can also use the escape sequence [[\u2029]] to indicate a paragraph separator in a quoted literal.
		In HyperTalk, all backslashes are literal, as escape sequences are not supported.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">eof</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">end</name>
	<type>string</type>
	<example>read from file thePath until [[*]]</example>
	<description>
		A one-length [[dt:string]] consisting solely of Unicode character [[U+FFFF]],
		used to indicate when the [[cm:read]] command has reached the end of a text file.
		Since [[U+FFFF]] is not a valid Unicode character, [[*]] will never appear
		anywhere else in a correctly-encoded text file.
	</description>
	<note>
		In HyperTalk, [[cn:eof]] is actually a keyword to the [[cm:read]] command, not a constant.
		We know this because we can [[put it into eof]] in HyperTalk, but we cannot
		[[put it into pi]] or any other real constant. However, the {HyperCard Script Language Guide}
		mistakenly lists [[cn:eof]] as a constant. In XION, [[cn:eof]] is a real constant.
	</note>
	<see-also>[[cm:read]]</see-also>
</constant>

<constant>
	<name dialects="hyp">up</name>
	<type>string</type>
	<value>up</value>
	<example>wait until the optionKey is up</example>
	<description>
		A [[dt:string]] consisting of the text [["up"]] (without the quotes).
	</description>
	<note>
		The [[*]] constant is a rare example of HyperTalk defining something other than a command
		or function that XION does not. It was decided that since [[left]] and [[right]] cannot be
		defined as constants alongside [[cn:up]] and [[cn:down]] (they conflict with the [[left]]
		and [[right]] functions), then [[cn:up]] and [[cn:down]] should not be defined as
		constants either. Furthermore, the [[cn:up]] and [[cn:down]] constants are used in an
		environment-specific context for describing the state of mouse buttons and keyboard keys,
		which does not apply to XION.
	</note>
</constant>

<constant>
	<name dialects="hyp">down</name>
	<type>string</type>
	<value>down</value>
	<example>wait until the mouse is down</example>
	<description>
		A [[dt:string]] consisting of the text [["down"]] (without the quotes).
	</description>
	<note>
		The [[*]] constant is a rare example of HyperTalk defining something other than a command
		or function that XION does not. It was decided that since [[left]] and [[right]] cannot be
		defined as constants alongside [[cn:up]] and [[cn:down]] (they conflict with the [[left]]
		and [[right]] functions), then [[cn:up]] and [[cn:down]] should not be defined as
		constants either. Furthermore, the [[cn:up]] and [[cn:down]] constants are used in an
		environment-specific context for describing the state of mouse buttons and keyboard keys,
		which does not apply to XION.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">true</name>
	<type>boolean</type>
	<value>true</value>
	<example>if 2+2=4 is true then beep</example>
	<description>
		The [[dt:boolean]] representing a truth value of true.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">false</name>
	<type>boolean</type>
	<value>false</value>
	<example>if false then answer "This should never happen."</example>
	<description>
		The [[dt:boolean]] representing a truth value of false.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">white</name>
	<type>color</type>
	<value>65535,65535,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 65535, 65535.
	</description>
	<note>
		Although HyperCard had no native support for color,
		the [[dt:color]] constants originate from HyperTalk's
		[[visual]] command, which allowed [[black]], [[gray]],
		[[grey]], and [[white]] as possible images to transition
		to.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">lightGray</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">lightGrey</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">silver</name>
	<type>color</type>
	<value>49152,49152,49152</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 49152, 49152, 49152.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">gray</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">grey</name>
	<type>color</type>
	<value>32768,32768,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 32768, 32768.
	</description>
	<note>
		Although HyperCard had no native support for color,
		the [[dt:color]] constants originate from HyperTalk's
		[[visual]] command, which allowed [[black]], [[gray]],
		[[grey]], and [[white]] as possible images to transition
		to.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">darkGray</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">darkGrey</name>
	<type>color</type>
	<value>16384,16384,16384</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 16384, 16384, 16384.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">black</name>
	<type>color</type>
	<value>0,0,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 0, 0.
	</description>
	<note>
		Although HyperCard had no native support for color,
		the [[dt:color]] constants originate from HyperTalk's
		[[visual]] command, which allowed [[black]], [[gray]],
		[[grey]], and [[white]] as possible images to transition
		to.
	</note>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">coral</name>
	<type>color</type>
	<value>65535,32768,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 32768, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">corange</name>
	<type>color</type>
	<value>65535,49152,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 49152, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">lemon</name>
	<type>color</type>
	<value>65535,65535,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 65535, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">lime</name>
	<type>color</type>
	<value>32768,65535,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 65535, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">sky</name>
	<type>color</type>
	<value>32768,65535,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 65535, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">frost</name>
	<type>color</type>
	<value>32768,32768,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 32768, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">lavender</name>
	<type>color</type>
	<value>49152,32768,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 49152, 32768, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">pink</name>
	<type>color</type>
	<value>65535,32768,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 32768, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">red</name>
	<type>color</type>
	<value>65535,0,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 0, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">scarlet</name>
	<type>color</type>
	<value>65535,16384,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 16384, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">orange</name>
	<type>color</type>
	<value>65535,32768,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 32768, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">blonde</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">gold</name>
	<type>color</type>
	<value>65535,49152,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 49152, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">yellow</name>
	<type>color</type>
	<value>65535,65535,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 65535, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">chartreuse</name>
	<type>color</type>
	<value>32768,65535,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 65535, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">green</name>
	<type>color</type>
	<value>0,65535,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 65535, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">aquamarine</name>
	<type>color</type>
	<value>0,65535,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 65535, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">cyan</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">aqua</name>
	<type>color</type>
	<value>0,65535,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 65535, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">azure</name>
	<type>color</type>
	<value>0,32768,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 32768, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">blue</name>
	<type>color</type>
	<value>0,0,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 0, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">indigo</name>
	<type>color</type>
	<value>16384,0,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 16384, 0, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">violet</name>
	<type>color</type>
	<value>32768,0,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 0, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">purple</name>
	<type>color</type>
	<value>49152,0,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 49152, 0, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">magenta</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">fuchsia</name>
	<type>color</type>
	<value>65535,0,65535</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 0, 65535.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">rose</name>
	<type>color</type>
	<value>65535,0,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 0, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">maroon</name>
	<type>color</type>
	<value>32768,0,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 0, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">umber</name>
	<type>color</type>
	<value>32768,16384,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 16384, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">olive</name>
	<type>color</type>
	<value>32768,32768,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 32768, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">pine</name>
	<type>color</type>
	<value>0,32768,0</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 32768, 0.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">teal</name>
	<type>color</type>
	<value>0,32768,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 32768, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">navy</name>
	<type>color</type>
	<value>0,0,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 0, 0, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">eggplant</name>
	<type>color</type>
	<value>16384,0,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 16384, 0, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">plum</name>
	<type>color</type>
	<value>32768,0,32768</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 32768, 0, 32768.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">brown</name>
	<type>color</type>
	<value>39321,26214,13107</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 39321, 26214, 13107.
	</description>
</constant>

<constant>
	<name dialects="xn1,oxn1,oxn11,oxn12">creme</name>
	<type>color</type>
	<value>65535,61166,52428</value>
	<example>set the color of myObject to [[*]]</example>
	<description>
		A [[dt:color]] with RGB values 65535, 61166, 52428.
	</description>
</constant>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">zeroth</name>
	<value>0</value>
	<example>put the zeroth byte of ("09F91102" as binary) -- prints "09"</example>
	<description>
		An ordinal corresponding to index zero.
		The [[or:zeroth]] ordinal is used mainly with the [[dt:binary]] data type,
		where offsets into the binary data are numbered starting at zero.
		It is rarely used elsewhere, as most other indexes in XION start at 1.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">first</name>
	<value>1</value>
	<example>put first sentence of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "Hello, my name is Rebecca."</example>
	<description>
		An ordinal corresponding to index 1.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">second</name>
	<value>2</value>
	<example>put second word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "my"</example>
	<description>
		An ordinal corresponding to index 2.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">third</name>
	<value>3</value>
	<example>put third word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "name"</example>
	<description>
		An ordinal corresponding to index 3.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">fourth</name>
	<value>4</value>
	<example>put fourth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "is"</example>
	<description>
		An ordinal corresponding to index 4.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">fifth</name>
	<value>5</value>
	<example>put fifth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "Rebecca."</example>
	<description>
		An ordinal corresponding to index 5.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">sixth</name>
	<value>6</value>
	<example>put sixth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "But"</example>
	<description>
		An ordinal corresponding to index 6.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">seventh</name>
	<value>7</value>
	<example>put seventh word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "you"</example>
	<description>
		An ordinal corresponding to index 7.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">eighth</name>
	<value>8</value>
	<example>put eighth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "can"</example>
	<description>
		An ordinal corresponding to index 8.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">ninth</name>
	<value>9</value>
	<example>put ninth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "call"</example>
	<description>
		An ordinal corresponding to index 9.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">tenth</name>
	<value>10</value>
	<example>put tenth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "me"</example>
	<description>
		An ordinal corresponding to index 10.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">eleventh</name>
	<value>11</value>
	<example>put eleventh word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "Beckie."</example>
	<description>
		An ordinal corresponding to index 11.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">twelfth</name>
	<value>12</value>
	<example>put twelfth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "a" from "name"</example>
	<description>
		An ordinal corresponding to index 12.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">thirteenth</name>
	<value>13</value>
	<example>put thirteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "m" from "name"</example>
	<description>
		An ordinal corresponding to index 13.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">fourteenth</name>
	<value>14</value>
	<example>put fourteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "e" from "name"</example>
	<description>
		An ordinal corresponding to index 14.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">fifteenth</name>
	<value>15</value>
	<example>put fifteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints " " after "name"</example>
	<description>
		An ordinal corresponding to index 15.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">sixteenth</name>
	<value>16</value>
	<example>put sixteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "i" from "is"</example>
	<description>
		An ordinal corresponding to index 16.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">seventeenth</name>
	<value>17</value>
	<example>put seventeenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "s" from "is"</example>
	<description>
		An ordinal corresponding to index 17.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">eighteenth</name>
	<value>18</value>
	<example>put eighteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints " " after "is"</example>
	<description>
		An ordinal corresponding to index 18.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">nineteenth</name>
	<value>19</value>
	<example>put nineteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "R" from "Rebecca"</example>
	<description>
		An ordinal corresponding to index 19.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12">twentieth</name>
	<value>20</value>
	<example>put twentieth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints first "e" from "Rebecca"</example>
	<description>
		An ordinal corresponding to index 20.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">mid</name>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">middle</name>
	<example>put the [[*]] word of "It was the turtle, not I, who spilled the beans." -- prints "I,"</example>
	<example>put the [[*]] item of "It was the turtle, not I, who spilled the beans." -- prints " not I"</example>
	<description>
		A special ordinal corresponding to the middle, or median, value of a set of values.
		If the number of values is even, the [[*]] ordinal favors the second, or latter,
		of the two middle values.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">last</name>
	<value>-1</value>
	<example>put the last word of "Hello, my name is Rebecca." -- prints "Rebecca."</example>
	<description>
		An ordinal corresponding to index -1, or the last value of a set of values.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">any</name>
	<example>put any word of "apple orange banana" into randomFruit</example>
	<description>
		A special ordinal corresponding to a random index.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">this</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">current</name>
	<description>
		A special ordinal corresponding to the current instance of an object type.
		What this means is dependent on which object type it is being used with.
		None of the object types in the XION Scripting Language Standard or
		OpenXION currently support this ordinal.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">prev</name>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">previous</name>
	<description>
		A special ordinal corresponding to the previous instance of an object type.
		What this means is dependent on which object type it is being used with.
		None of the object types in the XION Scripting Language Standard or
		OpenXION currently support this ordinal.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">next</name>
	<description>
		A special ordinal corresponding to the next instance of an object type.
		What this means is dependent on which object type it is being used with.
		None of the object types in the XION Scripting Language Standard or
		OpenXION currently support this ordinal.
	</description>
</ordinal>

<ordinal>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">recent</name>
	<description>
		A special ordinal corresponding to the previous recent instance of an object type.
		What this means is dependent on which object type it is being used with.
		None of the object types in the XION Scripting Language Standard or
		OpenXION currently support this ordinal.
	</description>
</ordinal>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">variant</name>
	<description>
		The [[dt:variant]] data type is the most generic type.
		Every single value, piece of data, list, or object is considered a [[dt:variant]].
	</description>
	<note>
		The only value that is intrinsically a [[dt:variant]],
		as opposed to some other data type, is [[cn:empty]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">variants</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">list</name>
	<description>
		The [[dt:list]] or [[dt:variants]] data type is the most generic type of all lists.
		Every list is considered a [[dt:list]], and every other single value, piece of data, or
		object is considered a [[dt:list]] of one [[dt:element]].
	</description>
	<description>
		When a list is converted to a string, the result is the concatenation of each
		element as a string, with a comma between each element. If any element is itself a list,
		its string representation will be enclosed in parentheses. (This prevents the list
		from being flattened in certain circumstances.)
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">lists</name>
	<description>
		The [[dt:lists]] data type is a list that consists entirely of [[dt:list]]s.
		Every list of lists is considered a [[dt:lists]]. Every list of single values
		is considered a [[dt:lists]] of one [[dt:list]]. Every other single value,
		piece of data, or object is considered a [[dt:lists]] of one [[dt:list]] of
		one [[dt:element]].
	</description>
	<description>
		When a list is converted to a string, the result is the concatenation of each
		element as a string, with a comma between each element. If any element is itself a list,
		its string representation will be enclosed in parentheses. (This prevents the list
		from being flattened in certain circumstances.)
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">element</name>
	<description>
		The [[dt:element]] data type is a chunk type of [[dt:list]] that represents
		individual items in a list. Every single value, piece of data, list, or object
		is considered an [[dt:element]] of its containing [[dt:list]], or, if not in a list,
		an [[dt:element]] of a single-element [[dt:list]] containing it.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
	<note>
		There is a subtle difference between an index, ordinal, or name descriptor
		and an index range, ordinal range, or mass descriptor for [[dt:element]]s.
		An index, ordinal, or name descriptor evaluates to an item in the list,
		while an index range, ordinal range, or mass descriptor evaluates to a sublist.
		Consider the following:\\
		\\
		[[local myList as list]]\\
		[[put (1,2,(3,4),5) into myList]]\\
		[[put the number of elements in element 3 of myList]]\\
		[[put the number of elements in element 3 to 3 of myList]]\\
		\\
		The first line of output will be [[2]], since [[element 3 of myList]] is a list
		containing two values, [[3]] and [[4]]. However, the second line of output will be
		[[1]], since [[element 3 to 3 of myList]] is a list containing that list.
	</note>
	<note>
		The [[dt:element]] and [[dt:elements]] data types were broken in OpenXION 1.0 and 1.1,
		and evaluated index, ordinal, and name descriptors as sublists rather than list items.
		This was fixed in OpenXION 1.2.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">elements</name>
	<description>
		The [[dt:elements]] data type is a chunk type of [[dt:list]] that represents
		a sublist of that list. Every single value, piece of data, list, or object
		is considered an [[dt:elements]] similarly to how it is considered a [[dt:list]].
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
	<note>
		There is a subtle difference between an index, ordinal, or name descriptor
		and an index range, ordinal range, or mass descriptor for [[dt:element]]s.
		An index, ordinal, or name descriptor evaluates to an item in the list,
		while an index range, ordinal range, or mass descriptor evaluates to a sublist.
		Consider the following:\\
		\\
		[[local myList as list]]\\
		[[put (1,2,(3,4),5) into myList]]\\
		[[put the number of elements in element 3 of myList]]\\
		[[put the number of elements in element 3 to 3 of myList]]\\
		\\
		The first line of output will be [[2]], since [[element 3 of myList]] is a list
		containing two values, [[3]] and [[4]]. However, the second line of output will be
		[[1]], since [[element 3 to 3 of myList]] is a list containing that list.
	</note>
	<note>
		The [[dt:element]] and [[dt:elements]] data types were broken in OpenXION 1.0 and 1.1,
		and evaluated index, ordinal, and name descriptors as sublists rather than list items.
		This was fixed in OpenXION 1.2.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">string</name>
	<description>
		The [[dt:string]] data type represents a sequence of Unicode characters.
	</description>
	<note>
		Every single value, piece of data, list, or object can be converted to a
		[[dt:string]] in some way. A container will be converted to its contents
		as a [[dt:string]]. The resulting [[dt:string]] cannot necessarily be
		converted back to the original variant.
	</note>
	<note>
		The [[dt:string]] data type is the default when no other data type is
		specified in a variable declaration or parameter list or when a variable
		is used without being previously declared.
		Other data types, particularly [[dt:variant]], behave in a manner
		incompatible with HyperTalk, but that may be desirable.
		Specifically, [[cm:put]]ting a container into a variable declared as
		[[dt:variant]] will put the container itself into the variable,
		while [[cm:put]]ting a container into a variable declared as
		[[dt:string]] will put the {contents} into the variable.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">strings</name>
	<description>
		The [[dt:strings]] data type represents a [[dt:list]] that consists
		entirely of [[dt:string]]s.
	</description>
	<note>
		Every single value, piece of data, list, or object can be converted to a
		[[dt:strings]] in some way. A list will be converted to a list of the
		individual [[dt:element]]s as [[dt:string]]s. A single value, piece of data,
		or object will be converted to a single-element list of that variant
		as a [[dt:string]].
	</note>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">boolean</name>
	<description>
		The [[dt:boolean]] data type represents a single truth value, which
		may be either [[cn:true]] or [[cn:false]].
	</description>
	<note>
		The [[dt:boolean]] value [[cn:true]] can convert to the [[dt:string]]
		[["true"]] while the [[dt:boolean]] value [[cn:false]] can convert to
		the [[dt:string]] [["false"]]. Conversely, the [[dt:string]]s [["true"]]
		and [["false"]] can convert to the [[dt:boolean]] values [[cn:true]] and
		[[cn:false]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">booleans</name>
	<description>
		The [[dt:booleans]] data type represents a [[dt:list]] that consists
		entirely of [[dt:boolean]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">number</name>
	<description>
		The [[dt:number]] data type represents a real number.
		The [[dt:number]] data type can also represent the values positive
		[[cn:infinity]], negative [[cn:infinity]], and [[cn:NaN]].
	</description>
	<note>
		The XION Scripting Language Standard states that the [[dt:number]]
		type must have IEEE single precision or better. The [[dt:number]]
		type in OpenXION has arbitrary precision: basic arithmetic
		operations use the number of fractional digits specified by the
		[[pr:precision]] property; and mathematical functions can use either
		IEEE double precision or the number of fractional digits specified
		by the [[pr:precision]] property, depending on the setting of the
		[[pr:mathProcessor]] property.
	</note>
	<note>
		A [[dt:number]] can always convert to a [[dt:string]] or a [[dt:complex]].
		A [[dt:number]] can convert to an [[dt:integer]] only if its numeric value
		is a mathematical integer and it is within the range of the [[dt:integer]]
		type.
	</note>
	<note>
		An [[dt:integer]] can always convert to a [[dt:number]].
		A [[dt:string]] can convert to a [[dt:number]] if it has the correct format,
		and a [[dt:complex]] can convert to a [[dt:number]] if its imaginary part is zero.
	</note>
	<note>
		The format used for the conversion of a [[dt:number]] to a [[dt:string]]
		is determined by the [[pr:numberFormat]] property.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">numbers</name>
	<description>
		The [[dt:numbers]] data type represents a [[dt:list]] that consists
		entirely of [[dt:number]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">integer</name>
	<description>
		The [[dt:integer]] data type represents an integer.
	</description>
	<note>
		The XION Scripting Language Standard states that the [[dt:integer]]
		type must have the range of a 32-bit signed two's-complement integer,
		-2147483648 to +2147483647, or larger. The [[dt:integer]] type in
		OpenXION has arbitrary range.
	</note>
	<note>
		The XION Scripting Language Standard also states that if a calculation
		produces an integer outside the range of the [[dt:integer]] type, the
		result must be converted to a [[dt:number]] instead of rolling over
		or overflowing.
	</note>
	<note>
		An [[dt:integer]] can always convert to a [[dt:string]], [[dt:number]],
		or [[dt:complex]]. A [[dt:string]] can convert to an [[dt:integer]] if
		it has the correct format. A [[dt:number]] can convert to an [[dt:integer]]
		if its numeric value is a mathematical integer and it is within the
		range of the [[dt:integer]] type. A [[dt:complex]] can convert to an
		[[dt:integer]] if its imaginary part is zero and its real part is a
		mathematical integer in the range of the [[dt:integer]] type.
	</note>
	<note>
		The format used for the conversion of an [[dt:integer]] to a [[dt:string]]
		is determined by the [[pr:numberFormat]] property.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">integers</name>
	<description>
		The [[dt:integers]] data type represents a [[dt:list]] that consists
		entirely of [[dt:integer]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">complex</name>
	<description>
		The [[dt:complex]] data type represents a complex number, a number
		of the form {a+bi} where {a} and {b} are real numbers and {i} is
		the square root of -1.
	</description>
	<note>
		The XION Scripting Language Standard states that both real and imaginary
		parts of the [[dt:complex]] type must have the same precision as that
		of the [[dt:number]] type. OpenXION follows this.
	</note>
	<note>
		A [[dt:complex]] can always convert to a [[dt:string]].
		A [[dt:complex]] can convert to a [[dt:number]] if its imaginary part
		is zero, and can convert to an [[dt:integer]] if, in addition to its
		imaginary part being zero, its real part is a mathematical integer
		in the range of the [[dt:integer]] type.
	</note>
	<note>
		An [[dt:integer]] or a [[dt:number]] can always convert to a [[dt:complex]]
		with an imaginary part of zero. A [[dt:string]] can convert to a [[dt:complex]]
		if it has the correct format.
	</note>
	<note>
		The format used for the conversion of a [[dt:complex]] to a [[dt:string]]
		is determined by the [[pr:numberFormat]] property.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">complexes</name>
	<description>
		The [[dt:complexes]] data type represents a [[dt:list]] that consists
		entirely of [[dt:complex]]es.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">point</name>
	<description>
		The [[dt:point]] data type represents a point in a Cartesian coordinate
		system with integer coordinates.
	</description>
	<note>
		The [[dt:string]] representation of a [[dt:point]] is the [[dt:string]]
		representation of the X coordinate, followed by a comma, followed by the
		[[dt:string]] representation of the Y coordinate.
	</note>
	<note>
		In HyperTalk, you can test for a point with the [[op:is a]] operator,
		but the test is broken: if the value is not a comma-delimited list of integers,
		the expression will trigger an "Expected integer here" script error instead of
		evaluating to [[cn:false]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">points</name>
	<description>
		The [[dt:points]] data type represents a [[dt:list]] that consists
		entirely of [[dt:point]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">rect</name>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">rectangle</name>
	<description>
		The [[*]] data type represents a rectangle in a Cartesian coordinate
		system with integer coordinates.
	</description>
	<properties>
		left, top, right, bottom, topLeft, topRight, bottomLeft, botLeft,
		bottomRight, botRight, location, loc, center, width, height
	</properties>
	<note>
		The [[dt:string]] representation of a [[*]] is the [[dt:string]]
		representations of the left, top, right, and bottom coordinates, in order,
		delimited by commas.
	</note>
	<note>
		In HyperTalk, you can test for a rectangle with the [[op:is a]] operator,
		but the test is broken: if the value is not a comma-delimited list of integers,
		the expression will trigger an "Expected integer here" script error instead of
		evaluating to [[cn:false]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">rects</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">rectangles</name>
	<description>
		The [[*]] data type represents a [[dt:list]] that consists
		entirely of [[dt:rectangle]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">color</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">colour</name>
	<description>
		The [[*]] data type represents a color in the sRGB color space.
		Each color channel is specified by an integer from 0 to 65535.
		An alpha channel may or may not be specified; if not, it is
		assumed to be 65535 (opaque).
	</description>
	<properties>red, green, blue, alpha, hue, saturation, brightness</properties>
	<note>
		The [[pr:red]], [[pr:green]], [[pr:blue]], and [[pr:alpha]] properties
		are [[dt:integer]]s from 0 to 65535. The [[pr:hue]], [[pr:saturation]],
		and [[pr:brightness]] properties are [[dt:number]]s from 0 to 1.
	</note>
	<note>
		The [[dt:string]] representation of a [[*]] is the [[dt:string]]
		representations of the red, green, blue, and alpha components, in order,
		delimited by commas. If the color is opaque (the alpha component is 65535),
		only the red, green, and blue components appear in the [[dt:string]] representation.
	</note>
	<note>
		OpenXION 1.0 and 1.1 did not support an alpha channel.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">colors</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">colours</name>
	<description>
		The [[*]] data type represents a [[dt:list]] that consists
		entirely of [[dt:color]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">date</name>
	<description>
		The [[dt:date]] data type represents a date and time in the Gregorian calendar system.
		A [[dt:date]] is obtained from the [[fn:date]] and [[fn:time]] functions and the
		[[cm:convert]] command.
	</description>
	<note>
		HyperTalk considers just about any string to be a [[dt:date]], although very few
		such strings can actually be converted to [[dt:date]]s. XION is much stricter
		and only considers a string a [[dt:date]] if it can be converted to one. The
		formats XION accepts are:\\
		\\
		a U.S.-formatted date with long month and day names, e.g. [["Sunday, February 15, 2009"]]
		([[the English ]][[fn:date]]),\\
		\\
		a U.S.-formatted date with short month and day names, e.g. [["Sun, Feb 15, 2009"]],\\
		\\
		a U.S.-formatted date with numbers, e.g. [["2/15/09"]],\\
		\\
		a U.S.-formatted time with seconds, e.g. [["9:44:26 PM"]]
		([[the English ]][[fn:time]]),\\
		\\
		a U.S.-formatted time without seconds, e.g. [["9:44 PM"]],\\
		\\
		a locale-specific formatted date with long month and day names
		([[the long ]][[fn:date]]),\\
		\\
		a locale-specific formatted date with short month and day names
		([[the abbreviated ]][[fn:date]]),\\
		\\
		a locale-specific formatted date with numbers
		([[the short ]][[fn:date]]),\\
		\\
		a locale-specific formatted time with seconds
		([[the long ]][[fn:time]] or [[the abbreviated ]][[fn:time]]),\\
		\\
		a locale-specific formatted time without seconds
		([[the short ]][[fn:time]]).
	</note>
	<see-also>[[fn:date]], [[fn:time]], [[cm:convert]]</see-also>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">dates</name>
	<description>
		The [[dt:dates]] data type represents a [[dt:list]] that consists
		entirely of [[dt:date]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">binary</name>
	<description>
		The [[dt:binary]] data type represents a stream of bytes.
		In [[dt:string]] form, a [[dt:binary]] appears as a string of
		digits in hexadecimal.
	</description>
	<note>
		A [[dt:binary]] is manipulated using the chunk types [[dt:byte]],
		[[dt:tinyInt]], [[dt:shortInt]], [[dt:medInt]], [[dt:longInt]],
		[[dt:halfFloat]], [[dt:singleFloat]], and [[dt:doubleFloat]].
		Two global properties, [[pr:unsigned]] and [[pr:littleEndian]], control
		the signedness of the integer types and the byte order, respectively.
	</note>
	<note>
		The [[pr:unsigned]] property is [[cn:false]], or signed, by default.
		The [[pr:littleEndian]] property is [[cn:false]], or big-endian, by default.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">binaries</name>
	<description>
		The [[dt:binaries]] data type represents a [[dt:list]] that consists
		entirely of [[dt:binary]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">object</name>
	<description>
		The [[dt:object]] data type is the root of the class hierarchy of any
		user-defined data type.
	</description>
	<descriptors>index, ordinal, id, name</descriptors>
	<note>
		If an [[dt:object]] is a container, converting it to a [[dt:string]]
		will return the contents of the [[dt:object]] as a [[dt:string]].
		Otherwise, converting an [[dt:object]] to a [[dt:string]] results in
		a [[dt:string]] that looks like a descriptor. Conversely, a [[dt:string]]
		that is formatted like a descriptor may be converted to the [[dt:object]]
		it describes.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">objects</name>
	<description>
		The [[dt:objects]] data type represents a [[dt:list]] that consists
		entirely of [[dt:object]]s.
	</description>
	<descriptors>index-range, ordinal-range, mass</descriptors>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">interpreter</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">environment</name>
	<description>
		The [[*]] is a singleton variant that represents the XION
		interpreter. Properties of the [[*]] reflect the properties
		of the global environment.
	</description>
	<descriptors>
		singleton
	</descriptors>
	<properties>
		name, version,
		itemDelimiter, columnDelimiter, rowDelimiter, littleEndian, unsigned, textEncoding, lineEnding,
		userName, applicationPaths, documentPaths, includePaths, mathProcessor
	</properties>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">interpreters</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">environments</name>
	<description>
		The [[*]] data type represents a [[dt:list]] that consists
		entirely of [[dt:interpreter]]s.
	</description>
	<note>
		In order to use lists properly, you must declare your variables to be a kind of list.
		If a list is put into a variable that is undeclared, or declared to be a type other
		than a kind of list, the list will be converted to a single string. For example:\\
		\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[1]] because [[steve]] has only one element: the string [["1,2,3,4"]].
		However, this example:\\
		\\
		[[local steve as numbers]]\\
		[[put (1,2,3,4) into steve]]\\
		[[put the number of elements in steve]]\\
		\\
		will print [[4]] because [[steve]] has 4 elements: the numbers [[1]], [[2]], [[3]], and [[4]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">char</name>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">character</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:string]]
		that represents a single Unicode character or a range of Unicode characters.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		Accessing a [[*]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[*]] chunk that is out of range prepends or appends to the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">chars</name>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">characters</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:string]]
		that represents a range of Unicode characters.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		Accessing a [[dt:character]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:character]] chunk that is out of range prepends or appends to the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">line</name>
	<description>
		The [[dt:line]] data type is a chunk type of [[dt:string]]
		that represents a line or a range of lines. This includes empty
		lines at the beginning or in the middle of the [[dt:string]]
		but not the last trailing empty line of the [[dt:string]],
		if there is one.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		Accessing a [[dt:line]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:line]] chunk that is out of range inserts as many
		line breaks as necessary to insert text on the appropriate line of the
		parent [[dt:string]].
	</note>
	<note>
		The [[dt:line]] chunk type in HyperTalk always and only uses [[cn:return]]
		as the line ending.
		The [[dt:line]] chunk type in XION uses [[cn:return]][[op:&amp;]][[cn:newline]],
		[[cn:newline]], [[cn:return]], [[cn:linesep]], and [[cn:parasep]] as possible
		line endings. When inserting additional line breaks, [[dt:line]] uses the
		current setting of the [[pr:lineEnding]] property.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">lines</name>
	<description>
		The [[dt:lines]] data type is a chunk type of [[dt:string]]
		that represents a range of lines. This includes empty lines
		at the beginning or in the middle of the [[dt:string]] but
		not the last trailing empty line of the [[dt:string]],
		if there is one.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		Accessing a [[dt:line]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:line]] chunk that is out of range inserts as many
		line breaks as necessary to insert text on the appropriate line of the
		parent [[dt:string]].
	</note>
	<note>
		The [[dt:lines]] chunk type in HyperTalk always and only uses [[cn:return]]
		as the line ending.
		The [[dt:lines]] chunk type in XION uses [[cn:return]][[op:&amp;]][[cn:newline]],
		[[cn:newline]], [[cn:return]], [[cn:linesep]], and [[cn:parasep]] as possible
		line endings. When inserting additional line breaks, [[dt:lines]] uses the
		current setting of the [[pr:lineEnding]] property.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">item</name>
	<description>
		The [[dt:item]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by the [[pr:itemDelimiter]].
		This includes empty [[dt:item]]s but not the last trailing empty
		[[dt:item]] of the [[dt:string]], if there is one.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		Accessing an [[dt:item]] chunk that is out of range returns [[cn:empty]].
		Modifying an [[dt:item]] chunk that is out of range inserts as many
		[[pr:itemDelimiter]]s as necessary to insert text in the appropriate
		[[dt:item]] of the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">items</name>
	<description>
		The [[dt:items]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by the [[pr:itemDelimiter]].
		This includes empty [[dt:item]]s but not the last trailing empty
		[[dt:item]] of the [[dt:string]], if there is one.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		Accessing an [[dt:item]] chunk that is out of range returns [[cn:empty]].
		Modifying an [[dt:item]] chunk that is out of range inserts as many
		[[pr:itemDelimiter]]s as necessary to insert text in the appropriate
		[[dt:item]] of the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">col</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">column</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by the [[pr:columnDelimiter]].
		This includes empty [[*]]s but not the last trailing empty
		[[*]] of the [[dt:string]], if there is one.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		Accessing a [[*]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[*]] chunk that is out of range inserts as many
		[[pr:columnDelimiter]]s as necessary to insert text in the appropriate
		[[*]] of the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">cols</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">columns</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by the [[pr:columnDelimiter]].
		This includes empty [[dt:column]]s but not the last trailing empty
		[[dt:column]] of the [[dt:string]], if there is one.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		Accessing an [[dt:column]] chunk that is out of range returns [[cn:empty]].
		Modifying an [[dt:column]] chunk that is out of range inserts as many
		[[pr:columnDelimiter]]s as necessary to insert text in the appropriate
		[[dt:column]] of the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">row</name>
	<description>
		The [[dt:row]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by the [[pr:rowDelimiter]].
		This includes empty [[dt:row]]s but not the last trailing empty
		[[dt:row]] of the [[dt:string]], if there is one.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		Accessing a [[dt:row]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:row]] chunk that is out of range inserts as many
		[[pr:rowDelimiter]]s as necessary to insert text in the appropriate
		[[dt:row]] of the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">rows</name>
	<description>
		The [[dt:rows]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by the [[pr:rowDelimiter]].
		This includes empty [[dt:row]]s but not the last trailing empty
		[[dt:row]] of the [[dt:string]], if there is one.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		Accessing a [[dt:row]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:row]] chunk that is out of range inserts as many
		[[pr:rowDelimiter]]s as necessary to insert text in the appropriate
		[[dt:row]] of the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">word</name>
	<description>
		The [[dt:word]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by one or more white
		space characters.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		Accessing a [[dt:word]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:word]] chunk that is out of range prepends or appends to the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">words</name>
	<description>
		The [[dt:words]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by one or more white
		space characters.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		Accessing a [[dt:word]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:word]] chunk that is out of range prepends or appends to the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">sent</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">sentence</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text starting with a non-white space
		character and ending with a period, exclamation mark, or question
		mark followed by zero or more other non-white space characters.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		Accessing a [[*]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[*]] chunk that is out of range prepends or appends to the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">sents</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">sentences</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text starting with a non-white space
		character and ending with a period, exclamation mark, or question
		mark followed by zero or more other non-white space characters.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		Accessing a [[dt:sentence]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:sentence]] chunk that is out of range prepends or appends to the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">para</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">paragraph</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by one or more
		line breaks.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<note>
		Accessing a [[*]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[*]] chunk that is out of range prepends or appends to the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">paras</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">paragraphs</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:string]]
		that represents a chunk of text delimited by one or more
		line breaks.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		Accessing a [[dt:paragraph]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:paragraph]] chunk that is out of range prepends or appends to the parent [[dt:string]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">byte</name>
	<description>
		The [[dt:byte]] data type is a chunk type of [[dt:binary]]
		that represents a single byte or range of bytes.
	</description>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[dt:byte]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:byte]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">bytes</name>
	<description>
		The [[dt:bytes]] data type is a chunk type of [[dt:binary]]
		that represents a range of bytes.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[dt:byte]] chunk that is out of range returns [[cn:empty]].
		Modifying a [[dt:byte]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">tinyInt</name>
	<description>
		The [[dt:tinyInt]] data type is a chunk type of [[dt:binary]]
		that represents an 8-bit integer at a particular offset
		in the parent [[dt:binary]].
	</description>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[dt:tinyInt]] chunk that is out of range returns [[cn:zero]].
		Modifying a [[dt:tinyInt]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
	<note>
		The signedness and endianness of the [[dt:tinyInt]] are determined by
		the [[pr:unsigned]] and [[pr:littleEndian]] global properties.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">tinyInts</name>
	<description>
		The [[dt:tinyInts]] data type represents a [[dt:list]] that consists
		entirely of [[dt:tinyInt]]s.
	</description>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">shortInt</name>
	<description>
		The [[dt:shortInt]] data type is a chunk type of [[dt:binary]]
		that represents a 16-bit integer at a particular offset
		in the parent [[dt:binary]].
	</description>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[dt:shortInt]] chunk that is out of range returns [[cn:zero]].
		Modifying a [[dt:shortInt]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
	<note>
		The signedness and endianness of the [[dt:shortInt]] are determined by
		the [[pr:unsigned]] and [[pr:littleEndian]] global properties.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">shortInts</name>
	<description>
		The [[dt:shortInts]] data type represents a [[dt:list]] that consists
		entirely of [[dt:shortInt]]s.
	</description>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">medInt</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">mediumInt</name>
	<description>
		The [[*]] data type is a chunk type of [[dt:binary]]
		that represents a 32-bit integer at a particular offset
		in the parent [[dt:binary]].
	</description>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[*]] chunk that is out of range returns [[cn:zero]].
		Modifying a [[*]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
	<note>
		The signedness and endianness of the [[*]] are determined by
		the [[pr:unsigned]] and [[pr:littleEndian]] global properties.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">medInts</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">mediumInts</name>
	<description>
		The [[*]] data type represents a [[dt:list]] that consists
		entirely of [[dt:mediumInt]]s.
	</description>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">longInt</name>
	<description>
		The [[dt:longInt]] data type is a chunk type of [[dt:binary]]
		that represents a 64-bit integer at a particular offset
		in the parent [[dt:binary]].
	</description>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[dt:longInt]] chunk that is out of range returns [[cn:zero]].
		Modifying a [[dt:longInt]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
	<note>
		The signedness and endianness of the [[dt:longInt]] are determined by
		the [[pr:unsigned]] and [[pr:littleEndian]] global properties.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">longInts</name>
	<description>
		The [[dt:longInts]] data type represents a [[dt:list]] that consists
		entirely of [[dt:longInt]]s.
	</description>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">halfFloat</name>
	<description>
		The [[dt:halfFloat]] data type is a chunk type of [[dt:binary]]
		that represents an IEEE-format half-precision floating point number
		at a particular offset in the parent [[dt:binary]].
	</description>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[dt:halfFloat]] chunk that is out of range returns [[cn:zero]].
		Modifying a [[dt:halfFloat]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
	<note>
		The endianness of the [[dt:halfFloat]] is determined by
		the [[pr:littleEndian]] global property.
	</note>
	<note>
		The half-precision format has one sign bit, 5 exponent bits, and 10 mantissa bits.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">halfFloats</name>
	<description>
		The [[dt:halfFloats]] data type represents a [[dt:list]] that consists
		entirely of [[dt:halfFloat]]s.
	</description>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">singleFloat</name>
	<description>
		The [[dt:singleFloat]] data type is a chunk type of [[dt:binary]]
		that represents an IEEE-format single-precision floating point number
		at a particular offset in the parent [[dt:binary]].
	</description>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[dt:singleFloat]] chunk that is out of range returns [[cn:zero]].
		Modifying a [[dt:singleFloat]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
	<note>
		The endianness of the [[dt:singleFloat]] is determined by
		the [[pr:littleEndian]] global property.
	</note>
	<note>
		The single-precision format has one sign bit, 8 exponent bits, and 23 mantissa bits.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">singleFloats</name>
	<description>
		The [[dt:singleFloats]] data type represents a [[dt:list]] that consists
		entirely of [[dt:singleFloat]]s.
	</description>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">doubleFloat</name>
	<description>
		The [[dt:doubleFloat]] data type is a chunk type of [[dt:binary]]
		that represents an IEEE-format double-precision floating point number
		at a particular offset in the parent [[dt:binary]].
	</description>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<note>
		The chunks of a [[dt:binary]] are numbered starting at zero.
		This is one of the very few instances of zero-based indexing in XION,
		as most indexes start at 1.
	</note>
	<note>
		Accessing a [[dt:doubleFloat]] chunk that is out of range returns [[cn:zero]].
		Modifying a [[dt:doubleFloat]] chunk that is out of range inserts as many
		zero bytes as necessary to insert data at the appropriate offset in the
		parent [[dt:binary]].
	</note>
	<note>
		The endianness of the [[dt:doubleFloat]] is determined by
		the [[pr:littleEndian]] global property.
	</note>
	<note>
		The double-precision format has one sign bit, 11 exponent bits, and 52 mantissa bits.
	</note>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">doubleFloats</name>
	<description>
		The [[dt:doubleFloats]] data type represents a [[dt:list]] that consists
		entirely of [[dt:doubleFloat]]s.
	</description>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">disk</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">volume</name>
	<description>
		The [[*]] data type represents a mounted volume in the file system.
		A [[*]] may contain [[dt:folder]]s, [[dt:directory]]s, and [[dt:file]]s.
	</description>
	<properties>name, path, count</properties>
	<descriptors>
		index, ordinal, name
	</descriptors>
	<security>
		To use [[*]]s, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[dt:folder]]</see-also>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">disks</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">volumes</name>
	<description>
		The [[*]] data type represents a [[dt:list]] that consists
		entirely of [[dt:disk]]s or [[dt:volume]]s.
	</description>
	<descriptors>
		index-range, ordinal-range, mass
	</descriptors>
	<security>
		To use [[*]], OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[dt:folder]]</see-also>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">folder</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">directory</name>
	<description>
		The [[*]] data type represents a folder or directory in the file system.
		A [[*]] may contain [[dt:folder]]s, [[dt:directory]]s, and [[dt:file]]s.
	</description>
	<properties>name, path, modificationDate, count</properties>
	<descriptors>
		index, ordinal, name, child-index, child-ordinal, child-name
	</descriptors>
	<note>
		If no parent [[dt:disk]], [[dt:volume]], [[dt:folder]], or [[dt:directory]]
		is specified, the current directory is used as the parent.
	</note>
	<security>
		To use [[*]]s, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		To delete or change the properties of [[*]]s, OpenXION's security settings must allow the [[FILE_SYSTEM_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[dt:disk]], [[dt:file]]</see-also>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">folders</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">directories</name>
	<description>
		The [[*]] data type represents a [[dt:list]] that consists
		entirely of [[dt:folder]]s or [[dt:directory]]s.
	</description>
	<descriptors>
		index-range, ordinal-range, mass, child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		If no parent [[dt:disk]], [[dt:volume]], [[dt:folder]], or [[dt:directory]]
		is specified, the current directory is used as the parent.
	</note>
	<security>
		To use [[*]], OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		To delete or change the properties of [[*]], OpenXION's security settings must allow the [[FILE_SYSTEM_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[dt:disk]], [[dt:file]]</see-also>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">file</name>
	<description>
		The [[dt:file]] data type represents a file in the file system.
		A [[dt:file]] may contain [[dt:fork]]s.
	</description>
	<properties>name, path, modificationDate, size</properties>
	<descriptors>
		index, ordinal, name, child-index, child-ordinal, child-name
	</descriptors>
	<note>
		If no parent [[dt:disk]], [[dt:volume]], [[dt:folder]], or [[dt:directory]]
		is specified, the current directory is used as the parent.
	</note>
	<security>
		To use [[*]]s, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		To delete or change the properties of [[*]]s, OpenXION's security settings must allow the [[FILE_SYSTEM_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[dt:fork]], [[dt:folder]], [[mg:file]], [[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">files</name>
	<description>
		The [[dt:files]] data type represents a [[dt:list]] that consists
		entirely of [[dt:file]]s.
	</description>
	<descriptors>
		index-range, ordinal-range, mass, child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<note>
		If no parent [[dt:disk]], [[dt:volume]], [[dt:folder]], or [[dt:directory]]
		is specified, the current directory is used as the parent.
	</note>
	<security>
		To use [[*]], OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		To delete or change the properties of [[*]], OpenXION's security settings must allow the [[FILE_SYSTEM_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[dt:fork]], [[dt:folder]], [[mg:file]], [[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">fork</name>
	<description>
		The [[dt:fork]] data type represents a fork of a file in the file system.
	</description>
	<properties>name, size</properties>
	<descriptors>
		child-index, child-ordinal, child-name
	</descriptors>
	<security>
		To use [[*]]s, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		To delete or change the properties of [[*]]s, OpenXION's security settings must allow the [[FILE_SYSTEM_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[dt:file]], [[mg:file]], [[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</datatype>

<datatype>
	<name dialects="xn1,oxn1,oxn11,oxn12">forks</name>
	<description>
		The [[dt:forks]] data type represents a [[dt:list]] that consists
		entirely of [[dt:fork]]s.
	</description>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<security>
		To use [[*]], OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		To delete or change the properties of [[*]], OpenXION's security settings must allow the [[FILE_SYSTEM_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[dt:file]], [[mg:file]], [[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</datatype>

<datatype>
	<name dialects="oxne1,oxne11,oxne12,hyp">clipboard</name>
	<description>
		The [[*]] is a singleton variant that represents the clipboard.
		It is used as a container to provide copy and paste functionality
		to a script.
	</description>
	<descriptors>
		singleton
	</descriptors>
	<security>
		To read the contents of the clipboard, OpenXION's security settings must allow the [[CLIPBOARD_READ]] security key.
		To change the contents of the clipboard, OpenXION's security settings must allow the [[CLIPBOARD_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</datatype>

<datatype>
	<name dialects="oxne1,oxne11,oxne12">clipboards</name>
	<description>
		The [[*]] data type represents a [[dt:list]] that consists
		entirely of [[dt:clipboard]]s.
	</description>
	<security>
		To read the contents of the clipboard, OpenXION's security settings must allow the [[CLIPBOARD_READ]] security key.
		To change the contents of the clipboard, OpenXION's security settings must allow the [[CLIPBOARD_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</datatype>

<datatype>
	<name dialects="oxne1,oxne11,oxne12">URL</name>
	<description>
		The [[dt:URL]] data type represents a URL.
	</description>
	<descriptors>
		name
	</descriptors>
	<note>
		Opening a [[dt:URL]] with the [[cm:open]] command without specifying an I/O method
		opens the URL in the user's default browser. Opening a [[dt:URL]] while specifying
		an I/O method allows using the [[cm:read]] and [[cm:write]] commands to read and
		write to the URL.
	</note>
	<see-also>[[mg:URL]], [[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</datatype>

<datatype>
	<name dialects="oxne1,oxne11,oxne12">URLs</name>
	<description>
		The [[dt:URLs]] data type represents a [[dt:list]] that consists
		entirely of [[dt:URL]]s.
	</description>
	<see-also>[[mg:URL]], [[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</datatype>

<property>
	<name dialects="oxn1,oxn11,oxn12">userName</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<example>answer "Hello," && the long [[*]] & "!"</example>
	<description>
		The [[*]] property determines the user's login name or full real name.
		The [[short ]][[*]] or [[abbreviated ]][[*]] is usually the user's login name.
		The [[long ]][[*]] is usually the user's full real name.
		If no modifier is specified, [[long]] is assumed.
	</description>
	<description>
		In OpenXION 1.0 and 1.1, the [[long ]][[*]] can be [[cm:set]] but the [[short ]][[*]] is read-only.
		In OpenXION 1.2 and later, both the [[long ]][[*]] and the [[short ]][[*]] are read-only.
		(See note.)
	</description>
	<note>
		HyperTalk did not have this property but used a [[Username]] global variable for the same purpose.
		OpenXION avoids using any XION global variables for special purposes.
	</note>
	<note>
		OpenXION 1.0 and 1.1 did not get the user's full real name from the system,
		but left the [[long ]][[*]] as a property to be [[cm:set]] by the user themselves.
		OpenXION 1.2 and later will get the user's full real name from the system instead.
	</note>
	<note>
		The [[*]] property is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
</property>

<property>
	<name dialects="oxn1,oxn11,oxn12">applicationPaths</name>
	<name dialects="oxn1,oxn11,oxn12">programPaths</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields a list of file system paths delimited by line breaks.</syntax-note>
	<example>set [[*]] to the [[*]] &amp; newline &amp; "/home/jdoe/bin/"</example>
	<description>
		The [[*]] property determines or changes the list of file system paths
		searched by the [[cm:open]] command and the [[fn:appPath]], [[fn:appFile]],
		[[fn:appOrDocPath]], and [[fn:appOrDocFile]] functions to locate applications
		or program files.
	</description>
	<note>
		HyperTalk did not have this property but used an [[Applications]] global variable for the same purpose.
		OpenXION avoids using any XION global variables for special purposes.
	</note>
	<note>
		The default list of paths in OpenXION is, on Mac OS X:\\
		\\
		[[/Applications/\\
		/Applications/Utilities/\\
		/Applications (Mac OS 9)/\\
		~/Applications/\\
		/Developer/Applications/\\
		/Developer/Applications/Utilities/\\
		/bin/\\
		/sbin/\\
		/usr/bin/\\
		/usr/sbin/\\
		/usr/local/bin/\\
		/usr/local/sbin/\\
		/usr/shared/bin/\\
		/usr/shared/sbin/\\
		/opt/bin/\\
		/opt/sbin/\\
		/opt/local/bin/\\
		/opt/local/sbin/\\
		/opt/shared/bin/\\
		/opt/shared/sbin/]]\\
		\\
		On Windows:\\
		\\
		[[C:\Program Files\ \\
		C:\Windows\ \\
		C:\Windows\System32\ ]]\\
		\\
		On all other systems:\\
		\\
		[[/bin/\\
		/sbin/\\
		/usr/bin/\\
		/usr/sbin/\\
		/usr/local/bin/\\
		/usr/local/sbin/\\
		/usr/shared/bin/\\
		/usr/shared/sbin/\\
		/opt/bin/\\
		/opt/sbin/\\
		/opt/local/bin/\\
		/opt/local/sbin/\\
		/opt/shared/bin/\\
		/opt/shared/sbin/]]\\
		\\
		The [[~]] refers to the user's home directory.
	</note>
	<note>
		OpenXION reads the value of this property from a file at startup
		and writes it back to the file upon exit. This file is located at
		[[~/Library/Preferences/com.kreative.openxion.conf]] (on Mac OS X),
		[[~\Application Data\OpenXION\xion.conf]] (on Windows),
		or [[~/.xion.conf]] (on all other systems).
		This is a plain text file that can be edited with any text editor.
	</note>
	<note>
		The [[*]] property is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To change the value of this property, OpenXION's security settings must allow the [[SEARCH_PATHS]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[fn:appPath]], [[fn:appFile]], [[fn:appOrDocPath]], [[fn:appOrDocFile]]</see-also>
</property>

<property>
	<name dialects="oxn1,oxn11,oxn12">documentPaths</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields a list of file system paths delimited by line breaks.</syntax-note>
	<example>set [[*]] to the [[*]] &amp; newline &amp; "/home/jdoe/work/"</example>
	<description>
		The [[*]] property determines or changes the list of file system paths
		searched by the [[cm:open]] command and the [[fn:docPath]], [[fn:docFile]],
		[[fn:appOrDocPath]], and [[fn:appOrDocFile]] functions to locate document files.
	</description>
	<note>
		HyperTalk did not have this property but used a [[Documents]] global variable for the same purpose.
		OpenXION avoids using any XION global variables for special purposes.
	</note>
	<note>
		The default list of paths in OpenXION is, on Mac OS X:\\
		\\
		[[~/Desktop/\\
		~/Documents/\\
		~/Downloads/\\
		~/Pictures/\\
		~/Music/\\
		~/Movies/\\
		~/Public/\\
		~/Sites/\\
		~/]]\\
		\\
		On Windows:\\
		\\
		[[~\Desktop\ \\
		~\My Documents\ \\
		~\My Photos\ \\
		~\My Music\ \\
		~\My Videos\ \\
		~\ ]]\\
		\\
		On all other systems:\\
		\\
		[[~/]]\\
		\\
		The [[~]] refers to the user's home directory.
	</note>
	<note>
		OpenXION reads the value of this property from a file at startup
		and writes it back to the file upon exit. This file is located at
		[[~/Library/Preferences/com.kreative.openxion.conf]] (on Mac OS X),
		[[~\Application Data\OpenXION\xion.conf]] (on Windows),
		or [[~/.xion.conf]] (on all other systems).
		This is a plain text file that can be edited with any text editor.
	</note>
	<note>
		The [[*]] property is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To change the value of this property, OpenXION's security settings must allow the [[SEARCH_PATHS]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[fn:docPath]], [[fn:docFile]], [[fn:appOrDocPath]], [[fn:appOrDocFile]]</see-also>
</property>

<property>
	<name dialects="oxn11,oxn12">includePaths</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields a list of file system paths delimited by line breaks.</syntax-note>
	<example>set [[*]] to the [[*]] &amp; newline &amp; "/home/jdoe/scripts/"</example>
	<description>
		The [[*]] property determines or changes the list of file system paths
		searched by the [[cs:include]] and [[cs:require]] keywords and the [[fn:includePath]]
		and [[fn:includeFile]] functions to locate include files.
	</description>
	<note>
		The default list of paths in OpenXION consists solely of the current working directory.
	</note>
	<note>
		OpenXION reads the value of this property from a file at startup
		and writes it back to the file upon exit. This file is located at
		[[~/Library/Preferences/com.kreative.openxion.conf]] (on Mac OS X),
		[[~\Application Data\OpenXION\xion.conf]] (on Windows),
		or [[~/.xion.conf]] (on all other systems).
		This is a plain text file that can be edited with any text editor.
	</note>
	<note>
		The [[*]] property is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To change the value of this property, OpenXION's security settings must allow the [[SEARCH_PATHS]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cs:include]], [[cs:require]], [[fn:includePath]], [[fn:includeFile]]</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">itemDelimiter</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields a single character.</syntax-note>
	<example>
		if the [[*]] &lt;&gt; comma\\
		then set the [[*]] to comma
	</example>
	<example>set [[*]] to "#"</example>
	<description>
		The [[*]] property determines or changes the character that delimits [[dt:item]] chunks.
		The default value is [[cn:comma]].
	</description>
	<description>
		Changing the item delimiter has no effect on other data types, such as
		[[dt:point]] or [[dt:rectangle]], or on functions, such as [[fn:dateItems]].
	</description>
	<see-also>[[dt:item]], [[pr:rowDelimiter]], [[pr:columnDelimiter]]</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">columnDelimiter</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields a single character.</syntax-note>
	<example>set [[*]] to delete</example>
	<description>
		The [[*]] property determines or changes the character that delimits [[dt:column]] chunks.
		The default value is Unicode character [[U+FFF0]].
	</description>
	<see-also>[[dt:column]], [[pr:itemDelimiter]], [[pr:rowDelimiter]]</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">rowDelimiter</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields a single character.</syntax-note>
	<example>set [[*]] to backspace</example>
	<description>
		The [[*]] property determines or changes the character that delimits [[dt:row]] chunks.
		The default value is Unicode character [[U+FFF1]].
	</description>
	<see-also>[[dt:row]], [[pr:itemDelimiter]], [[pr:columnDelimiter]]</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">littleEndian</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {boolean}</syntax>
	<syntax-note>{Boolean} yields [[cn:true]] (for little-endian) or [[cn:false]] (for big-endian)</syntax-note>
	<example>set the [[*]] to true</example>
	<description>
		The [[*]] property determines or changes the endianness of the
		[[dt:tinyInt]], [[dt:shortInt]], [[dt:mediumInt]], [[dt:longInt]],
		[[dt:halfFloat]], [[dt:singleFloat]], and [[dt:doubleFloat]]
		binary numeric chunk types. A [[cn:true]] value indicates that
		binary data should be treated as little-endian. A [[cn:false]]
		value indicates that binary data should be treated as big-endian.
		The default is [[cn:false]], or big-endian.
		This was chosen as the default because the 68000 and PowerPC architectures
		running Mac OS Classic and the Java virtual machine are big-endian.
	</description>
	<see-also>
		[[pr:unsigned]], [[dt:binary]],
		[[dt:tinyInt]], [[dt:shortInt]], [[dt:mediumInt]], [[dt:longInt]],
		[[dt:halfFloat]], [[dt:singleFloat]], [[dt:doubleFloat]]
	</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">unsigned</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {boolean}</syntax>
	<syntax-note>{Boolean} yields [[cn:true]] (for unsigned) or [[cn:false]] (for signed)</syntax-note>
	<example>set the [[*]] to false</example>
	<description>
		The [[*]] property determines or changes the signedness of the
		[[dt:tinyInt]], [[dt:shortInt]], [[dt:mediumInt]], and [[dt:longInt]]
		binary numeric chunk types. A [[cn:true]] value indicates that
		binary data should be treated as unsigned. A [[cn:false]] value
		indicates that binary data should be treated as signed.
		The default is [[cn:false]], or signed.
	</description>
	<see-also>
		[[pr:littleEndian]], [[dt:binary]],
		[[dt:tinyInt]], [[dt:shortInt]], [[dt:mediumInt]], [[dt:longInt]]
	</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">numberFormat</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields the format to be used for the display of numbers.</syntax-note>
	<example>set [[*]] to "00.##" -- displays 02.21 for 2.21</example>
	<example>set [[*]] to "0" -- displays 2 for 2.21</example>
	<example>set [[*]] to "0.0" -- displays 2.2 for 2.21</example>
	<description>
		The [[*]] property determines the format used when [[dt:integer]]s, [[dt:number]]s, and [[dt:complex]]es
		are converted to [[dt:string]]s. Use zeroes ([[0]]) to represent digits that always appear, a period ([[.]])
		to represent the decimal point, and number signs ([[#]]) to represent digits that appear only when they
		are non-zero. Use [[E]] followed by one or more zeroes to specify scientific notation. If scientific notation
		is specified, you can use [[&lt;]] followed by an integer to specify scientific notation only for numbers with
		an exponent less than or equal to that integer, and [[&gt;]] followed by an integer to specify scientific
		notation only for numbers with an exponent greater than or equal to that integer.
	</description>
	<description>
		The following table illustrates various number formats:\\\\
		::TABLE
		{{Format}}            :: {{0}}        :: {{0.00715}}  :: {{0.0715}}   :: {{0.715}}    :: {{7.15}}     :: {{71.5}}      :: {{715}}        :: {{7150}}
		...........................................................................................................................................................
		[[0.######]]          :: [[0]]        :: [[0.00715]]  :: [[0.0715]]   :: [[0.715]]    :: [[7.15]]     :: [[71.5]]      :: [[715]]        :: [[7150]]
		...........................................................................................................................................................
		[[0.##]]              :: [[0]]        :: [[0.01]]     :: [[0.07]]     :: [[0.72]]     :: [[7.15]]     :: [[71.5]]      :: [[715]]        :: [[7150]]
		...........................................................................................................................................................
		[[0.#]]               :: [[0]]        :: [[0]]        :: [[0.1]]      :: [[0.7]]      :: [[7.2]]      :: [[71.5]]      :: [[715]]        :: [[7150]]
		...........................................................................................................................................................
		[[0.000000]]          :: [[0.000000]] :: [[0.007150]] :: [[0.071500]] :: [[0.715000]] :: [[7.150000]] :: [[71.500000]] :: [[715.000000]] :: [[7150.000000]]
		...........................................................................................................................................................
		[[0.00]]              :: [[0.00]]     :: [[0.01]]     :: [[0.07]]     :: [[0.72]]     :: [[7.15]]     :: [[71.50]]     :: [[715.00]]     :: [[7150.00]]
		...........................................................................................................................................................
		[[0.0]]               :: [[0.0]]      :: [[0.0]]      :: [[0.1]]      :: [[0.7]]      :: [[7.2]]      :: [[71.5]]      :: [[715.0]]      :: [[7150.0]]
		...........................................................................................................................................................
		[[0.00##]]            :: [[0.00]]     :: [[0.0072]]   :: [[0.0715]]   :: [[0.715]]    :: [[7.15]]     :: [[71.50]]     :: [[715.00]]     :: [[7150.00]]
		...........................................................................................................................................................
		[[0.0#]]              :: [[0.0]]      :: [[0.01]]     :: [[0.07]]     :: [[0.72]]     :: [[7.15]]     :: [[71.5]]      :: [[715.0]]      :: [[7150.0]]
		...........................................................................................................................................................
		[[0]]                 :: [[0]]        :: [[0]]        :: [[0]]        :: [[1]]        :: [[7]]        :: [[72]]        :: [[715]]        :: [[7150]]
		...........................................................................................................................................................
		[[0.###E0]]           :: [[0E0]]      :: [[7.15E-3]]  :: [[7.15E-2]]  :: [[7.15E-1]]  :: [[7.15E0]]   :: [[7.15E1]]    :: [[7.15E2]]     :: [[7.15E3]]
		...........................................................................................................................................................
		[[0.#E0]]             :: [[0E0]]      :: [[7.2E-3]]   :: [[7.2E-2]]   :: [[7.2E-1]]   :: [[7.2E0]]    :: [[7.2E1]]     :: [[7.2E2]]      :: [[7.2E3]]
		...........................................................................................................................................................
		[[0.#E00]]            :: [[0E00]]     :: [[7.2E-03]]  :: [[7.2E-02]]  :: [[7.2E-01]]  :: [[7.2E00]]   :: [[7.2E01]]    :: [[7.2E02]]     :: [[7.2E03]]
		...........................................................................................................................................................
		[[0.000E0]]           :: [[0.000E0]]  :: [[7.150E-3]] :: [[7.150E-2]] :: [[7.150E-1]] :: [[7.150E0]]  :: [[7.150E1]]   :: [[7.150E2]]    :: [[7.150E3]]
		...........................................................................................................................................................
		[[0.##E0&lt;-3&gt;3]] :: [[0]]        :: [[7.15E-3]]  :: [[0.07]]     :: [[0.72]]     :: [[7.15]]     :: [[71.5]]      :: [[715]]        :: [[7.15E3]]
		...........................................................................................................................................................
		[[0.##E0&lt;-2&gt;2]] :: [[0]]        :: [[7.15E-3]]  :: [[7.15E-2]]  :: [[0.72]]     :: [[7.15]]     :: [[71.5]]      :: [[7.15E2]]     :: [[7.15E3]]
		...........................................................................................................................................................
		[[0.##E0&lt;-1&gt;1]] :: [[0]]        :: [[7.15E-3]]  :: [[7.15E-2]]  :: [[7.15E-1]]  :: [[7.15]]     :: [[7.15E1]]    :: [[7.15E2]]     :: [[7.15E3]]
		...........................................................................................................................................................
		[[0.###'0]]           :: [[0'0]]      :: [[7.15''3]]  :: [[7.15''2]]  :: [[7.15''1]]  :: [[7.15'0]]   :: [[7.15'1]]    :: [[7.15'2]]     :: [[7.15'3]]
		...........................................................................................................................................................
		[[0.#'0]]             :: [[0'0]]      :: [[7.2''3]]   :: [[7.2''2]]   :: [[7.2''1]]   :: [[7.2'0]]    :: [[7.2'1]]     :: [[7.2'2]]      :: [[7.2'3]]
		...........................................................................................................................................................
		[[0.#'00]]            :: [[0'00]]     :: [[7.2''03]]  :: [[7.2''02]]  :: [[7.2''01]]  :: [[7.2'00]]   :: [[7.2'01]]    :: [[7.2'02]]     :: [[7.2'03]]
		...........................................................................................................................................................
		[[0.000'0]]           :: [[0.000'0]]  :: [[7.150''3]] :: [[7.150''2]] :: [[7.150''1]] :: [[7.150'0]]  :: [[7.150'1]]   :: [[7.150'2]]    :: [[7.150'3]]
		...........................................................................................................................................................
		[[0.##'0&lt;-3&gt;3]] :: [[0]]        :: [[7.15''3]]  :: [[0.07]]     :: [[0.72]]     :: [[7.15]]     :: [[71.5]]      :: [[715]]        :: [[7.15'3]]
		...........................................................................................................................................................
		[[0.##'0&lt;-2&gt;2]] :: [[0]]        :: [[7.15''3]]  :: [[7.15''2]]  :: [[0.72]]     :: [[7.15]]     :: [[71.5]]      :: [[7.15'2]]     :: [[7.15'3]]
		...........................................................................................................................................................
		[[0.##'0&lt;-1&gt;1]] :: [[0]]        :: [[7.15''3]]  :: [[7.15''2]]  :: [[7.15''1]]  :: [[7.15]]     :: [[7.15'1]]    :: [[7.15'2]]     :: [[7.15'3]]
		ELBAT::
	</description>
	<note>
		The [[*]] property does not affect the accuracy or precision of mathematical operations,
		only the presentation of the results.
	</note>
	<note>
		HyperTalk supports only the [[0]], [[.]], and [[#]] characters in its [[*]] property.
	</note>
	<note>
		The default number format in both HyperTalk and XION is [[0.######]].
	</note>
	<see-also>
		[[pr:precision]]
	</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">textEncoding</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {encoding}</syntax>
	<syntax-note>{Encoding} yields the name of a text encoding supported by the XION interpreter.</syntax-note>
	<example>set [[*]] to "ISO-8859-1"</example>
	<example>set the [[*]] to "UTF-8"</example>
	<example>set [[*]] to "MacRoman"</example>
	<description>
		The [[*]] property determines or changes the text encoding used by several commands
		and functions, among them [[cm:open]], [[fn:numToChar]], and [[fn:charToNum]], and
		[[\x]] escape sequences in quoted literals.
	</description>
	<note>
		The default text encoding in OpenXION is ISO-8859-1.
	</note>
	<note>
		The XION Scripting Language Standard specifies ISO-8859-1, UTF-8, UTF-16, and MacRoman
		as the minimal set of supported text encodings.
	</note>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">lineEnding</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields a line break of some type.</syntax-note>
	<example>set [[*]] to return&amp;newline -- MS-DOS style</example>
	<example>set [[*]] to return -- Mac OS Classic style</example>
	<example>set [[*]] to newline -- Unix style</example>
	<description>
		The [[*]] property determines or changes the line endings created by the [[dt:line]]
		chunk type and the [[cm:sort]] command, and the line endings used in the default
		[[pr:applicationPaths]], [[pr:documentPaths]], and [[pr:includePaths]].
	</description>
	<note>
		The default line ending in OpenXION is [[cn:newline]].
	</note>
	<note>
		For consistent behavior, the [[*]] should be set to one of the following:
		[[cn:return]][[op:&amp;]][[cn:newline]], [[cn:newline]], [[cn:return]], [[cn:linesep]],
		or [[cn:parasep]]. Although the [[*]] can be set to anything, only those
		particular strings will be {recognized} as line endings, no matter what the
		[[*]] is set to.
	</note>
</property>

<property>
	<name dialects="oxn1,oxn11,oxn12">mathProcessor</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields either [["fast"]] or [["big"]].</syntax-note>
	<example>set [[*]] to "fast"</example>
	<example>set [[*]] to "big"</example>
	<description>
		The [[*]] property determines or changes how mathematical functions are evaluated.
		If the [[*]] is set to [["fast"]], mathematical functions use IEEE double precision
		for the best performance. If the [[*]] is set to [["big"]], mathematical functions
		use various methods with arbitrary precision for the best accuracy. The number of
		fractional digits used when the [[*]] is set to [["big"]] is determined by the
		[[pr:precision]] property.
	</description>
	<description>
		Evaluating expressions with the [[*]] set to [["big"]] will significantly slow down
		scripts, so the [[*]] is set to [["fast"]] by default.
	</description>
	<note>
		The [[*]] property is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<see-also>
		[[pr:precision]], [[pr:roundingMode]]
	</see-also>
</property>

<property>
	<name dialects="oxn1,oxn11,oxn12">precision</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {precision}</syntax>
	<syntax-note>{Precision} yields a non-negative [[dt:integer]].</syntax-note>
	<example>set [[*]] to 100</example>
	<example>set [[*]] to 6</example>
	<description>
		The [[*]] property determines or changes the number of fractional digits
		used when evaluating mathematical operations, as well as mathematical functions
		when the [[pr:mathProcessor]] is set to [["big"]].
	</description>
	<description>
		The default value of the [[*]] property is 100.
	</description>
	<note>
		The [[*]] property does not affect the formatting of numbers, only the precision
		of calculations. See the [[pr:numberFormat]] property.
	</note>
	<note>
		The [[*]] property is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<see-also>
		[[pr:numberFormat]], [[pr:roundingMode]], [[pr:mathProcessor]]
	</see-also>
</property>

<property>
	<name dialects="oxn1,oxn11,oxn12">roundingMode</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields [["ceiling"]], [["floor"]], [["up"]], [["down"]], [["nearest"]], or [["even"]].</syntax-note>
	<example>set [[*]] to "even"</example>
	<example>set [[*]] to "down"</example>
	<description>
		The [[*]] property determines or changes the rounding mode used
		when evaluating mathematical operations and functions. The possible
		values for the [[*]] are [["ceiling"]], corresponding to the rounding
		used by the [[fn:ceil]] function; [["floor"]], corresponding to the
		rounding used by the [[fn:floor]] function; [["up"]], corresponding
		to the rounding used by the [[fn:aug]] function; [["down"]], corresponding
		to the rounding used by the [[fn:trunc]] function; [["nearest"]],
		corresponding to the rounding used by the [[fn:round]] function; and
		[["even"]], corresponding to the rounding used by the [[fn:rint]] function.
	</description>
	<description>
		The default value of the [[*]] property is [["even"]].
	</description>
	<note>
		The [[*]] property is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<see-also>
		[[pr:precision]], [[pr:mathProcessor]]
	</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">left</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the x coordinate of the top left corner of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">top</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the y coordinate of the top left corner of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">right</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the x coordinate of the bottom right corner of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">bottom</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the y coordinate of the bottom right corner of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">topLeft</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the top left corner of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">topRight</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the top right corner of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">botLeft</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">bottomLeft</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the bottom left corner of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">botRight</name>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">bottomRight</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the bottom right corner of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">loc</name>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">location</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">center</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the center of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">width</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the width of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">height</name>
	<applies-to>[[dt:Rectangle]]s</applies-to>
	<syntax>the [[*]] of {rectangle}</syntax>
	<syntax-note>{Rectangle} yields a [[dt:rectangle]].</syntax-note>
	<example>get the [[*]] of ((100,50,600,230) as rectangle)</example>
	<description>
		The [[*]] property determines the height of a rectangle.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">red</name>
	<applies-to>[[dt:Color]]s</applies-to>
	<syntax>the [[*]] of {color}</syntax>
	<syntax-note>{Color} yields a [[dt:color]].</syntax-note>
	<example>get the [[*]] of purple</example>
	<description>
		The [[*]] property determines the intensity of the red channel of a color.
		The intensity is specified as an [[dt:integer]] between zero and 65535, inclusive.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">green</name>
	<applies-to>[[dt:Color]]s</applies-to>
	<syntax>the [[*]] of {color}</syntax>
	<syntax-note>{Color} yields a [[dt:color]].</syntax-note>
	<example>get the [[*]] of purple</example>
	<description>
		The [[*]] property determines the intensity of the green channel of a color.
		The intensity is specified as an [[dt:integer]] between zero and 65535, inclusive.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">blue</name>
	<applies-to>[[dt:Color]]s</applies-to>
	<syntax>the [[*]] of {color}</syntax>
	<syntax-note>{Color} yields a [[dt:color]].</syntax-note>
	<example>get the [[*]] of purple</example>
	<description>
		The [[*]] property determines the intensity of the blue channel of a color.
		The intensity is specified as an [[dt:integer]] between zero and 65535, inclusive.
	</description>
</property>

<property>
	<name dialects="xn1,oxn12">alpha</name>
	<applies-to>[[dt:Color]]s</applies-to>
	<syntax>the [[*]] of {color}</syntax>
	<syntax-note>{Color} yields a [[dt:color]].</syntax-note>
	<example>get the [[*]] of purple</example>
	<description>
		The [[*]] property determines the alpha channel of a color.
		The alpha is specified as an [[dt:integer]] between zero (transparent) and 65535 (opaque), inclusive.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">hue</name>
	<applies-to>[[dt:Color]]s</applies-to>
	<syntax>the [[*]] of {color}</syntax>
	<syntax-note>{Color} yields a [[dt:color]].</syntax-note>
	<example>get the [[*]] of purple</example>
	<description>
		The [[*]] property determines the hue of a color.
		The hue is specified as a [[dt:number]] between 0.0 and 1.0, inclusive.
		A hue of 0.0 is red, 0.1666... is yellow, 0.333... is green, 0.5 is cyan,
		0.666... is blue, and 0.8333... is magenta.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">saturation</name>
	<applies-to>[[dt:Color]]s</applies-to>
	<syntax>the [[*]] of {color}</syntax>
	<syntax-note>{Color} yields a [[dt:color]].</syntax-note>
	<example>get the [[*]] of purple</example>
	<description>
		The [[*]] property determines the saturation of a color.
		The saturation is specified as a [[dt:number]] between 0.0 and 1.0, inclusive.
		A saturation of 0.0 is a shade of gray while a saturation of 1.0 is a full color.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">brightness</name>
	<applies-to>[[dt:Color]]s</applies-to>
	<syntax>the [[*]] of {color}</syntax>
	<syntax-note>{Color} yields a [[dt:color]].</syntax-note>
	<example>get the [[*]] of purple</example>
	<description>
		The [[*]] property determines the brightness or value of a color.
		The value is specified as a [[dt:number]] between 0.0 and 1.0, inclusive.
		A value of 0.0 is black while a value of 1.0 is a full color.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">name</name>
	<applies-to>File system objects ([[dt:disk]]s, [[dt:folder]]s, [[dt:file]]s, and [[dt:fork]]s)</applies-to>
	<applies-to>User-defined objects</applies-to>
	<syntax>the [[*]] of {object}</syntax>
	<example>get the [[*]] of the first file</example>
	<description>
		The [[*]] property determines or changes the name of an object.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">id</name>
	<applies-to>User-defined objects</applies-to>
	<syntax>the [[*]] of {object}</syntax>
	<example>get the [[*]] of steve</example>
	<description>
		The [[*]] property determines the unique ID number of an object.
		An object's ID number will never change during the object's lifetime
		and will be unique among objects of the same type.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">number</name>
	<applies-to>Chunk types</applies-to>
	<applies-to>Lists</applies-to>
	<applies-to>User-defined objects</applies-to>
	<syntax>the [[*]] of {object}</syntax>
	<example>get the [[*]] of elements in steve</example>
	<example>get the [[*]] of words in bill</example>
	<example>get the [[*]] of andy</example>
	<description>
		For chunk types, the [[*]] property determines the number of chunks in a range.
	</description>
	<description>
		For lists, the [[*]] property determines the number of items in a list.
	</description>
	<description>
		For objects, the [[*]] property determines the index of an object.
	</description>
	<see-also>[[fn:number]]</see-also>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">path</name>
	<applies-to>File system objects ([[dt:disk]]s, [[dt:folder]]s, [[dt:file]]s, and [[dt:fork]]s)</applies-to>
	<syntax>the [[*]] of {object}</syntax>
	<syntax-note>{Object} yields a [[dt:disk]], [[dt:folder]], [[dt:file]], or [[dt:fork]].</syntax-note>
	<example>get the [[*]] of the first file</example>
	<description>
		The [[*]] property determines or changes the path of a file system object.
		Changing the path effectively moves the file.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">modificationDate</name>
	<applies-to>File system objects ([[dt:disk]]s, [[dt:folder]]s, [[dt:file]]s, and [[dt:fork]]s)</applies-to>
	<syntax>the [[*]] of {object}</syntax>
	<syntax-note>{Object} yields a [[dt:disk]], [[dt:folder]], [[dt:file]], or [[dt:fork]].</syntax-note>
	<example>get the [[*]] of the first file</example>
	<description>
		The [[*]] property determines or changes the modification date of a file system object.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">count</name>
	<applies-to>Directory-type file system objects ([[dt:disk]]s and [[dt:folder]]s)</applies-to>
	<syntax>the [[*]] of {object}</syntax>
	<syntax-note>{Object} yields a [[dt:disk]] or [[dt:folder]].</syntax-note>
	<example>get the [[*]] of the first volume</example>
	<description>
		The [[*]] property determines the number of files and folders in a file system object.
	</description>
</property>

<property>
	<name dialects="xn1,oxn1,oxn11,oxn12">size</name>
	<applies-to>Stream-type file system objects ([[dt:file]]s and [[dt:fork]]s)</applies-to>
	<syntax>the [[*]] of {object}</syntax>
	<syntax-note>{Object} yields a [[dt:file]] or [[dt:fork]].</syntax-note>
	<example>get the [[*]] of the first file</example>
	<description>
		The [[*]] property determines the size in bytes of a file system object.
	</description>
</property>

<property>
	<name dialects="oxna12,hyp">dialingPort</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {string}</syntax>
	<syntax-note>{String} yields the name of a communications port.</syntax-note>
	<description>
		The [[*]] property determines which communications port is used
		by the [[cm:dial]] command to dial a phone number using a modem.
		A list of possible values for this property is returned by the
		[[fn:serialPorts]] function.
	</description>
	<note>
		In HyperTalk, this property existed but was undocumented.
	</note>
	<security>
		To use the [[*]] property, OpenXION's security settings must allow the [[TELEPHONY]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:dial]], [[fn:serialPorts]]</see-also>
</property>

<property>
	<name dialects="oxna12,hyp">dialingTime</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {duration}</syntax>
	<syntax-note>{Duration} yields a [[dt:number]].</syntax-note>
	<description>
		The [[*]] property determines the amount of time the [[cm:dial]]
		command waits before closing the communications port after issuing
		the modem command to dial a phone number. The amount of time
		is specified in ticks, or sixtieths of a second. The default
		value is 180 ticks, or 3 seconds.
	</description>
	<see-also>[[cm:dial]]</see-also>
</property>

<property>
	<name dialects="oxna12,hyp">dialingVolume</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {volume}</syntax>
	<syntax-note>{Volume} yields a [[dt:number]] between 0 and 7, inclusive.</syntax-note>
	<description>
		The [[*]] property determines the volume of the dial tones
		produced by the [[cm:dial]] command. The default value is 7.
	</description>
	<note>
		In HyperTalk, as in old versions of Mac OS Classic, the volume was
		restricted to an [[dt:integer]] between 0 and 7. OpenXION uses the
		same range for compatibility, but allows any [[dt:number]] in order
		to give finer control over volume.
	</note>
	<see-also>[[cm:dial]], [[pr:toneVolume]]</see-also>
</property>

<property>
	<name dialects="oxna12,hyp">soundChannel</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {channel}</syntax>
	<syntax-note>{Channel} yields an [[dt:integer]] between 1 and 8, inclusive.</syntax-note>
	<description>
		The [[*]] property determines which channel music produced by the [[cm:play]] command
		is played on. Only one sequence can be played on a single channel at any one time,
		but multiple sequences can be played simultaneously on different channels. Both HyperTalk
		and OpenXION support 8 channels.
	</description>
	<see-also>[[cm:play]], [[fn:sound]], [[pr:toneChannel]]</see-also>
</property>

<property>
	<name dialects="oxna12">toneChannel</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {channel}</syntax>
	<syntax-note>{Channel} yields an [[dt:integer]] between 1 and 8, inclusive.</syntax-note>
	<description>
		The [[*]] property determines which channel tones produced by the [[cm:tone]] command
		is played on. Only one tone can be played on a single channel at any one time,
		but multiple tones can be played simultaneously on different channels. OpenXION
		supports 8 channels.
	</description>
	<note>
		Music played with the [[cm:play]] command and tones produced by
		the [[cm:tone]] command are always played on separate channels,
		despite the similarities between the [[pr:soundChannel]] and
		[[pr:toneChannel]] properties.
	</note>
	<see-also>[[cm:tone]], [[fn:tone]], [[pr:soundChannel]]</see-also>
</property>

<property>
	<name dialects="oxna12">toneVolume</name>
	<applies-to>Global environment</applies-to>
	<syntax>set the [[*]] to {volume}</syntax>
	<syntax-note>{Volume} yields a [[dt:number]] between 0 and 7, inclusive.</syntax-note>
	<description>
		The [[*]] property determines the volume of the tones
		produced by the [[cm:tone]] command. The default value is 7.
	</description>
	<note>
		In HyperTalk, as in old versions of Mac OS Classic, the volume was
		restricted to an [[dt:integer]] between 0 and 7. OpenXION uses the
		same range for compatibility, but allows any [[dt:number]] in order
		to give finer control over volume.
	</note>
	<see-also>[[cm:tone]], [[pr:dialingVolume]]</see-also>
</property>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">add</name>
	<syntax>add {number} to {container}</syntax>
	<syntax-note>
		{Number} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
		{Container} yields a container containing an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
	</syntax-note>
	<example>add 3 to it</example>
	<example>add amount to total</example>
	<description>
		The [[*]] command adds the value of {number} to the value of {container}
		and leaves the result in {container}. The value in the container must
		be an [[dt:integer]], a [[dt:number]], or a [[dt:complex]] and is replaced
		with the new value.
	</description>
	<script>
		The following example sums a line-delimited list of numbers and prints
		the result.
		\\\\[[on printSum numberList\\
		  put 0 into total\\
		  repeat with count = 1 to the number of lines¬\\
		    in numberList\\
		    add line count of numberList to total\\
		  end repeat\\
		  put total\\
		end printSum]]
	</script>
	<see-also>
		[[cm:subtract]], [[cm:multiply]], [[cm:divide]], [[cm:modulo]],
		[[op:+]], [[fn:sum]]
	</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">answer</name>
	<syntax>answer {question}</syntax>
	<syntax>answer {question} with {reply}</syntax>
	<syntax>answer {question} with {reply} or {reply}</syntax>
	<syntax>answer {question} with {reply} or {reply} or {reply}</syntax>
	<syntax>answer {question} at {point}</syntax>
	<syntax>answer {question} with {reply} at {point}</syntax>
	<syntax>answer {question} with {reply} or {reply} at {point}</syntax>
	<syntax>answer {question} with {reply} or {reply} or {reply} at {point}</syntax>
	<syntax>answer list {promptText} with {list}</syntax>
	<syntax>answer list {promptText} with {list} at {point}</syntax>
	<syntax>answer file {promptText}</syntax>
	<syntax>answer file {promptText} of type {fileType}</syntax>
	<syntax>answer file {promptText} of type {fileType} or {fileType}</syntax>
	<syntax>answer file {promptText} of type {fileType} or {fileType} or {fileType}</syntax>
	<syntax>answer file {promptText} at {point}</syntax>
	<syntax>answer file {promptText} of type {fileType} at {point}</syntax>
	<syntax>answer file {promptText} of type {fileType} or {fileType} at {point}</syntax>
	<syntax>answer file {promptText} of type {fileType} or {fileType} or {fileType} at {point}</syntax>
	<syntax>answer folder {promptText}</syntax>
	<syntax>answer folder {promptText} at {point}</syntax>
	<syntax>answer directory {promptText}</syntax>
	<syntax>answer directory {promptText} at {point}</syntax>
	<syntax>answer disk {promptText}</syntax>
	<syntax>answer disk {promptText} at {point}</syntax>
	<syntax>answer volume {promptText}</syntax>
	<syntax>answer volume {promptText} at {point}</syntax>
	<syntax-note>
		{Question}, {reply}, {promptText}, and {fileType} yield [[dt:string]]s.
		{List} yields a [[dt:list]]. {Point} yields a [[dt:point]].
	</syntax-note>
	<example>answer "Which is the way the world ends?" with "Bang" or "Whimper"</example>
	<example>answer file "Pick a file:"</example>
	<description>
		The [[answer]] command displays a prompt to the user with up to three possible responses.
		The last response appears as the default response to the prompt. If no possible responses
		are specified, a single possible response will be presented with the text "OK." The script
		waits until one of the possible responses is chosen. The chosen response is placed in the
		local variable [[it]].
	</description>
	<description>
		The [[answer list]] command displays a prompt to the user with a list of any number of
		possible responses. The script waits until one of the possible responses is selected.
		The chosen response is placed in the local variable [[it]] and the [[fn:result]] is set
		to [["OK"]]. If the prompt is dismissed without choosing a response, [[cn:empty]] is
		placed in [[it]] and the [[fn:result]] is set to [["Cancel"]].
	</description>
	<description>
		The [[answer file]] command displays a prompt to the user asking to select a file.
		The script waits until a file is selected. The path of the selected file is placed
		in the local variable [[it]] and the [[fn:result]] is set to [["OK"]]. If the
		prompt is dismissed without selecting a file, [[cn:empty]] is placed in [[it]] and
		the [[fn:result]] is set to [["Cancel"]].
	</description>
	<description>
		The [[answer folder]] or [[answer directory]] command displays a prompt to the user
		asking to select a folder or directory. The script waits until a folder is selected.
		The path of the selected folder is placed in the local variable [[it]] and the
		[[fn:result]] is set to [["OK"]]. If the prompt is dismissed without selecting a folder,
		[[cn:empty]] is placed in [[it]] and the [[fn:result]] is set to [["Cancel"]].
	</description>
	<description>
		The [[answer disk]] or [[answer volume]] command displays a prompt to the user
		asking to select a disk or volume. The script waits until a volume is selected.
		The path of the selected volume is placed in the local variable [[it]] and the
		[[fn:result]] is set to [["OK"]]. If the prompt is dismissed without selecting a volume,
		[[cn:empty]] is placed in [[it]] and the [[fn:result]] is set to [["Cancel"]].
	</description>
	<description>
		The exact presentation of the prompts is left to the implementation. OpenXION presents
		a stylized text-based prompt. A GUI-based system, like HyperCard, will present an
		appropriate dialog box. The [[at]] parameter gives a preferred location for this dialog box.
	</description>
	<script>
		[[on chooseColor\\
		  answer "Which color do you prefer?" with "Red" or¬\\
		  "Blue" or "Yellow"\\
		  if it is "Red" then answer "You picked red."\\
		  else if it is "Blue" then answer "You picked blue."\\
		  else if it is "Yellow" then answer "You picked yellow."\\
		end chooseColor]]
	</script>
	<note>
		There is no way for a script to respond to a prompt by itself, so do not use [[*]]
		in a script intended to run unattended.
	</note>
	<note>
		HyperTalk does not support the [[answer list]], [[answer directory]], [[answer disk]],
		or [[answer volume]] forms, or the [[at]] parameter. However, the Power Tools stack
		has the [[ShowList]] XFCN that inspired the [[answer list]] command and HyperTalk itself
		has an [[answer program]] form that OpenXION does not.
	</note>
	<see-also>[[cm:ask]]</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">ask</name>
	<syntax>ask {question}</syntax>
	<syntax>ask {question} with {defaultAnswer}</syntax>
	<syntax>ask {question} at {point}</syntax>
	<syntax>ask {question} with {defaultAnswer} at {point}</syntax>
	<syntax>ask password {question}</syntax>
	<syntax>ask password {question} with {defaultAnswer}</syntax>
	<syntax>ask password {question} at {point}</syntax>
	<syntax>ask password {question} with {defaultAnswer} at {point}</syntax>
	<syntax>ask password clear {question}</syntax>
	<syntax>ask password clear {question} with {defaultAnswer}</syntax>
	<syntax>ask password clear {question} at {point}</syntax>
	<syntax>ask password clear {question} with {defaultAnswer} at {point}</syntax>
	<syntax>ask file {promptText}</syntax>
	<syntax>ask file {promptText} with {fileName}</syntax>
	<syntax>ask file {promptText} at {point}</syntax>
	<syntax>ask file {promptText} with {fileName} at {point}</syntax>
	<syntax>ask folder {promptText}</syntax>
	<syntax>ask folder {promptText} with {fileName}</syntax>
	<syntax>ask folder {promptText} at {point}</syntax>
	<syntax>ask folder {promptText} with {fileName} at {point}</syntax>
	<syntax>ask directory {promptText}</syntax>
	<syntax>ask directory {promptText} with {fileName}</syntax>
	<syntax>ask directory {promptText} at {point}</syntax>
	<syntax>ask directory {promptText} with {fileName} at {point}</syntax>
	<syntax-note>
		{Question}, {defaultAnswer}, {promptText}, and {fileName} yield [[dt:string]]s.
		{Point} yields a [[dt:point]].
	</syntax-note>
	<example>ask "Who needs this kind of grief?" with "Not me."</example>
	<example>ask password "Please enter your password:"</example>
	<example>ask file "Save this file as:" with "Untitled-1"</example>
	<description>
		The [[ask]] command displays a prompt to the user and allows the user to type
		a response. The optional {defaultAnswer} parameter specifies a response that
		initially appears. The prompt appears with "OK" and "Cancel" choices as well.
		The script waits until a response is typed and one of the choices is selected.
		If the "OK" choice is selected, the typed text is placed in the local variable
		[[it]] and the [[fn:result]] is set to [["OK"]]. If the "Cancel" choice is
		selected, [[cn:empty]] is placed in [[it]] and the [[fn:result]] is set to
		[["Cancel"]].
	</description>
	<description>
		The [[ask password]] command hides the response from the user as it is being typed and
		encrypts the response using the Atkinson hash (see the [[fn:hash]] function).
		The encrypted response can be stored somewhere to be compared to a later
		response to [[ask password]] if, for example, you want the user to be able
		to protect data they enter.
	</description>
	<description>
		The [[ask password clear]] command hides the response from the user as it is being typed,
		but does not encrypt the response in any way.
	</description>
	<description>
		The [[ask file]] command displays a prompt to the user asking for the location and
		name of a new file. The optional {fileName} parameter specifies a file name that
		initially appears. The script waits until a file name is entered. The file path is placed
		in the local variable [[it]] and the [[fn:result]] is set to [["OK"]]. If the
		prompt is dismissed without entering a file name, [[cn:empty]] is placed in [[it]] and
		the [[fn:result]] is set to [["Cancel"]].
	</description>
	<description>
		The [[ask folder]] or [[ask directory]] command displays a prompt to the user asking for
		the location and name of a new folder or directory. The optional {fileName} parameter
		specifies a folder name that initially appears. The script waits until a folder name is
		entered. The directory path is placed in the local variable [[it]] and the [[fn:result]]
		is set to [["OK"]]. If the prompt is dismissed without entering a folder name, [[cn:empty]]
		is placed in [[it]] and the [[fn:result]] is set to [["Cancel"]].
	</description>
	<description>
		The exact presentation of the prompts is left to the implementation. OpenXION presents
		a stylized text-based prompt. A GUI-based system, like HyperCard, will present an
		appropriate dialog box. The [[at]] parameter gives a preferred location for this dialog box.
	</description>
	<note>
		The [[ask file]], [[ask folder]], and [[ask directory]] commands do not actually create
		the selected file, folder, or directory. The script must create the file, folder, or
		directory itself.
	</note>
	<note>
		There is no way for a script to respond to a prompt by itself, so do not use [[*]]
		in a script intended to run unattended.
	</note>
	<note>
		HyperTalk does not support the [[ask folder]] or [[ask directory]] forms,
		or the [[at]] parameter.
	</note>
	<see-also>[[cm:answer]], [[fn:hash]]</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">create</name>
	<syntax>create {object}</syntax>
	<syntax>create new {objectType}</syntax>
	<syntax>create a new {objectType}</syntax>
	<syntax-note>
		{Object} yields the descriptor of the object to be created.
		{ObjectType} is the name of an object type.
	</syntax-note>
	<example>create folder "My Files"</example>
	<example>create file "MyTemp"</example>
	<description>
		The [[*]] command creates an object that did not previously exist.
		The object is created to match the given descriptor if possible.
		The newly-created object is placed in the local variable [[it]].
	</description>
	<note>
		HyperTalk only supports the creation of two kinds of objects,
		[[menu]]s and [[stack]]s. HyperTalk does not support the [[new]]
		or [[a new]] forms, and does not put the newly-created
		object into [[it]].
	</note>
	<see-also>[[cm:delete]]</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">delete</name>
	<syntax>delete {object}</syntax>
	<syntax-note>{Object} yields the descriptor of the object to be deleted.</syntax-note>
	<example>delete line 1 of steve</example>
	<example>delete char 1 to 5 of line 4 of bill</example>
	<example>delete file "MyTemp"</example>
	<description>
		The [[*]] command deletes an object or removes a chunk from a container.
	</description>
	<script>
		The following example finds and deletes a name from a line-delimited list of names:
		\\\\[[on zapaName\\
		  put "Maller\nCalhoun\nWinkler" into list\\
		  ask "Delete which name from the list?" with empty\\
		  repeat with count = the number of lines in list¬\\
		  down to 1\\
		    if it is line count of list then ¬\\
		    delete line count of list\\
		  end repeat\\
		  put list\\
		end zapaName]]
	</script>
	<note>
		Using the [[*]] command to delete a chunk is not the same as using [[put empty into]]
		with the same chunk. For example, if you delete a line with a statement like:
	</note>
	<note>
		[[delete line 4 of myText]]
	</note>
	<note>
		you delete the line break as well as the text; what was previously the fifth line
		becomes the fourth. The following statement leaves the line break in line 4:
	</note>
	<note>
		[[put empty into line 4 of myText]]
	</note>
	<note>
		HyperTalk only supports the deletion of chunks, [[menu]]s,
		[[menuItem]]s, and [[part]]s ([[button]]s and [[field]]s).
	</note>
	<see-also>[[cm:create]], [[cm:put]]</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">divide</name>
	<syntax>divide {container} by {number}</syntax>
	<syntax>divide {container} by {number} rounding {roundingMethod}</syntax>
	<syntax-note>
		{Number} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
		{Container} yields a container containing an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
		{RoundingMethod} is [[up]], [[down]], or [[to]], [[toward]], or [[towards]]
		[[zero]], [[infinity]], [[nearest]], [[even]], [[ceiling]], or [[floor]].
	</syntax-note>
	<example>divide total by 3</example>
	<example>divide line 3 of steve by 10</example>
	<description>
		The [[*]] command divides the value of {container} by the value of {number}
		and leaves the result in {container}. The value in the container must
		be an [[dt:integer]], a [[dt:number]], or a [[dt:complex]] and is replaced
		with the new value.
	</description>
	<description>
		If a {roundingMethod} is given, the result is rounded to an integer.
		The following table shows the correspondences among the various
		{roundingMethod}s, rounding functions, and division operators:\\\\
		::TABLE
		{{[[rounding]] parameter}} :: {{function}} :: {{operator}}             :: {{[[java.math.RoundingMode]]}}
		........................................................................................................
		[[to ceiling]]             :: [[fn:ceil]]  ::                          :: [[CEILING]]
		........................................................................................................
		[[to floor]]               :: [[fn:floor]] :: [[op:div]] / [[op:mod]]  :: [[FLOOR]]
		........................................................................................................
		[[up]] / [[to infinity]]   :: [[fn:aug]]   ::                          :: [[UP]]
		........................................................................................................
		[[down]] / [[to zero]]     :: [[fn:trunc]] :: [[op:quot]] / [[op:rem]] :: [[DOWN]]
		........................................................................................................
		[[to nearest]]             :: [[fn:round]] ::                          :: [[HALF_UP]]
		........................................................................................................
		[[to even]]                :: [[fn:rint]]  ::                          :: [[HALF_EVEN]]
		ELBAT::\\
		See the [[fn:ceil]], [[fn:floor]], [[fn:aug]], [[fn:trunc]], [[fn:round]], and [[fn:rint]] functions for
		descriptions of how these rounding methods work.
	</description>
	<script>
		The following example prints the percentage represented by a fraction
		of two numbers passed in as parameters:
		\\\\[[on percent steve,bill\\
		  divide steve by bill\\
		  put trunc(steve * 100) &amp; "%"\\
		end percent]]
	</script>
	<note>
		HyperTalk does not support the [[rounding]] keyword.
	</note>
	<see-also>
		[[cm:add]], [[cm:subtract]], [[cm:multiply]], [[cm:modulo]],
		[[op:/]], [[op:div]], [[op:quot]]
	</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">get</name>
	<syntax>get {expression}</syntax>
	<syntax-note>{Expression} yields any value.</syntax-note>
	<example>get the short name of file 1</example>
	<example>get 2+3</example>
	<example>get the date</example>
	<description>
		The [[*]] command puts the value of any expression into the local variable [[it]].
		That is, [[get ]]{expression} is the same as [[put ]]{expression}[[ into it]].
	</description>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12">let</name>
	<syntax>let {container} = {expression}</syntax>
	<description>
		The [[*]] command copies the given value into {container}.
	</description>
	<note>
		If the specified {container} is a variable name but the variable has not been
		created yet, a new local variable is created with that name.
	</note>
	<see-also>[[cm:put]]</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12">modulo</name>
	<syntax>modulo {container} by {number}</syntax>
	<syntax>modulo {container} by {number} rounding {roundingMethod}</syntax>
	<syntax-note>
		{Number} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
		{Container} yields a container containing an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
		{RoundingMethod} is [[up]], [[down]], or [[to]], [[toward]], or [[towards]]
		[[zero]], [[infinity]], [[nearest]], [[even]], [[ceiling]], or [[floor]].
	</syntax-note>
	<example>modulo steve by 17</example>
	<example>modulo line 13 of bill by 100</example>
	<description>
		The [[*]] command divides the value of {container} by the value of {number}
		and leaves the remainder of the division in {container}. The value in the
		container must be an [[dt:integer]], a [[dt:number]], or a [[dt:complex]] and
		is replaced with the new value.
	</description>
	<note>
		The remainder is calculated as follows:
	</note>
	<note>
		{remainder} = {container} - {number} * {roundingFunction}( {container} / {number} )
	</note>
	<note>
		where {roundingFunction} is the function listed in the table below.
	</note>
	<note>
		If no {roundingMethod} is specified, [[to floor]] is assumed.
	</note>
	<note>
		The following table shows the correspondences among the various
		{roundingMethod}s, rounding functions, and division operators:\\\\
		::TABLE
		{{[[rounding]] parameter}} :: {{function}} :: {{operator}}             :: {{[[java.math.RoundingMode]]}}
		........................................................................................................
		[[to ceiling]]             :: [[fn:ceil]]  ::                          :: [[CEILING]]
		........................................................................................................
		[[to floor]]               :: [[fn:floor]] :: [[op:div]] / [[op:mod]]  :: [[FLOOR]]
		........................................................................................................
		[[up]] / [[to infinity]]   :: [[fn:aug]]   ::                          :: [[UP]]
		........................................................................................................
		[[down]] / [[to zero]]     :: [[fn:trunc]] :: [[op:quot]] / [[op:rem]] :: [[DOWN]]
		........................................................................................................
		[[to nearest]]             :: [[fn:round]] ::                          :: [[HALF_UP]]
		........................................................................................................
		[[to even]]                :: [[fn:rint]]  ::                          :: [[HALF_EVEN]]
		ELBAT::\\
		See the [[fn:ceil]], [[fn:floor]], [[fn:aug]], [[fn:trunc]], [[fn:round]], and [[fn:rint]] functions for
		descriptions of how these rounding methods work.
	</note>
	<see-also>
		[[cm:add]], [[cm:subtract]], [[cm:multiply]], [[cm:divide]],
		[[op:%]], [[op:mod]], [[op:rem]]
	</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">multiply</name>
	<syntax>multiply {container} by {number}</syntax>
	<syntax-note>
		{Number} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
		{Container} yields a container containing an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
	</syntax-note>
	<example>multiply Subtotal by Tax</example>
	<example>multiply steve by bill</example>
	<example>multiply line 3 of andy by 25</example>
	<description>
		The [[*]] command multiplies the value of {container} by the value of {number}
		and leaves the result in {container}. The value in the container must
		be an [[dt:integer]], a [[dt:number]], or a [[dt:complex]] and is replaced
		with the new value.
	</description>
	<script>
		The following example adds 6 percent to each item in a list:
		\\\\[[on taxMe\\
		  put "12.45,15.00,150.00,76.95,10.00,14.95,19.87" into taxables\\
		  repeat with count = 1 to the number of items in taxables\\
		    multiply item count of taxables by 1.06\\
		  end repeat\\
		  put taxables\\
		end taxMe]]
	</script>
	<see-also>
		[[cm:add]], [[cm:subtract]], [[cm:divide]], [[cm:modulo]],
		[[op:*]], [[fn:product]]
	</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">put</name>
	<syntax>put {expression}</syntax>
	<syntax>put {expression} into {container}</syntax>
	<syntax>put {expression} before {container}</syntax>
	<syntax>put {expression} after {container}</syntax>
	<syntax>put {expression} into {container} with {propertyName} {propertyValue}</syntax>
	<syntax>put {expression} before {container} with {propertyName} {propertyValue}</syntax>
	<syntax>put {expression} after {container} with {propertyName} {propertyValue}</syntax>
	<syntax-note>{PropertyName} is the name of a property.</syntax-note>
	<example>put "Hello" into steve</example>
	<example>put empty into it</example>
	<example>put it</example>
	<example>put "Tom" into first word of theName</example>
	<example>put "." after first character of last word of bill</example>
	<example>put steve + bill into andy</example>
	<example>put the date into myDate</example>
	<description>
		The [[*]] command without a {container} specified presents the given value
		to the user in an implementation-defined way. OpenXION prints the given value
		to standard output. HyperCard puts the given value into the message box.
	</description>
	<description>
		The [[*]] command with a {container} copies the given value into {container}.
		The [[kw:before]] and [[kw:after]] prepositions specify that the given value
		should be inserted before or after the existing contents, respectively, instead
		of completely replacing the existing contents. The [[with]] keyword allows
		you to set a property of the new contents.
	</description>
	<note>
		If the specified {container} is a variable name but the variable has not been
		created yet, a new local variable is created with that name.
	</note>
	<note>
		The only property HyperTalk supports for the [[with]] keyword is [[menuMessage]].
	</note>
	<see-also>[[cm:let]], [[kw:into]], [[kw:before]], [[kw:after]]</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">set</name>
	<syntax>set {propertyName} to {propertyValue}</syntax>
	<syntax>set {propertyName} of {object} to {propertyValue}</syntax>
	<syntax>set {propertyName} in {object} to {propertyValue}</syntax>
	<syntax>set the {propertyName} to {propertyValue}</syntax>
	<syntax>set the {propertyName} of {object} to {propertyValue}</syntax>
	<syntax>set the {propertyName} in {object} to {propertyValue}</syntax>
	<syntax-note>{PropertyName} is the name of a property.</syntax-note>
	<example>set the name of file "Untitled" to "MyFile"</example>
	<example>set itemDelimiter to ":"</example>
	<description>
		The [[*]] command changes the specified property. If the object to which
		the property belongs is not specified, the property must be a global property.
	</description>
	<note>
		Some properties cannot be changed with the [[*]] command. These exceptions
		are noted in the descriptions for the properties themselves.
	</note>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">subtract</name>
	<syntax>subtract {number} from {container}</syntax>
	<syntax-note>
		{Number} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
		{Container} yields a container containing an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].
	</syntax-note>
	<example>subtract 2 from it</example>
	<example>subtract steve from bill</example>
	<description>
		The [[*]] command subtracts the value of {number} from the value of {container}
		and leaves the result in {container}. The value in the container must
		be an [[dt:integer]], a [[dt:number]], or a [[dt:complex]] and is replaced
		with the new value.
	</description>
	<see-also>
		[[cm:add]], [[cm:multiply]], [[cm:divide]], [[cm:modulo]],
		[[op:-]]
	</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">beep</name>
	<syntax>beep</syntax>
	<syntax>beep {number}</syntax>
	<syntax>beep {number} times</syntax>
	<syntax-note>{Number} yields a non-negative [[dt:integer]].</syntax-note>
	<example>beep 5</example>
	<example>beep twice</example>
	<description>
		The [[*]] command causes the computer to beep the specified number of times.
		If no number is given, the computer beeps once.
	</description>
	<note>
		HyperTalk does not support the [[times]] keyword. It can just be left off.
	</note>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">close</name>
	<syntax>close {object}</syntax>
	<syntax>close {applicationPath}</syntax>
	<syntax>close {documentPath} with {applicationPath}</syntax>
	<syntax>close {documentPath} in {applicationPath}</syntax>
	<syntax-note>
		{Object} yields an object with an appropriate I/O manager.
		{DocumentPath} and {applicationPath} yield file paths to a document file
		and an application file, respectively.
	</syntax-note>
	<description>
		The [[*]] command, when given an object with an appropriate I/O manager,
		closes an object previously opened with the [[cm:open]] command.
	</description>
	<description>
		If the parameter to the [[*]] command does not have an appropriate I/O manager
		or is not an object, or if the [[with]] or [[in]] parameter is given, the
		[[*]] command closes an open application or document. OpenXION currently only
		supports this on Mac OS X.
	</description>
	<security>
		To close an open application or document, OpenXION's security settings must allow the [[FILE_LAUNCH]] security key.
		To close an object with an I/O manager, any security keys required are determined by the I/O manager; see the documentation for the I/O manager itself.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]]</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">convert</name>
	<syntax>convert {container} to {format}</syntax>
	<syntax>convert {container} to {format} and {format}</syntax>
	<syntax>convert {container} from {format} to {format}</syntax>
	<syntax>convert {container} from {format} to {format} and {format}</syntax>
	<syntax>convert {container} from {format} and {format} to {format}</syntax>
	<syntax>convert {container} from {format} and {format} to {format} and {format}</syntax>
	<syntax-note>
		{Format} is one of the following: [[date]], [[short date]], [[abbreviated date]],
		[[long date]], [[English date]], [[short time]], [[abbreviated time]], [[long time]],
		[[English time]], [[seconds]], or [[dateItems]].
	</syntax-note>
	<example>convert line 1 of steve from date to dateItems</example>
	<example>convert bill from date and time to dateItems</example>
	<example>convert andy to seconds</example>
	<example>convert first line of steve to long date and short time</example>
	<description>
		The [[*]] command gets a date or time and converts it from a particular format,
		if specified, to a particular format. This command works with either the local
		date format or the U.S. date format.
	</description>
	<description>
		If the first parameter to the [[*]] command is a container, the converted
		date or time is placed in that container. If the first parameter is not a
		container, the converted date or time is placed in the local variable [[it]].
	</description>
	<description>
		A script that needs to work with dates and times should convert them to
		the [[seconds]] or [[dateItems]] format before working on them.
		This avoids problems that may occur when running the script in a
		different locale. The [[seconds]] and [[dateItems]] formats are the
		only ones guaranteed to be recognized in any locale.
	</description>
	<script>
		The following example prints tomorrow's date in the short format
		regardless of the current locale:
		\\\\[[on printTomorrow\\
		  get the date\\
		  convert it to dateItems\\
		  add 1 to item 3 of it\\
		  convert it to short date\\
		  put it\\
		end printTomorrow]]
	</script>
	<see-also>[[dt:date]], [[fn:date]], [[fn:time]], [[fn:seconds]], [[fn:dateItems]]</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">open</name>
	<syntax>open {object}</syntax>
	<syntax>open {object} as {method}</syntax>
	<syntax>open {applicationPath}</syntax>
	<syntax>open {documentPath} with {applicationPath}</syntax>
	<syntax>open {documentPath} in {applicationPath}</syntax>
	<syntax-note>
		{Object} yields an object with an appropriate I/O manager.
		{Method} yields the name of an I/O method.
		{DocumentPath} and {applicationPath} yield file paths to a document file
		and an application file, respectively.
	</syntax-note>
	<description>
		The [[*]] command, when given an object with an appropriate I/O manager,
		opens an object for reading or writing. If the object is a [[dt:file]]
		and the file does not exist, the interpreter creates it.
	</description>
	<description>
		If the parameter to the [[*]] command does not have an appropriate I/O manager
		or is not an object, or if the [[with]] or [[in]] parameter is given, the
		[[*]] command launches an application or document. The [[*]] command without
		a [[with]] or [[in]] parameter first looks for applications, then documents.
		The [[*]] command with a [[with]] or [[in]] parameter opens the file {documentPath}
		with the application {applicationPath} regardless of what application would
		normally open the file. In OpenXION, the locations searched for applications
		and documents are determined by the [[pr:applicationPaths]] and [[pr:documentPaths]]
		properties, respectively. In HyperTalk, the locations searched for applications
		and documents are determined by the global variables [[Applications]] and
		[[Documents]].
	</description>
	<script>
		The following example opens a file, reads a line of data from it, then closes the file:
		\\\\[[on printALine\\
		  open file "MyFile"\\
		  read from file "MyFile"\\
		  put it\\
		  close file "MyFile"\\
		end printALine]]
	</script>
	<script>
		The following example opens a URL with the user's default web browser:
		\\\\[[on myLink\\
		  open url "http://www.xkcd.com"\\
		end myLink]]
	</script>
	<script>
		The following example opens a URL and reads its contents:
		\\\\[[on readURL\\
		  open URL "http://www.purple.com/" as "text"\\
		  read from URL "http://www.purple.com/" until eof\\
		  put it\\
		  close URL "http://www.purple.com/"\\
		end readURL]]
	</script>
	<script>
		The following example queries the user for a document and application before
		executing the [[*]] command:
		\\\\[[on openSomething\\
		  answer file "Select a document:"\\
		  if it is not empty then\\
		    put it into doc\\
		    answer file "Select an application:"\\
		    if it is not empty then open doc with it\\
		  end if\\
		end openSomething]]
	</script>
	<note>
		If the [[open {applicationPath}]] or [[open {documentPath} with {applicationPath}]]
		form is used and the specified application or document cannot be found, the interpreter
		must present a prompt to the user asking them to select the appropriate file.
		To avoid this prompt, you can use the [[fn:appPath]], [[fn:appFile]], [[fn:docPath]],
		[[fn:docFile]], [[fn:appOrDocPath]], or [[fn:appOrDocFile]] functions. If the function
		returns [[cn:empty]], then the application or document cannot be found.
	</note>
	<note>
		HyperTalk does not support the [[as]] parameter or reading from or writing to URLs.
	</note>
	<security>
		To launch applications and documents, OpenXION's security settings must allow the [[FILE_LAUNCH]] security key.
		To open an object with an I/O manager, any security keys required are determined by the I/O manager; see the documentation for the I/O manager itself.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>
		[[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]],
		[[mg:file]], [[mg:URL]], [[mt:text]], [[mt:binary]]
	</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">read</name>
	<syntax>read from {object}</syntax>
	<syntax>read from {object} at {offset}</syntax>
	<syntax>read from {object} for {length}</syntax>
	<syntax>read from {object} at {offset} for {length}</syntax>
	<syntax>read from {object} until {data}</syntax>
	<syntax>read from {object} at {offset} until {data}</syntax>
	<syntax>read from {object} for {length} until {data}</syntax>
	<syntax>read from {object} at {offset} for {length} until {data}</syntax>
	<syntax-note>
		{Object} yields an object with an appropriate I/O manager.
		{Offset} yields an [[dt:integer]] identifying the position where reading starts.
		{Length} yields a non-negative [[dt:integer]] identifying the length of data to be read.
		{Data} yields the last data to be read.
	</syntax-note>
	<example>read from file "MyData" at 4 for 20</example>
	<example>read from file "MyData" until tab</example>
	<example>read from file "MyData" at -20 until eof</example>
	<description>
		The [[*]] command reads from the specified object, which must be opened
		already with the [[cm:open]] command, into the local variable [[it]].
		Reading starts at the specified offset or, if no offset is specified,
		from where the last [[cm:read]] or [[cm:write]] left off. A negative
		offset indicates an offset from the end of the file, while a positive
		offset indicates an offset from the beginning of the file. Reading
		continues until either the specified data is read, or the specified
		length of data is read, whichever occurs first. If neither is specified,
		reading continues until the end of a line (if the [[mt:text]] I/O method
		is used) or the end of file (if the [[mt:binary]] I/O method is used).
	</description>
	<note>
		HyperTalk uses only the first character of {data}. OpenXION uses the whole {data}.
	</note>
	<note>
		HyperTalk converts null characters to spaces when reading. OpenXION refuses
		to do such an unspeakable thing.
	</note>
	<see-also>
		[[cm:open]], [[cm:write]], [[cm:truncate]], [[cm:close]],
		[[mg:file]], [[mg:URL]], [[mt:text]], [[mt:binary]]
	</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">sort</name>
	<syntax>sort {container}</syntax>
	<syntax>sort {container} by {expression}</syntax>
	<syntax>sort {container} {sortType}</syntax>
	<syntax>sort {container} {sortType} by {expression}</syntax>
	<syntax>sort {container} {direction}</syntax>
	<syntax>sort {container} {direction} by {expression}</syntax>
	<syntax>sort {container} {direction} {sortType}</syntax>
	<syntax>sort {container} {direction} {sortType} by {expression}</syntax>
	<syntax-note>
		{Direction} is [[ascending]] or [[descending]]. The default is [[ascending]].
		{SortType} is [[text]], [[numeric]], [[dateTime]], or [[international]]. The default is [[text]].
		{Expression} is any expression.
	</syntax-note>
	<example>sort lines of steve by last word of each</example>
	<example>sort items of bill descending numeric by word 2 of each</example>
	<example>sort lines of steve ascending</example>
	<example>sort items of bill dateTime</example>
	<example>sort andy</example>
	<example>sort it numeric</example>
	<description>
		The [[*]] command will sort chunks of a [[dt:string]], elements of a [[dt:list]],
		bytes of a [[dt:binary]], or child objects of an object that supports sorting.
	</description>
	<description>
		The [[ascending]] direction sorts in normal, ascending order, while the
		[[descending]] direction sorts in reverse, descending order.
	</description>
	<description>
		The [[text]] sort type sorts by the Unicode code points of the characters in
		a string. The [[international]] sort type sorts using the current locale's
		collation rules. The [[numeric]] sort type sorts strings that look like numbers
		as numbers rather than strings. The [[dateTime]] sort type sorts strings that
		look like dates as dates rather than strings.
	</description>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12">truncate</name>
	<syntax>truncate {object}</syntax>
	<syntax>truncate {object} at {offset}</syntax>
	<syntax-note>
		{Object} yields an object with an appropriate I/O manager.
		{Offset} yields an [[dt:integer]].
	</syntax-note>
	<description>
		The [[*]] command truncates the specified object, which must be opened
		already with the [[cm:open]] command. In other words, any data after
		the specified offset is deleted. If no offset is specified, the object
		will be truncated where the last [[cm:read]] or [[cm:write]] left off.
	</description>
	<note>
		If you [[cm:open]] a file that already exists and [[cm:write]] some
		data to it, the file can still contain old data that did not get overwritten.
		The [[cm:truncate]] command allows you to remove the contents of a file
		before writing to it.
	</note>
	<see-also>
		[[cm:open]], [[cm:read]], [[cm:write]], [[cm:close]],
		[[mg:file]], [[mg:URL]], [[mt:text]], [[mt:binary]]
	</see-also>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">wait</name>
	<syntax>wait until {condition}</syntax>
	<syntax>wait while {condition}</syntax>
	<syntax>wait for {number}</syntax>
	<syntax>wait for {number} {unit}</syntax>
	<syntax>wait {number}</syntax>
	<syntax>wait {number} {unit}</syntax>
	<syntax-note>
		{Condition} is an expression that always yields [[cn:true]] or [[cn:false]].
		{Number} yields an [[dt:integer]] or a [[dt:number]].
		{Unit} is one of the following: [[nanoseconds]], [[microseconds]], [[milliseconds]],
		[[seconds]], [[ticks]], [[minutes]], [[hours]], [[nanosecond]], [[microsecond]],
		[[millisecond]], [[second]], [[tick]], [[minute]], or [[hour]].
	</syntax-note>
	<description>
		The [[*]] command causes the interpreter to pause before executing the rest of the
		script. The [[wait until]] form will pause until the specified condition becomes
		[[cn:true]]. The [[wait while]] form will pause until the specified condition
		becomes [[cn:false]]. The [[wait for]] form will pause for the specified length
		of time.
	</description>
	<description>
		If no {unit} is specified, the [[*]] command assumes [[ticks]], defined as sixtieths
		of a second.
	</description>
	<note>
		The [[*]] command causes a busy wait—the interpreter keeps running in an infinite loop,
		checking the specified condition or the elapsed time since the command began executing.
		Although you can specify a length of time as short as a nanosecond, there is absolutely
		no guarantee on how long the wait will actually be. The [[*]] command {{cannot}} be used
		for thread synchronization or real-time applications.
	</note>
	<note>
		HyperTalk only supports [[seconds]], [[ticks]], [[second]], and [[tick]] for the unit.
	</note>
</command>

<command>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">write</name>
	<syntax>write {data} to {object}</syntax>
	<syntax>write {data} to {object} at {offset}</syntax>
	<syntax-note>
		{Object} yields an object with an appropriate I/O manager.
		{Offset} yields an [[dt:integer]].
	</syntax-note>
	<example>write address to file "MyFile"</example>
	<example>write "first line" &amp; newline &amp; "second line" to file "TwoLiner"</example>
	<example>write steve to file "MyFile" at -15</example>
	<description>
		The [[*]] command copies the specified data to the specified object,
		which must be opened already with the [[cm:open]] command.
		Writing starts at the specified offset or, if no offset is specified,
		from where the last [[cm:read]] or [[cm:write]] left off. A negative
		offset indicates an offset from the end of the file, while a positive
		offset indicates an offset from the beginning of the file.
	</description>
	<note>
		In HyperTalk, in OpenXION 1.2 or later, and according to the XION Scripting
		Language Standard, if you write to a file without specifying an offset and
		without having previously read from, written to, or truncated the file, the
		file will automatically get truncated before the data is written. Otherwise
		the file will not be automatically truncated and any data that was not
		overwritten will remain.
	</note>
	<note>
		OpenXION 1.0 and 1.1 did not automatically truncate files, requiring
		the use of the [[cm:truncate]] command before writing to files. This
		was a bug, not a feature, and was fixed in OpenXION 1.2.
	</note>
	<see-also>
		[[cm:open]], [[cm:read]], [[cm:truncate]], [[cm:close]],
		[[mg:file]], [[mg:URL]], [[mt:text]], [[mt:binary]]
	</see-also>
</command>

<command>
	<name dialects="oxne12">sql</name>
	<syntax>sql connect to {url}</syntax>
	<syntax>sql connect to {url} with driver {driver}</syntax>
	<syntax>sql connect to {url} with username {username} with password {password}</syntax>
	<syntax>sql connect to {url} with driver {driver} with username {username} with password {password}</syntax>
	<syntax>sql disconnect</syntax>
	<syntax>sql disconnect from {url}</syntax>
	<syntax>sql prepare {query}</syntax>
	<syntax>sql prepare {query} using connection {url}</syntax>
	<syntax>sql prepare statement {query}</syntax>
	<syntax>sql prepare statement {query} using connection {url}</syntax>
	<syntax>sql prepare set {parameter} to {value}</syntax>
	<syntax>sql prepare set {parameter} to {value} using connection {url}</syntax>
	<syntax>sql prepare execute</syntax>
	<syntax>sql prepare execute using connection {url}</syntax>
	<syntax>sql execute prepared</syntax>
	<syntax>sql execute prepared using connection {url}</syntax>
	<syntax>sql execute {query}</syntax>
	<syntax>sql execute {query} using connection {url}</syntax>
	<syntax-note>
		{URL} yields the database's URL as a [[dt:string]].
		{Driver} yields the JDBC driver's class name as a [[dt:string]].
		{Username} and {password} yield the login name and password used to connect to the database as [[dt:string]]s.
		{Query} yields a SQL query as a [[dt:string]].
		{Parameter} yields the index into the prepared statement's parameters, starting from 1, as an [[dt:integer]].
		{Value} yields the parameter's value as a [[dt:string]].
	</syntax-note>
	<example>sql connect to "mysql://localhost/studentdb" with driver "com.mysql.jdbc.Driver" with username "admin" with password "woot"</example>
	<example>sql execute "select * from students" using connection "mysql://localhost/studentdb"</example>
	<example>sql prepare "update students set name=? where id=?" using connection "mysql://localhost/studentdb"</example>
	<example>sql prepare set 1 to "Little Bobby Tables"</example>
	<example>sql prepare set 2 to 16777216</example>
	<example>sql execute prepared</example>
	<example>sql disconnect from "mysql://localhost/studentdb"</example>
	<description>
		The [[*]] command connects to, disconnects from, and submits queries to a database.
	</description>
	<description>
		The [[sql connect]] form opens a connection to a database.
		If a connection has already been opened, the {driver} cannot be found or loaded,
		the database {url} is invalid, or the specified {username} and {password} are
		invalid, a script error is triggered.
	</description>
	<description>
		The [[sql disconnect]] form closes an open connection to a database.
		If no {url} is specified, the last successfully-used {url} is used.
		If there is no open connection to the database, a script error is triggered.
	</description>
	<description>
		The [[sql prepare statement]] form creates a prepared statement for the specified database.
		Parameters in the prepared statement are indicated by question marks in the query string.
		If no {url} is specified, the last successfully-used {url} is used.
		If there is no open connection to the database, a script error is triggered.
	</description>
	<description>
		The [[sql prepare set]] form sets the value of a parameter in the last prepared statement
		created for the specified database. The first parameter in the prepared statement is parameter 1.
		If no {url} is specified, the last successfully-used {url} is used.
		If there is no open connection to the database, no prepared statement has been created for
		the specified database, or the specified parameter index is invalid, a script error is triggered.
	</description>
	<description>
		The [[sql prepare execute]] and [[sql execute prepared]] forms execute the prepared statement.
		The number of rows affected or returned by the query is put into the [[fn:result]].
		If any rows are returned, they are put into [[it]]. Rows are delimited by the [[pr:rowDelimiter]]
		and columns are delimited by the [[pr:columnDelimiter]].
		If no {url} is specified, the last successfully-used {url} is used.
		If there is no open connection to the database, the query contains a syntax error,
		or the query cannot be executed successfully, a script error is triggered.
	</description>
	<description>
		The [[sql execute]] form executes a query immediately, without requiring the creation of a prepared statement.
		The number of rows affected or returned by the query is put into the [[fn:result]].
		If any rows are returned, they are put into [[it]]. Rows are delimited by the [[pr:rowDelimiter]]
		and columns are delimited by the [[pr:columnDelimiter]].
		If no {url} is specified, the last successfully-used {url} is used.
		If there is no open connection to the database, the query contains a syntax error,
		or the query cannot be executed successfully, a script error is triggered.
	</description>
	<script>
		The following scripts demonstrate two possible ways to list the contents of a table:
	</script>
	<script>
		[[sql execute "select * from students"\\
		repeat foreach x in the rows of it\\
		  put replaceall(x, the columndelimiter, tab)\\
		end repeat]]
	</script>
	<script>
		[[set the rowDelimiter to newline\\
		set the columnDelimiter to tab\\
		sql execute "select * from students"\\
		put it]]
	</script>
	<note>
		It is also possible to execute a query without quotes by leaving out the [[execute]] keyword, e.g.:\\
		\\
		[[sql select * from students where firstname = "Steve"]]\\
		\\
		However, this is prone to error and is not recommended.
		(If you're curious, among the reasons are:
		SQL and XION use different lexicographical rules, so it's possible for the query to confuse OpenXION or the database or both;
		it is impossible to use any XION expressions in such a statement, so you are limited to static queries;
		and this feature may change in future versions of OpenXION.)
	</note>
</command>

<command>
	<name dialects="oxna12,hyp">dial</name>
	<syntax>dial {number}</syntax>
	<syntax>dial {number} with modem</syntax>
	<syntax>dial {number} with modem {command}</syntax>
	<syntax-note>{Number} and {command} yield [[dt:string]]s.</syntax-note>
	<example>dial steve -- steve is a variable containing a phone number</example>
	<example>dial "555-1212"</example>
	<example>dial "555-1212" with modem</example>
	<example>dial "555-1212" with modem "ATS0=0S7=1DT"</example>
	<description>
		Without the [[with modem]] keyword, the [[*]] command plays the dial tones
		for the given phone {number}. With some land-line telephones, you can hold
		the handset against your computer's speaker while the [[*]] command is executing
		to dial the given phone {number}. The volume of the generated tones is controlled
		by the [[pr:dialingVolume]] property.
	</description>
	<description>
		With the [[with modem]] keyword, the [[*]] command will dial the given phone {number}
		using a modem attached to a communications port. If no modem {command} is specified,
		the default is [["ATDT"]]. The communications port used is determined by the
		[[pr:dialingPort]] property. There is a one-second delay between opening the
		communications port and issuing the {command}, and a delay between issuing the
		{command} and closing the port determined by the [[pr:dialingTime]] property.
	</description>
	<note>
		The [[*]] command is synchronous: it will not return until it has finished dialing.
		(This is different from the [[cm:play]], [[cm:speak]], and [[cm:tone]] commands,
		which are asynchronous.)
	</note>
	<note>
		OpenXION will use RXTX ([[gnu.io]] package) or the Java Communications API
		([[javax.comm]] package) to communicate with the modem, whichever is available.
		If neither package is available, [[*]] will do nothing but set the [[fn:result]]
		to an error message.
	</note>
	<security>
		To use the [[with modem]] keyword, OpenXION's security settings must allow the [[TELEPHONY]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[pr:dialingVolume]], [[pr:dialingTime]], [[pr:dialingPort]], [[fn:serialPorts]]</see-also>
</command>

<command>
	<name dialects="oxna12,hyp">play</name>
	<syntax>play {instrument}</syntax>
	<syntax>play {instrument} {notes}</syntax>
	<syntax>play {instrument} tempo {tempo} {notes}</syntax>
	<syntax>play stop</syntax>
	<syntax-note>{Instrument} and {notes} yield [[dt:string]]s. {Tempo} yields a [[dt:number]].</syntax-note>
	<example>play "harpsichord" "ch d e f g a b c5w"</example>
	<example>play "music box" "c4e c dq c f eh"</example>
	<example>play "harpsichord" "c4 a3 f c4 a3 f c4 d c c c"</example>
	<description>
		The [[*]] command plays the specified sequence of {notes} with the specified
		{instrument} using a MIDI synthesizer (in OpenXION) or sampled sounds (in HyperTalk).
		The {tempo} parameter specifies the number of quarter notes per minute;
		the default value is 120.
	</description>
	<description>
		The [[*]] command in OpenXION uses an extended version of the scripted
		music notation originally found in HyperTalk. A sequence of notes is
		represented as a [[dt:string]] with notes delimited by whitespace.
		Each note has the following format for a regular note:\\
		\\
		{noteName} {octave} {duration} {velocity} {effect}\\
		\\
		or the following format for a rest:\\
		\\
		{duration} [[r]]
	</description>
	<description>
		{NoteName} is a letter between [[A]] and [[G]], which may or may not be followed
		by any number of [[#]] symbols, each of which raises the pitch a half step,
		or any number of [[b]] symbols, each of which lowers the pitch a half step.
		In OpenXION, {noteName} can also be one of the letters [[M]], [[N]], or [[P]]
		followed by the MIDI dollar value, for which 60 is middle C. {NoteName}
		is the only required value in a note string.
	</description>
	<description>
		{Octave} is an integer specifying which octave the note belongs to.
		If the {octave} is not specified, the last {octave} specified is used.
		The default is 4, the octave starting with middle C.
	</description>
	<description>
		Middle C corresponds to the note string [[C4]] or [[B#3]].
		The note one half step below middle C is [[B3]] or [[Cb4]].
		440 Hz corresponds to the note string [[A4]].
	</description>
	<description>
		{Duration} is one of the following letters:
		\\\\
		::TABLE
		[[w]] :: whole note
		.....
		[[h]] :: half note
		.....
		[[q]] :: quarter note
		.....
		[[e]] :: eighth note
		.....
		[[s]] :: 16th note
		.....
		[[t]] :: 32nd note
		.....
		[[x]] :: 64th note
		.....
		[[o]] :: 128th note
		ELBAT::
		which may or may not be followed by any number of [[.]] symbols, each of
		which multiplies the duration by 1.5 to create a dotted note, or any number
		of [[3]] symbols, each of which divides the duration by 3 to create a triplet
		note. (In OpenXION, you can use any digit 2 through 9 to divide the
		duration by that value.) Also in OpenXION, {duration} can be the letter [[d]]
		followed by the duration in MIDI ticks. OpenXION uses 64 ticks per quarter note.
		If the {duration} is not specified, the last {duration} specified is used.
		The default is [[q]].
	</description>
	<description>
		{Velocity} is another extension provided by OpenXION not found in HyperTalk.
		It may be any of the following strings:
		\\\\
		::TABLE
		[[fff]] :: triple forte (velocity 127)
		.....
		[[ff]] :: fortissimo (velocity 112)
		.....
		[[f]] :: forte (velocity 96)
		.....
		[[mff]] :: (velocity 88)
		.....
		[[mf]] :: mezzo forte (velocity 80)
		.....
		[[m]] :: (velocity 72)
		.....
		[[mp]] :: mezzo piano (velocity 64)
		.....
		[[mpp]] :: (velocity 56)
		.....
		[[p]] :: piano (velocity 48)
		.....
		[[pp]] :: pianissimo (velocity 32)
		....
		[[ppp]] :: triple piano (velocity 16)
		ELBAT::
		{Velocity} can also be the letter [[v]] followed by the velocity of the note
		from 0 to 127. If the {velocity} is not specified, the last {velocity} specified
		is used. The default is [[fff]] or 127.
	</description>
	<description>
		{Effect} is the final extension provided by OpenXION not found in HyperTalk.
		It is one or more of the following characters:
		\\\\
		::TABLE
		[[ , ]] :: The note is stopped a few MIDI ticks before it normally would be, creating a stoccato effect.
		.....
		[[ * ]] :: The note keeps playing after its duration has passed. This can be used to start a fermata.
		(This overrides the effect of any [[ , ]] or any preceding [[ ! ]].)
		.....
		[[ ! ]] :: Stops a note previously started by [[ * ]] after the duration has passed. This can be used to end a fermata.
		If the note is not already playing, this is equivalent to a rest. (This overrides the effect of any preceding [[ * ]].)
		.....
		[[ + ]] :: Starts the next note at the same time as this note, creating a chord.
		ELBAT::
		If {effect} is not specified, no effects are applied.
	</description>
	<description>
		If the note string contains an [[r]], it is a rest and only the duration can be specified.
	</description>
	<note>
		The [[*]] command is asynchronous: it will return immediately while the
		sound keeps playing in the background. If there is already sound playing
		on the current [[pr:soundChannel]], the next sound to be played will be
		added to a queue. The [[play stop]] form of the [[*]] command will stop
		playing any sound on the current [[pr:soundChannel]]. The [[stop sound]]
		command will stop all currently-playing and pending sounds on all [[pr:soundChannel]]s.
	</note>
	<note>
		Early versions of HyperTalk limited the length of the note string to 254 characters.
		OpenXION and later versions of HyperTalk do not limit the length of the note string.
	</note>
	<note>
		In HyperTalk, the [[*]] command accepted note strings that were left unquoted,
		and this was often done. For example:\\
		\\
		[[play harpsichord c4 a3 f c4 a3 f c4 d c c c]]\\
		\\
		OpenXION will also accept unquoted note strings, but this is highly discouraged.
		You cannot use any special symbols (such as [[#]], [[.]], or [[+]]) in an unquoted note string,
		and if one of the notes in an unquoted note string turns out to also be the name of a constant or variable,
		the value of the constant or the contents of the variable will be played instead of the intended note.
	</note>
	<see-also>[[cm:stop]], [[fn:sound]], [[fn:sounds]], [[pr:soundChannel]]</see-also>
</command>

<command>
	<name dialects="oxna12,hyp">speak</name>
	<syntax>speak {phrase}</syntax>
	<syntax>speak {phrase} with {gender} voice</syntax>
	<syntax>speak {phrase} with voice {voice}</syntax>
	<syntax-note>{Phrase} and {voice} yield [[dt:string]]s. {Gender} is [[male]], [[female]], or [[neuter]].</syntax-note>
	<description>
		The [[*]] command speaks the specified {phrase} using a text-to-speech synthesizer.
		If the {voice} is specified, the {phrase} will be read using the specified {voice}.
		Otherwise, the default voice is used.
	</description>
	<note>
		The [[*]] command is asynchronous: it will return immediately while the
		speech keeps playing in the background. If there is already text being spoken,
		the next text to be spoken will be added to a queue. The [[stop speech]]
		command will stop all current and pending speech.
	</note>
	<note>
		HyperTalk and OpenXION running under Mac OS use the speech synthesizer built in to Mac OS.
		OpenXION running under other platforms will use JSAPI (Java Speech API), if available.
		If JSAPI is not available, [[*]] will do nothing but set the [[fn:result]] to an error message.
	</note>
	<see-also>[[cm:stop]], [[fn:speech]], [[fn:voice]], [[fn:voices]]</see-also>
</command>

<command>
	<name dialects="oxna12,hyp">stop</name>
	<syntax>stop sound</syntax>
	<syntax>stop speech</syntax>
	<syntax>stop tone</syntax>
	<description>
		The [[stop sound]] command immediately stops all current and pending sound
		started or queued by the [[cm:play]] command on all [[pr:soundChannel]]s.
		To stop sound on the current [[pr:soundChannel]] only, use the [[play stop]]
		form of [[cm:play]].
	</description>
	<description>
		The [[stop speech]] command immediately stops all current and pending speech
		started or queued by the [[cm:speak]] command.
	</description>
	<description>
		The [[stop tone]] command immediately stops all current and pending tones
		started or queued by the [[cm:tone]] command on all [[pr:toneChannel]]s.
		(HyperTalk does not have a [[cm:tone]] or [[stop tone]] command.)
	</description>
	<see-also>[[cm:play]], [[cm:speak]], [[cm:tone]]</see-also>
</command>

<command>
	<name dialects="oxna12">tone</name>
	<syntax>tone {frequency}</syntax>
	<syntax>tone {frequency} for {duration}</syntax>
	<syntax>tone {frequency} for {duration} {unit}</syntax>
	<syntax-note>
		{Frequency} and {duration} yield [[dt:number]]s.
		{Unit} is [[hour]], [[hours]], [[min]], [[mins]], [[minute]], [[minutes]],
		[[sec]], [[secs]], [[second]], [[seconds]], [[tick]], [[ticks]],
		[[milli]], [[millis]], [[millisecond]], or [[milliseconds]].
	</syntax-note>
	<description>
		The [[*]] command plays a tone of a single {frequency} (in Hz) for a specified {duration}.
		Unless specified, the default {unit} for the {duration} is [[ticks]], or sixtieths of a second.
		The volume of the generated tone is determined by the [[pr:toneVolume]] property.
	</description>
	<note>
		The [[*]] command is asynchronous: it will return immediately while the tone
		keeps playing in the background. If there is already a tone playing on the current
		[[pr:toneChannel]], the next tone to be played will be added to a queue.
		The [[stop tone]] command will stop all currently-playing and pending tones
		on all [[pr:toneChannel]]s.
	</note>
	<see-also>[[cm:stop]], [[fn:tone]], [[pr:toneVolume]], [[pr:toneChannel]]</see-also>
</command>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">abs</name>
	<syntax>the abs of {factor}</syntax>
	<syntax>abs({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put abs(a-b) into theDifference</example>
	<description>
		The [[fn:abs]] function returns the absolute value of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]], an [[dt:integer]] is returned.
	</description>
	<description>
		If the argument is a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
		The returned [[dt:complex]] will have a real part of the distance
		of the passed in [[dt:complex]] from the origin, and an imaginary
		part of zero.
	</description>
	<note>
		This function is similar to the [[fn:hypot]] and [[fn:radius]] functions,
		but takes one numeric argument rather than a list.
	</note>
	<see-also>[[fn:hypot]], [[fn:radius]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">acos</name>
	<syntax>the acos of {factor}</syntax>
	<syntax>acos({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put acos(theCosine) into theAngle</example>
	<description>
		The [[fn:acos]] function returns the inverse cosine of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">acosh</name>
	<syntax>the acosh of {factor}</syntax>
	<syntax>acosh({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put acosh(steve) into bill</example>
	<description>
		The [[fn:acosh]] function returns the inverse hyperbolic cosine of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">acot</name>
	<syntax>the acot of {factor}</syntax>
	<syntax>acot({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put acot(theCotangent) into theAngle</example>
	<description>
		The [[fn:acot]] function returns the inverse cotangent of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">acoth</name>
	<syntax>the acoth of {factor}</syntax>
	<syntax>acoth({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put acoth(steve) into bill</example>
	<description>
		The [[fn:acoth]] function returns the inverse hyperbolic cotangent of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">acsc</name>
	<syntax>the acsc of {factor}</syntax>
	<syntax>acsc({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put acsc(theCosecant) into theAngle</example>
	<description>
		The [[fn:acsc]] function returns the inverse cosecant of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">acsch</name>
	<syntax>the acsch of {factor}</syntax>
	<syntax>acsch({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put acsch(steve) into bill</example>
	<description>
		The [[fn:acsch]] function returns the inverse hyperbolic cosecant of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">agm</name>
	<syntax>the agm of ({expression}, {expression})</syntax>
	<syntax>agm({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].</syntax-note>
	<example>put agm(steve, bill) into andy</example>
	<description>
		The [[fn:agm]] function returns the arithmetic-geometric mean of its arguments.
	</description>
	<description>
		The following function handler mimics the behavior of this built-in function for valid arguments:
		\\\\[[function agm a,b\\
		  repeat while a is not b\\
		    put (a+b)/2 into arithmeticMean\\
		    put sqrt(a*b) into geometricMean\\
		    put arithmeticMean into a\\
		    put geometricMean into b\\
		  end repeat\\
		  return a\\
		end agm]]\\\\
		The [[*]] function is faster and more accurate than using the above handler.
	</description>
	<description>
		If both arguments are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If either argument is negative, [[cn:NaN]] is returned.
		To get a [[dt:complex]] result, convert the arguments to [[dt:complex]]es.
	</description>
	<description>
		If either argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		To use this function with more than two arguments, use this construction:
		\\\\[[get agm(avg({list}), geom({list}))]]
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">and</name>
	<syntax>the and of {factor}</syntax>
	<syntax>and({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:booleans]].</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if and only if all of its arguments are [[cn:true]].
		If any argument is [[cn:false]], it returns [[cn:false]].
	</description>
	<note>
		This is the infinite-arity version of the [[op:and]] operator.
	</note>
	<see-also>[[op:and]], [[op:&amp;&amp;&amp;]], [[fn:or]], [[fn:xor]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">annuity</name>
	<syntax>the annuity of ({rate}, {periods})</syntax>
	<syntax>annuity({rate}, {periods})</syntax>
	<syntax-note>{Rate} and {periods} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put myPayment*annuity(.015,12) into presentValue</example>
	<example>put myPayment*annuity(.015,12)*compound(.015,12)¬\\  into futureValue</example>
	<description>
		The [[*]] function is used to calculate the present or future value of
		an ordinary annuity. {Rate} is the interest rate per period, and {periods}
		is the number of periods over which the value is calculated.
	</description>
	<description>
		The formula for the [[*]] function is
		\\\\[[annuity({rate}, {periods}) = (1-((1+{rate})^(-{periods})))/{rate}]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<note>
		You can use [[dt:complex]] arguments to this function, but what this means
		exactly is up to the accountants and economists to figure out, not me.
	</note>
	<see-also>[[fn:compound]]</see-also>
</function>

<function>
	<name dialects="oxn1,oxn11,oxn12">appFile</name>
	<name dialects="oxn1,oxn11,oxn12">applicationFile</name>
	<name dialects="oxn1,oxn11,oxn12">progFile</name>
	<name dialects="oxn1,oxn11,oxn12">programFile</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns a [[dt:file]] that represents the application with the specified name.
		If no such application can be found, the [[*]] function returns [[cn:empty]].
		In OpenXION, the locations searched for applications are determined by the
		[[pr:applicationPaths]] property.
	</description>
	<note>
		The [[*]] function is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[pr:applicationPaths]], [[fn:appPath]], [[fn:docPath]], [[fn:docFile]], [[fn:appOrDocPath]], [[fn:appOrDocFile]]</see-also>
</function>

<function>
	<name dialects="oxn1,oxn11,oxn12">appPath</name>
	<name dialects="oxn1,oxn11,oxn12">applicationPath</name>
	<name dialects="oxn1,oxn11,oxn12">progPath</name>
	<name dialects="oxn1,oxn11,oxn12">programPath</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the path of the application with the specified name.
		If no such application can be found, the [[*]] function returns [[cn:empty]].
		In OpenXION, the locations searched for applications are determined by the
		[[pr:applicationPaths]] property.
	</description>
	<note>
		The [[*]] function is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[pr:applicationPaths]], [[fn:appFile]], [[fn:docPath]], [[fn:docFile]], [[fn:appOrDocPath]], [[fn:appOrDocFile]]</see-also>
</function>

<function>
	<name dialects="oxn1,oxn11,oxn12">appOrDocFile</name>
	<name dialects="oxn1,oxn11,oxn12">applicationOrDocumentFile</name>
	<name dialects="oxn1,oxn11,oxn12">progOrDocFile</name>
	<name dialects="oxn1,oxn11,oxn12">programOrDocumentFile</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns a [[dt:file]] that represents the application or document with the specified name.
		If no such application or document can be found, the [[*]] function returns [[cn:empty]].
		In OpenXION, the locations searched for applications and documents are determined by the
		[[pr:applicationPaths]] and [[pr:documentPaths]] properties, respectively.
	</description>
	<note>
		The [[*]] function is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[pr:applicationPaths]], [[pr:documentPaths]], [[fn:appPath]], [[fn:appFile]], [[fn:docPath]], [[fn:docFile]], [[fn:appOrDocPath]]</see-also>
</function>

<function>
	<name dialects="oxn1,oxn11,oxn12">appOrDocPath</name>
	<name dialects="oxn1,oxn11,oxn12">applicationOrDocumentPath</name>
	<name dialects="oxn1,oxn11,oxn12">progOrDocPath</name>
	<name dialects="oxn1,oxn11,oxn12">programOrDocumentPath</name>
	<name dialects="oxn1,oxn11,oxn12">path</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the path of the application or document with the specified name.
		If no such application or document can be found, the [[*]] function returns [[cn:empty]].
		In OpenXION, the locations searched for applications and documents are determined by the
		[[pr:applicationPaths]] and [[pr:documentPaths]] properties, respectively.
	</description>
	<note>
		The [[*]] function is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[pr:applicationPaths]], [[pr:documentPaths]], [[fn:appPath]], [[fn:appFile]], [[fn:docPath]], [[fn:docFile]], [[fn:appOrDocFile]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">arg</name>
	<syntax>the arg of {factor}</syntax>
	<syntax>arg({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put arg(3,4) into angle</example>
	<description>
		The [[fn:arg]] function returns the complex argument of its argument.
	</description>
	<description>
		If the argument is a negative [[dt:integer]] or [[dt:number]], [[cn:pi]] is returned.
		If the argument is a positive [[dt:integer]] or [[dt:number]], or if the argument is [[cn:zero]], [[cn:zero]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
		The returned [[dt:complex]] will have a real part of the angle, in radians,
		of the passed in [[dt:complex]] from the positive x-axis, and an imaginary
		part of zero.
	</description>
	<note>
		This function is similar to the [[fn:atan2]] and [[fn:theta]] functions,
		but takes one numeric argument rather than two.
	</note>
	<see-also>[[fn:atan2]], [[fn:theta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">asc</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">ascending</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">inc</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">increasing</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield any kind of [[dt:list]].</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if and only if its arguments are in a
		monotonically increasing sequence. That is, every element in the list must be
		greater than or equal to the elements preceding it, and less than or equal to
		the elements following it. The elements are compared as if by the [[op:&lt;=]]
		operator.
	</description>
	<note>
		This is the infinite-arity version of the [[op:&lt;=]] operator.
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">asec</name>
	<syntax>the asec of {factor}</syntax>
	<syntax>asec({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put asec(theSecant) into theAngle</example>
	<description>
		The [[fn:asec]] function returns the inverse secant of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">asech</name>
	<syntax>the asech of {factor}</syntax>
	<syntax>asech({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put asech(steve) into bill</example>
	<description>
		The [[fn:asech]] function returns the inverse hyperbolic secant of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">asin</name>
	<syntax>the asin of {factor}</syntax>
	<syntax>asin({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put asin(theSine) into theAngle</example>
	<description>
		The [[fn:asin]] function returns the inverse sine of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">asinh</name>
	<syntax>the asinh of {factor}</syntax>
	<syntax>asinh({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put asinh(steve) into bill</example>
	<description>
		The [[fn:asinh]] function returns the inverse hyperbolic sine of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">atan</name>
	<syntax>the atan of {factor}</syntax>
	<syntax>atan({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put atan(theTangent) into theAngle</example>
	<description>
		The [[fn:atan]] function returns the inverse tangent of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:atan2]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">atan2</name>
	<syntax>the atan2 of ({expression}, {expression})</syntax>
	<syntax>atan2({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]] or a [[dt:number]].</syntax-note>
	<example>put atan2(steve, bill) into andy</example>
	<description>
		The [[fn:atan2]] function returns the angle, in radians, of the specified
		coordinates from the positive x-axis. The first argument is the y coordinate,
		and the second argument is the x coordinate.
	</description>
	<note>
		This function is similar to the [[fn:theta]] function, but the arguments are in opposite order.
		It is also similar to the [[fn:arg]] function, but it takes two arguments rather than one,
		and the elements are in opposite order.
	</note>
	<see-also>[[fn:atan]], [[fn:arg]], [[fn:theta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">atanh</name>
	<syntax>the atanh of {factor}</syntax>
	<syntax>atanh({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put atanh(steve) into bill</example>
	<description>
		The [[fn:atanh]] function returns the inverse hyperbolic tangent of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">aug</name>
	<syntax>the aug of {factor}</syntax>
	<syntax>aug({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put aug(steve) into bill</example>
	<description>
		The [[*]] function returns the given value rounded towards unsigned infinity, or away from zero.
		If the given value is an [[dt:integer]], the given value is returned.
		Otherwise, the given value is rounded to the integer with the next highest absolute value and the same sign.
	</description>
	<description>
		The following table illustrates the behavior of the [[*]] function:\\\\
		::TABLE
		{{argument}} :: {{result}}
		..........................
		       2     ::   2
		..........................
		       1.75  ::   2
		..........................
		       1.5   ::   2
		..........................
		       1.25  ::   2
		..........................
		       1     ::   1
		..........................
		       0.75  ::   1
		..........................
		       0.5   ::   1
		..........................
		       0.25  ::   1
		..........................
		       0     ::   0
		..........................
		      -0.25  ::  -1
		..........................
		      -0.5   ::  -1
		..........................
		      -0.75  ::  -1
		..........................
		      -1     ::  -1
		..........................
		      -1.25  ::  -2
		..........................
		      -1.5   ::  -2
		..........................
		      -1.75  ::  -2
		..........................
		      -2     ::  -2
		ELBAT::
	</description>
	<description>
		If the given value is a [[dt:complex]], the real and imaginary
		parts of the complex number are each rounded individually.
	</description>
	<note>
		The following table shows the correspondences among the various
		{roundingMethod}s, rounding functions, and division operators:\\\\
		::TABLE
		{{[[rounding]] parameter}} :: {{function}} :: {{operator}}             :: {{[[java.math.RoundingMode]]}}
		........................................................................................................
		[[to ceiling]]             :: [[fn:ceil]]  ::                          :: [[CEILING]]
		........................................................................................................
		[[to floor]]               :: [[fn:floor]] :: [[op:div]] / [[op:mod]]  :: [[FLOOR]]
		........................................................................................................
		[[up]] / [[to infinity]]   :: [[fn:aug]]   ::                          :: [[UP]]
		........................................................................................................
		[[down]] / [[to zero]]     :: [[fn:trunc]] :: [[op:quot]] / [[op:rem]] :: [[DOWN]]
		........................................................................................................
		[[to nearest]]             :: [[fn:round]] ::                          :: [[HALF_UP]]
		........................................................................................................
		[[to even]]                :: [[fn:rint]]  ::                          :: [[HALF_EVEN]]
		ELBAT::
	</note>
	<note>
		The following table illustrates the behavior of the rounding functions side-by-side:\\\\
		::TABLE
		{{argument}} :: {{[[fn:ceil]]}}  :: {{[[fn:floor]]}} :: {{[[fn:aug]]}}   :: {{[[fn:trunc]]}} :: {{[[fn:round]]}} :: {{[[fn:rint]]}}
		...................................................................................................................................
		       2     ::   2              ::   2              ::   2              ::   2              ::   2              ::   2           
		...................................................................................................................................
		       1.75  ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.5   ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.25  ::   2              ::   1              ::   2              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       1     ::   1              ::   1              ::   1              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       0.75  ::   1              ::   0              ::   1              ::   0              ::   1              ::   1           
		...................................................................................................................................
		       0.5   ::   1              ::   0              ::   1              ::   0              ::   1              ::   0           
		...................................................................................................................................
		       0.25  ::   1              ::   0              ::   1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		       0     ::   0              ::   0              ::   0              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.25  ::   0              ::  -1              ::  -1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.5   ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::   0           
		...................................................................................................................................
		      -0.75  ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::  -1           
		...................................................................................................................................
		      -1     ::  -1              ::  -1              ::  -1              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.25  ::  -1              ::  -2              ::  -2              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.5   ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -1.75  ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -2     ::  -2              ::  -2              ::  -2              ::  -2              ::  -2              ::  -2           
		ELBAT::
	</note>
	<see-also>[[fn:ceil]], [[fn:floor]], [[fn:trunc]], [[fn:round]], [[fn:rint]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">average</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">avg</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>put [[*]](1,3,4) into bill</example>
	<description>
		The [[*]] function returns the arithmetic mean,
		or average, of the numeric values passed to it.
		This is equal to the sum of the passed values
		divided by the number of values.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:geom]], [[fn:geomean]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">bc</name>
	<syntax>the bc of ({expression}, {sourceBase}, {destinationBase})</syntax>
	<syntax>bc({expression}, {sourceBase}, {destinationBase})</syntax>
	<syntax-note>
		{Expression} yields a [[dt:string]].
		{SourceBase} and {destinationBase} yield positive [[dt:integer]]s
		between 2 and 36, inclusive.
	</syntax-note>
	<example>put bc("09F91102", 16, 10) into myNumber</example>
	<description>
		The [[*]] function converts a real or complex number in any base, or radix,
		to the same number in another base. For example, [[bc("FF",16,10)]] gives [["255"]],
		and [[bc("255",10,16)]] gives [["FF"]].
	</description>
	<note>
		If the given {sourceBase} or {destinationBase} is less than 2 or greater than 36,
		a script error is triggered.
	</note>
	<see-also>[[fn:bin]], [[fn:hex]], [[fn:oct]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">beta</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">β</name>
	<syntax>the [[*]] of ({expression}, {expression})</syntax>
	<syntax>[[*]]({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].</syntax-note>
	<description>
		The [[*]] function computes the value of the beta function,
		also known as the Euler integral of the first kind.
	</description>
	<description>
		The expression [[*]][[(x,y)]] is equivalent to [[gamma(x) * gamma(y) / gamma(x+y)]].
	</description>
	<see-also>[[fn:factorial]], [[fn:gamma]], [[fn:lnfactorial]], [[fn:lngamma]], [[fn:lnbeta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">bin</name>
	<syntax>the bin of {factor}</syntax>
	<syntax>bin({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put bin(6789) into steve</example>
	<description>
		The [[*]] function converts a real or complex number in decimal,
		or base ten, to the same number in binary, or base two. For example,
		[[bin(42)]] gives [["101010"]].
	</description>
	<see-also>[[fn:bc]], [[fn:hex]], [[fn:oct]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">binToChar</name>
	<syntax>the binToChar of {factor}</syntax>
	<syntax>binToChar({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield a [[dt:binary]].</syntax-note>
	<example>put the binToChar of "6364" -- yields "cd"</example>
	<description>
		The [[*]] function returns the [[dt:string]] encoded by the
		[[dt:binary]] passed to it in the text encoding specified
		by the [[pr:textEncoding]] property.
	</description>
	<see-also>
		[[fn:binToUni]], [[fn:charToBin]], [[fn:charToNum]],
		[[fn:numToChar]], [[fn:numToUni]], [[fn:uniToBin]], [[fn:uniToNum]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">binToUni</name>
	<syntax>the binToUni of {factor}</syntax>
	<syntax>binToUni({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield a [[dt:binary]].</syntax-note>
	<example>put the binToUni of "CEB3CEB4" -- yields "γδ"</example>
	<description>
		The [[*]] function returns the [[dt:string]] encoded by the
		[[dt:binary]] passed to it in the UTF-8 text encoding.
	</description>
	<see-also>
		[[fn:binToChar]], [[fn:charToBin]], [[fn:charToNum]],
		[[fn:numToChar]], [[fn:numToUni]], [[fn:uniToBin]], [[fn:uniToNum]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">cbrt</name>
	<syntax>the cbrt of {factor}</syntax>
	<syntax>cbrt({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put cbrt(27) -- puts 3</example>
	<description>
		The [[fn:cbrt]] function returns the cube root of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:sqrt]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">ceil</name>
	<syntax>the ceil of {factor}</syntax>
	<syntax>ceil({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put ceil(steve) into bill</example>
	<description>
		The [[*]] function returns the given value rounded towards positive infinity.
		If the given value is an [[dt:integer]], the given value is returned.
		Otherwise, the given value is rounded to the next highest integer, regardless of sign.
	</description>
	<description>
		The following table illustrates the behavior of the [[*]] function:\\\\
		::TABLE
		{{argument}} :: {{result}}
		..........................
		       2     ::   2
		..........................
		       1.75  ::   2
		..........................
		       1.5   ::   2
		..........................
		       1.25  ::   2
		..........................
		       1     ::   1
		..........................
		       0.75  ::   1
		..........................
		       0.5   ::   1
		..........................
		       0.25  ::   1
		..........................
		       0     ::   0
		..........................
		      -0.25  ::   0
		..........................
		      -0.5   ::   0
		..........................
		      -0.75  ::   0
		..........................
		      -1     ::  -1
		..........................
		      -1.25  ::  -1
		..........................
		      -1.5   ::  -1
		..........................
		      -1.75  ::  -1
		..........................
		      -2     ::  -2
		ELBAT::
	</description>
	<description>
		If the given value is a [[dt:complex]], the real and imaginary
		parts of the complex number are each rounded individually.
	</description>
	<note>
		The following table shows the correspondences among the various
		{roundingMethod}s, rounding functions, and division operators:\\\\
		::TABLE
		{{[[rounding]] parameter}} :: {{function}} :: {{operator}}             :: {{[[java.math.RoundingMode]]}}
		........................................................................................................
		[[to ceiling]]             :: [[fn:ceil]]  ::                          :: [[CEILING]]
		........................................................................................................
		[[to floor]]               :: [[fn:floor]] :: [[op:div]] / [[op:mod]]  :: [[FLOOR]]
		........................................................................................................
		[[up]] / [[to infinity]]   :: [[fn:aug]]   ::                          :: [[UP]]
		........................................................................................................
		[[down]] / [[to zero]]     :: [[fn:trunc]] :: [[op:quot]] / [[op:rem]] :: [[DOWN]]
		........................................................................................................
		[[to nearest]]             :: [[fn:round]] ::                          :: [[HALF_UP]]
		........................................................................................................
		[[to even]]                :: [[fn:rint]]  ::                          :: [[HALF_EVEN]]
		ELBAT::
	</note>
	<note>
		The following table illustrates the behavior of the rounding functions side-by-side:\\\\
		::TABLE
		{{argument}} :: {{[[fn:ceil]]}}  :: {{[[fn:floor]]}} :: {{[[fn:aug]]}}   :: {{[[fn:trunc]]}} :: {{[[fn:round]]}} :: {{[[fn:rint]]}}
		...................................................................................................................................
		       2     ::   2              ::   2              ::   2              ::   2              ::   2              ::   2           
		...................................................................................................................................
		       1.75  ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.5   ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.25  ::   2              ::   1              ::   2              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       1     ::   1              ::   1              ::   1              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       0.75  ::   1              ::   0              ::   1              ::   0              ::   1              ::   1           
		...................................................................................................................................
		       0.5   ::   1              ::   0              ::   1              ::   0              ::   1              ::   0           
		...................................................................................................................................
		       0.25  ::   1              ::   0              ::   1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		       0     ::   0              ::   0              ::   0              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.25  ::   0              ::  -1              ::  -1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.5   ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::   0           
		...................................................................................................................................
		      -0.75  ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::  -1           
		...................................................................................................................................
		      -1     ::  -1              ::  -1              ::  -1              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.25  ::  -1              ::  -2              ::  -2              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.5   ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -1.75  ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -2     ::  -2              ::  -2              ::  -2              ::  -2              ::  -2              ::  -2           
		ELBAT::
	</note>
	<see-also>[[fn:floor]], [[fn:aug]], [[fn:trunc]], [[fn:round]], [[fn:rint]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">center</name>
	<syntax>the center of ({string}, {length})</syntax>
	<syntax>center({string}, {length})</syntax>
	<syntax-note>{String} yields any [[dt:string]]. {Length} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] function returns the middle {length} characters of the specified {string}.
	</description>
	<note>
		If {length} is zero or negative, [[cn:empty]] is returned.
		If {length} is longer than the specified {string}, the original {string} is returned.
	</note>
	<see-also>[[fn:left]], [[fn:mid]], [[fn:right]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">charToBin</name>
	<syntax>the charToBin of {factor}</syntax>
	<syntax>charToBin({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield a [[dt:string]].</syntax-note>
	<example>put the charToBin of "ab" into it -- yields "6162"</example>
	<description>
		The [[*]] function returns a [[dt:binary]] of the string passed to it encoded
		in the text encoding specified by the [[pr:textEncoding]] property.
	</description>
	<see-also>
		[[fn:binToChar]], [[fn:binToUni]], [[fn:charToNum]],
		[[fn:numToChar]], [[fn:numToUni]], [[fn:uniToBin]], [[fn:uniToNum]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">charToNum</name>
	<syntax>the charToNum of {factor}</syntax>
	<syntax>charToNum({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield a character.</syntax-note>
	<example>put the charToNum of "a" into it -- yields 97</example>
	<description>
		The [[*]] function returns the equivalent value of the character passed to it
		in the text encoding specified by the [[pr:textEncoding]] property.
	</description>
	<note>
		If more than one character is passed, [[*]] returns the value of the first character.
	</note>
	<see-also>
		[[fn:binToChar]], [[fn:binToUni]], [[fn:charToBin]],
		[[fn:numToChar]], [[fn:numToUni]], [[fn:uniToBin]], [[fn:uniToNum]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">compound</name>
	<syntax>the compound of ({rate}, {periods})</syntax>
	<syntax>compound({rate}, {periods})</syntax>
	<syntax-note>{Rate} and {periods} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put futureValue/compound(.10,12) into presentValue</example>
	<example>put presentValue*compound(.10,12) into futureValue</example>
	<description>
		The [[*]] function is used to calculate the present or future value of
		a compound interest-bearing account. {Rate} is the interest rate per
		period, and {periods} is the number of periods over which the value is
		calculated.
	</description>
	<description>
		The formula for the [[*]] function is
		\\\\[[compound({rate}, {periods}) = (1+{rate})^{periods}]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<note>
		You can use [[dt:complex]] arguments to this function, but what this means
		exactly is up to the accountants and economists to figure out, not me.
	</note>
	<script>
		The following example calculates the value in one year of an account
		earning 7.5 percent interest compounded monthly:
		\\\\[[on calcInterest\\
		  ask "Enter the beginning balance:" with empty\\
		  put "Value in 1 year $" &amp; it * compound(.075/12, 12)\\
		end calcInterest]]
	</script>
	<see-also>[[fn:annuity]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">concat</name>
	<syntax>the concat of {factor}</syntax>
	<syntax>concat({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:strings]].</syntax-note>
	<description>
		The [[*]] function returns the string concatenation of all of its arguments.
	</description>
	<note>
		This is the infinite-arity version of the [[op:&amp;]] operator.
	</note>
	<see-also>[[fn:concatsp]], [[fn:implode]], [[fn:lconcat]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">concatsp</name>
	<syntax>the concatsp of {factor}</syntax>
	<syntax>concatsp({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:strings]].</syntax-note>
	<description>
		The [[*]] function returns the string concatenation of all of its arguments,
		with a single space between each argument.
	</description>
	<note>
		This is the infinite-arity version of the [[op:&amp;&amp;]] operator.
	</note>
	<see-also>[[fn:concat]], [[fn:implode]], [[fn:lconcat]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">conj</name>
	<syntax>the conj of {factor}</syntax>
	<syntax>conj({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put conj(3,4) -- yields 3,-4</example>
	<description>
		The [[fn:conj]] function returns the complex conjugate of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], the argument itself is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
		The returned [[dt:complex]] will have the same real part, and
		the negation of the imaginary part.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">cos</name>
	<syntax>the cos of {factor}</syntax>
	<syntax>cos({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the cos of 2 -- yields -0.416147</example>
	<description>
		The [[*]] function returns the cosine of the angle that is passed to it.
		The angle must be expressed in radians.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		Radians can be converted to degrees with the [[fn:toDegrees]] function,
		or by multiplying by 180 and dividing by [[cn:pi]].
		Degrees can be converted to radians with the [[fn:toRadians]] function,
		or by multiplying by [[cn:pi]] and dividing by 180.
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">cosh</name>
	<syntax>the cosh of {factor}</syntax>
	<syntax>cosh({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the cosh of 2 -- yields 3.762196</example>
	<description>
		The [[*]] function returns the hyperbolic cosine of the value that is passed to it.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">cot</name>
	<syntax>the cot of {factor}</syntax>
	<syntax>cot({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the cot of 2 -- yields -0.457658</example>
	<description>
		The [[*]] function returns the cotangent of the angle that is passed to it.
		The angle must be expressed in radians.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		Radians can be converted to degrees with the [[fn:toDegrees]] function,
		or by multiplying by 180 and dividing by [[cn:pi]].
		Degrees can be converted to radians with the [[fn:toRadians]] function,
		or by multiplying by [[cn:pi]] and dividing by 180.
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">coth</name>
	<syntax>the coth of {factor}</syntax>
	<syntax>coth({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the coth of 2 -- yields 1.037315</example>
	<description>
		The [[*]] function returns the hyperbolic cotangent of the value that is passed to it.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">countFields</name>
	<syntax>the countFields of ({string}, {delimiter})</syntax>
	<syntax>countFields({string}, {delimiter})</syntax>
	<syntax-note>{String} and {delimiter} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the number of chunks in the specified {string}
		delimited by the specified {delimiter}, not including any trailing empty
		chunks.
	</description>
	<description>
		The {delimiter} is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csCountFields]].
		For a regular expression-based version of this function, see [[fn:regCountFields]].
	</description>
	<see-also>[[fn:csCountFields]], [[fn:regCountFields]], [[fn:nthField]], [[fn:csNthField]], [[fn:regNthField]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">cpad</name>
	<syntax>the cpad of ({string}, {length})</syntax>
	<syntax>the cpad of ({string}, {length}, {padding})</syntax>
	<syntax>cpad({string}, {length})</syntax>
	<syntax>cpad({string}, {length}, {padding})</syntax>
	<syntax-note>{String} and {padding} yield any [[dt:string]]s. {Length} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] function both prepends and appends the specified {padding}
		to the specified {string} until the resulting string is longer than
		the specified {length}, then returns the middle {length} characters
		of the resulting string. In other words, the string is padded to be
		aligned in the center. If no {padding} is specified, spaces are used.
	</description>
	<note>
		If {length} is zero or negative, [[cn:empty]] is returned.
		If {length} is shorter than the specified {string}, only the
		middle {length} characters of the original {string} are returned.
	</note>
	<see-also>[[fn:lpad]], [[fn:rpad]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csc</name>
	<syntax>the csc of {factor}</syntax>
	<syntax>csc({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the csc of 2 -- yields 1.099750</example>
	<description>
		The [[*]] function returns the cosecant of the angle that is passed to it.
		The angle must be expressed in radians.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		Radians can be converted to degrees with the [[fn:toDegrees]] function,
		or by multiplying by 180 and dividing by [[cn:pi]].
		Degrees can be converted to radians with the [[fn:toRadians]] function,
		or by multiplying by [[cn:pi]] and dividing by 180.
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csch</name>
	<syntax>the csch of {factor}</syntax>
	<syntax>csch({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the csch of 2 -- yields 0.275721</example>
	<description>
		The [[*]] function returns the hyperbolic cosecant of the value that is passed to it.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csCountFields</name>
	<syntax>the csCountFields of ({string}, {delimiter})</syntax>
	<syntax>csCountFields({string}, {delimiter})</syntax>
	<syntax-note>{String} and {delimiter} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the number of chunks in the specified {string}
		delimited by the specified {delimiter}, not including any trailing empty
		chunks.
	</description>
	<description>
		The {delimiter} is case-sensitive.
		For a case-insensitive version of this function, see [[fn:countFields]].
		For a regular expression-based version of this function, see [[fn:regCountFields]].
	</description>
	<see-also>[[fn:countFields]], [[fn:regCountFields]], [[fn:nthField]], [[fn:csNthField]], [[fn:regNthField]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csExplode</name>
	<syntax>the csExplode of ({string}, {delimiter})</syntax>
	<syntax>csExplode({string}, {delimiter})</syntax>
	<syntax-note>{String} and {delimiter} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns a [[dt:list]] of the chunks in the specified {string}
		delimited by the specified {delimiter}, not including any trailing empty chunks.
	</description>
	<description>
		The {delimiter} is case-sensitive.
		For a case-insensitive version of this function, see [[fn:explode]].
		For a regular expression-based version of this function, see [[fn:regExplode]].
	</description>
	<see-also>[[fn:explode]], [[fn:regExplode]], [[fn:implode]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csInstr</name>
	<syntax>the csInstr of ({haystack}, {needle})</syntax>
	<syntax>csInstr({haystack}, {needle})</syntax>
	<syntax-note>{Haystack} and {needle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the index of the first appearance of
		the string {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is case-sensitive.
		For a case-insensitive version of this function, see [[fn:instr]].
		For a regular expression-based version of this function, see [[fn:regInstr]].
	</description>
	<note>
		This function is similar to [[fn:csOffset]], but the arguments are in reverse order.
	</note>
	<see-also>
		[[fn:instr]], [[fn:regInstr]],
		[[fn:offset]], [[fn:csOffset]], [[fn:regOffset]],
		[[fn:rinstr]], [[fn:csRinstr]], [[fn:regRinstr]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csNthField</name>
	<syntax>the csNthField of ({string}, {delimiter}, {index})</syntax>
	<syntax>csNthField({string}, {delimiter}, {index})</syntax>
	<syntax-note>{String} and {delimiter} yield [[dt:string]]s. {Index} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] function returns a chunk of the specified {string}
		delimited by the specified {delimiter}. {Index} starts at 1.
	</description>
	<description>
		If {index} is less than 1 or greater than [[fn:csCountFields]][[({string}, {delimiter})]],
		[[cn:empty]] is returned.
	</description>
	<description>
		The {delimiter} is case-sensitive.
		For a case-insensitive version of this function, see [[fn:nthField]].
		For a regular expression-based version of this function, see [[fn:regNthField]].
	</description>
	<see-also>[[fn:nthField]], [[fn:regNthField]], [[fn:countFields]], [[fn:csCountFields]], [[fn:regCountFields]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csOffset</name>
	<syntax>the csOffset of ({needle}, {haystack})</syntax>
	<syntax>csOffset({needle}, {haystack})</syntax>
	<syntax-note>{Haystack} and {needle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the index of the first appearance of
		the string {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is case-sensitive.
		For a case-insensitive version of this function, see [[fn:offset]].
		For a regular expression-based version of this function, see [[fn:regOffset]].
	</description>
	<note>
		This function is similar to [[fn:csInstr]], but the arguments are in reverse order.
	</note>
	<see-also>
		[[fn:offset]], [[fn:regOffset]],
		[[fn:instr]], [[fn:csInstr]], [[fn:regInstr]],
		[[fn:rinstr]], [[fn:csRinstr]], [[fn:regRinstr]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csReplace</name>
	<syntax>the csReplace of ({haystack}, {needle}, {noodle})</syntax>
	<syntax>csReplace({haystack}, {needle}, {noodle})</syntax>
	<syntax-note>{Haystack}, {needle}, and {noodle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the string {haystack}
		with the first occurrence of the string {needle}
		replaced with the string {noodle}.
	</description>
	<description>
		{Needle} is case-sensitive.
		For a case-insensitive version of this function, see [[fn:replace]].
		For a regular expression-based version of this function, see [[fn:regReplace]].
	</description>
	<see-also>[[fn:csReplaceAll]], [[fn:replace]], [[fn:regReplace]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csReplaceAll</name>
	<syntax>the csReplaceAll of ({haystack}, {needle}, {noodle})</syntax>
	<syntax>csReplaceAll({haystack}, {needle}, {noodle})</syntax>
	<syntax-note>{Haystack}, {needle}, and {noodle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the string {haystack}
		with every occurrence of the string {needle}
		replaced with the string {noodle}.
	</description>
	<description>
		{Needle} is case-sensitive.
		For a case-insensitive version of this function, see [[fn:replaceAll]].
		For a regular expression-based version of this function, see [[fn:regReplaceAll]].
	</description>
	<see-also>[[fn:csReplace]], [[fn:replaceAll]], [[fn:regReplaceAll]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csRinstr</name>
	<syntax>the csRinstr of ({haystack}, {needle})</syntax>
	<syntax>csRinstr({haystack}, {needle})</syntax>
	<syntax-note>{Haystack} and {needle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the index of the last appearance of
		the string {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is case-sensitive.
		For a case-insensitive version of this function, see [[fn:rinstr]].
		For a regular expression-based version of this function, see [[fn:regRinstr]].
	</description>
	<see-also>
		[[fn:rinstr]], [[fn:regRinstr]],
		[[fn:instr]], [[fn:csInstr]], [[fn:regInstr]],
		[[fn:offset]], [[fn:csOffset]], [[fn:regOffset]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">csStrcmp</name>
	<syntax>the csStrcmp of ({expression}, {expression})</syntax>
	<syntax>csStrcmp({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields a [[dt:string]].</syntax-note>
	<description>
		The [[fn:strcmp]] function compares the two given [[dt:string]]s by Unicode code point.
		If the first string comes before the second, a negative [[dt:integer]] is returned.
		If the first string comes after the second, a positive [[dt:integer]] is returned.
		If the two strings are equal, [[cn:zero]] is returned.
	</description>
	<description>
		The [[fn:csStrcmp]] function is case-sensitive.
		For a case-insensitive version of this function, see [[fn:strcmp]].
		For a regular expression-based version of this function, see [[fn:regMatch]].
	</description>
	<see-also>[[fn:strcmp]], [[fn:regMatch]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">date</name>
	<syntax>the date</syntax>
	<syntax>the {modifier} date</syntax>
	<syntax>date()</syntax>
	<syntax-note>{Modifier} is [[kw:short]], [[kw:abbreviated]], [[kw:long]], or [[kw:English]]. The default is [[kw:short]].</syntax-note>
	<example>put the last word of the long date into currentYear</example>
	<description>
		The [[*]] function returns a [[dt:date]] representing the current date.
		There are four forms of the [[*]] function:\\\\
		::TABLE
		[[the short date]] :: [[20/7/93]]
		.................................
		[[the abbrev date]] :: [[Tue 20 Oct 1992]]
		.................................
		[[the long date]] :: [[Tuesday 7 October 1989]]
		.................................
		[[the English date]] :: [[Saturday, February 15, 1986]]
		ELBAT::
	</description>
	<note>
		The format of the date is dependent on the current locale.
		This is important if you want to write scripts that work anywhere without modification.
		You cannot assume that the [[*]] function will always return a date in the same format.
	</note>
	<note>
		To prevent issues caused by differing local date formats, use the
		[[fn:seconds]] or the [[fn:dateItems]] to store and perform calculations
		with dates and times.
	</note>
	<see-also>[[cm:convert]], [[fn:dateItems]], [[fn:seconds]], [[fn:ticks]], [[fn:time]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">dateItems</name>
	<syntax>the dateItems</syntax>
	<syntax>dateItems()</syntax>
	<example>put the first item of the dateItems into currentYear</example>
	<description>
		The [[*]] function returns a [[dt:date]] representing the current date
		as a comma-delimited list of integers representing the year, month
		(from 1 for January to 12 for December), day, hour (from 0 to 23),
		minute, second, and day of week (from 1 for Sunday to 7 for Saturday).
		The format of the [[*]] is fixed.
	</description>
	<see-also>[[cm:convert]], [[fn:date]], [[fn:seconds]], [[fn:ticks]], [[fn:time]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">dec</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">decreasing</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">desc</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">descending</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield any kind of [[dt:list]].</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if and only if its arguments are in a
		monotonically decreasing sequence. That is, every element in the list must be
		less than or equal to the elements preceding it, and greater than or equal to
		the elements following it. The elements are compared as if by the [[op:&gt;=]]
		operator.
	</description>
	<note>
		This is the infinite-arity version of the [[op:&gt;=]] operator.
	</note>
</function>

<function>
	<name dialects="oxn1,oxn11,oxn12">docFile</name>
	<name dialects="oxn1,oxn11,oxn12">documentFile</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns a [[dt:file]] that represents the document with the specified name.
		If no such document can be found, the [[*]] function returns [[cn:empty]].
		In OpenXION, the locations searched for documents are determined by the
		[[pr:documentPaths]] property.
	</description>
	<note>
		The [[*]] function is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[pr:documentPaths]], [[fn:appPath]], [[fn:appFile]], [[fn:docPath]], [[fn:appOrDocPath]], [[fn:appOrDocFile]]</see-also>
</function>

<function>
	<name dialects="oxn1,oxn11,oxn12">docPath</name>
	<name dialects="oxn1,oxn11,oxn12">documentPath</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the path of the document with the specified name.
		If no such document can be found, the [[*]] function returns [[cn:empty]].
		In OpenXION, the locations searched for documents are determined by the
		[[pr:documentPaths]] property.
	</description>
	<note>
		The [[*]] function is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[pr:documentPaths]], [[fn:appPath]], [[fn:appFile]], [[fn:docFile]], [[fn:appOrDocPath]], [[fn:appOrDocFile]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">equal</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield any kind of [[dt:list]].</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if and only if all of its arguments
		are equal to each other. If any two arguments are not equal, the [[*]]
		function returns [[cn:false]].
	</description>
	<note>
		If the given values are [[dt:integer]]s or [[dt:number]]s, the values will be compared numerically.
		If the given values are [[dt:date]]s, the values will be compared chronologically.
		Otherwise, the values will be compared as strings.
	</note>
	<note>
		This is the infinite-arity version of the [[op:=]] operator.
	</note>
	<see-also>[[op:=]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">exp</name>
	<syntax>the exp of {factor}</syntax>
	<syntax>exp({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the exp of 2 -- yields 7.389056</example>
	<description>
		The [[*]] function returns the mathematical exponential of its argument,
		defined as the constant {e}, which is approximately 2.7182818284, raised
		to the power specified by the argument.
		That is, it returns
		\\\\[[cn:euler]][[ ^ {number}]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp1]], [[fn:exp2]], [[fn:exp10]], [[fn:ln]], [[fn:ln1]], [[fn:log2]], [[fn:log10]], [[fn:log]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">exp1</name>
	<syntax>the exp1 of {factor}</syntax>
	<syntax>exp1({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the exp1 of 2 -- yields 6.389056</example>
	<description>
		The [[*]] function returns 1 less than the mathematical exponential of
		its argument.
		That is, it returns
		\\\\[[(]][[cn:euler]][[ ^ {number}) - 1]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp]], [[fn:exp2]], [[fn:exp10]], [[fn:ln]], [[fn:ln1]], [[fn:log2]], [[fn:log10]], [[fn:log]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">exp10</name>
	<syntax>the exp10 of {factor}</syntax>
	<syntax>exp10({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the exp10 of 4 -- yields 10000</example>
	<description>
		The [[*]] function returns the value of 10 raised to the
		power specified by its argument.
		That is, it returns
		\\\\[[10 ^ {number}]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp]], [[fn:exp1]], [[fn:exp2]], [[fn:ln]], [[fn:ln1]], [[fn:log2]], [[fn:log10]], [[fn:log]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">exp2</name>
	<syntax>the exp2 of {factor}</syntax>
	<syntax>exp2({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the exp2 of 16 -- yields 65536</example>
	<description>
		The [[*]] function returns the value of 2 raised to the
		power specified by its argument.
		That is, it returns
		\\\\[[2 ^ {number}]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp]], [[fn:exp1]], [[fn:exp10]], [[fn:ln]], [[fn:ln1]], [[fn:log2]], [[fn:log10]], [[fn:log]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">explode</name>
	<syntax>the explode of ({string}, {delimiter})</syntax>
	<syntax>explode({string}, {delimiter})</syntax>
	<syntax-note>{String} and {delimiter} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns a [[dt:list]] of the chunks in the specified {string}
		delimited by the specified {delimiter}, not including any trailing empty chunks.
	</description>
	<description>
		The {delimiter} is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csExplode]].
		For a regular expression-based version of this function, see [[fn:regExplode]].
	</description>
	<see-also>[[fn:csExplode]], [[fn:regExplode]], [[fn:implode]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">fact</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">factorial</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the [[*]] of 5 -- yields 120</example>
	<description>
		The [[*]] function returns the factorial of its argument.
		For positive integers, the factorial is defined as the product of the integers
		from 1 to the specified integer, e.g. [[fact(5) = 1 * 2 * 3 * 4 * 5 = 120]].
		For other real or complex numbers, the factorial is defined
		in terms of the [[fn:gamma]] function, i.e. [[fact({n}) = gamma({n}+1)]].
	</description>
	<see-also>[[fn:gamma]], [[fn:beta]], [[fn:lnfactorial]], [[fn:lngamma]], [[fn:lnbeta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">floor</name>
	<syntax>the floor of {factor}</syntax>
	<syntax>floor({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put floor(steve) into bill</example>
	<description>
		The [[*]] function returns the given value rounded towards negative infinity.
		If the given value is an [[dt:integer]], the given value is returned.
		Otherwise, the given value is rounded to the next lowest integer, regardless of sign.
	</description>
	<description>
		The following table illustrates the behavior of the [[*]] function:\\\\
		::TABLE
		{{argument}} :: {{result}}
		..........................
		       2     ::   2
		..........................
		       1.75  ::   1
		..........................
		       1.5   ::   1
		..........................
		       1.25  ::   1
		..........................
		       1     ::   1
		..........................
		       0.75  ::   0
		..........................
		       0.5   ::   0
		..........................
		       0.25  ::   0
		..........................
		       0     ::   0
		..........................
		      -0.25  ::  -1
		..........................
		      -0.5   ::  -1
		..........................
		      -0.75  ::  -1
		..........................
		      -1     ::  -1
		..........................
		      -1.25  ::  -2
		..........................
		      -1.5   ::  -2
		..........................
		      -1.75  ::  -2
		..........................
		      -2     ::  -2
		ELBAT::
	</description>
	<description>
		If the given value is a [[dt:complex]], the real and imaginary
		parts of the complex number are each rounded individually.
	</description>
	<note>
		The following table shows the correspondences among the various
		{roundingMethod}s, rounding functions, and division operators:\\\\
		::TABLE
		{{[[rounding]] parameter}} :: {{function}} :: {{operator}}             :: {{[[java.math.RoundingMode]]}}
		........................................................................................................
		[[to ceiling]]             :: [[fn:ceil]]  ::                          :: [[CEILING]]
		........................................................................................................
		[[to floor]]               :: [[fn:floor]] :: [[op:div]] / [[op:mod]]  :: [[FLOOR]]
		........................................................................................................
		[[up]] / [[to infinity]]   :: [[fn:aug]]   ::                          :: [[UP]]
		........................................................................................................
		[[down]] / [[to zero]]     :: [[fn:trunc]] :: [[op:quot]] / [[op:rem]] :: [[DOWN]]
		........................................................................................................
		[[to nearest]]             :: [[fn:round]] ::                          :: [[HALF_UP]]
		........................................................................................................
		[[to even]]                :: [[fn:rint]]  ::                          :: [[HALF_EVEN]]
		ELBAT::
	</note>
	<note>
		The following table illustrates the behavior of the rounding functions side-by-side:\\\\
		::TABLE
		{{argument}} :: {{[[fn:ceil]]}}  :: {{[[fn:floor]]}} :: {{[[fn:aug]]}}   :: {{[[fn:trunc]]}} :: {{[[fn:round]]}} :: {{[[fn:rint]]}}
		...................................................................................................................................
		       2     ::   2              ::   2              ::   2              ::   2              ::   2              ::   2           
		...................................................................................................................................
		       1.75  ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.5   ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.25  ::   2              ::   1              ::   2              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       1     ::   1              ::   1              ::   1              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       0.75  ::   1              ::   0              ::   1              ::   0              ::   1              ::   1           
		...................................................................................................................................
		       0.5   ::   1              ::   0              ::   1              ::   0              ::   1              ::   0           
		...................................................................................................................................
		       0.25  ::   1              ::   0              ::   1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		       0     ::   0              ::   0              ::   0              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.25  ::   0              ::  -1              ::  -1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.5   ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::   0           
		...................................................................................................................................
		      -0.75  ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::  -1           
		...................................................................................................................................
		      -1     ::  -1              ::  -1              ::  -1              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.25  ::  -1              ::  -2              ::  -2              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.5   ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -1.75  ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -2     ::  -2              ::  -2              ::  -2              ::  -2              ::  -2              ::  -2           
		ELBAT::
	</note>
	<see-also>[[fn:ceil]], [[fn:aug]], [[fn:trunc]], [[fn:round]], [[fn:rint]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">frac</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put [[*]](steve) into bill</example>
	<description>
		The [[*]] function returns the fractional part of the given value,
		discarding the integer part, regardless of sign.
		The sign of the result will be the same as the sign of the given value.
	</description>
	<description>
		The following table illustrates the behavior of the [[*]] function:\\\\
		::TABLE
		{{argument}} :: {{result}}
		..........................
		       2     ::   0
		..........................
		       1.75  ::   0.75
		..........................
		       1.5   ::   0.5
		..........................
		       1.25  ::   0.25
		..........................
		       1     ::   0
		..........................
		       0.75  ::   0.75
		..........................
		       0.5   ::   0.5
		..........................
		       0.25  ::   0.25
		..........................
		       0     ::   0
		..........................
		      -0.25  ::  -0.25
		..........................
		      -0.5   ::  -0.5
		..........................
		      -0.75  ::  -0.75
		..........................
		      -1     ::   0
		..........................
		      -1.25  ::  -0.25
		..........................
		      -1.5   ::  -0.5
		..........................
		      -1.75  ::  -0.75
		..........................
		      -2     ::   0
		ELBAT::
	</description>
	<description>
		If the given value is a [[dt:complex]], the real and imaginary
		parts of the complex number are each processed individually.
	</description>
	<see-also>[[fn:int]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">gamma</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">Γ</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function computes the value of the gamma function.
	</description>
	<see-also>[[fn:factorial]], [[fn:beta]], [[fn:lnfactorial]], [[fn:lngamma]], [[fn:lnbeta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">gcd</name>
	<syntax>the gcd of ({expression}, {expression})</syntax>
	<syntax>gcd({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]].</syntax-note>
	<example>put gcd(steve, bill) into andy</example>
	<description>
		The [[fn:gcd]] function returns the greatest common divisor of its arguments.
	</description>
	<see-also>[[fn:lcm]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">geom</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">geomean</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>put [[*]](1,3,4) into bill</example>
	<description>
		The [[*]] function returns the geometric mean
		of the numeric values passed to it.
		This is equal to the product of the passed values
		raised to the power of one over the number of values.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:avg]], [[fn:average]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">hash</name>
	<syntax>the hash of {data}</syntax>
	<syntax>the hash of ({data}, {algorithm})</syntax>
	<syntax>hash({data})</syntax>
	<syntax>hash({data}, {algorithm})</syntax>
	<syntax-note>
		{Data} yields a [[dt:binary]] or a [[dt:string]].
		{Algorithm} yields the name of a hash algorithm.
	</syntax-note>
	<example>put hash(steve, "Atkinson") into bill</example>
	<example>put hash(data, "MD5") into md5</example>
	<description>
		The [[*]] function hashes the specified {data} with
		the specified hash {algorithm} and returns either
		an [[dt:integer]] or a [[dt:binary]] containing the
		resulting hash.
	</description>
	<description>
		If {data} is not a [[dt:binary]], it is converted
		to a [[dt:string]], converted to lowercase, and
		then converted to a [[dt:binary]] using the text
		encoding specified by the [[pr:textEncoding]]
		property.
	</description>
	<description>
		If the hash {algorithm} is not specified, the default is
		the Atkinson hash algorithm. The Atkinson algorithm is
		the only hash algorithm required by the XION Scripting
		Language Standard. The resulting hash is returned as
		an unsigned [[dt:integer]]. The Atkinson hash algorithm
		is as follows:
		\\
		\\if the binary is zero-length:
		\\        initialize {hash} to [[0x42696C6C]] ([['Bill']])
		\\else:
		\\        initialize {hash} to zero
		\\        initialize {seed} to the unsigned value of the first byte, plus the number of bytes
		\\        for each bit {b} in the binary, starting with the most significant bit of the first byte:
		\\                multiply {seed} by [[0x41A7]]
		\\                while {seed} ≥ [[0x80000000]]:
		\\                        set {seed} to ( {seed} &amp; [[0x7FFFFFFF]] ) + ( {seed} &gt;&gt; 31 )
		\\                if {seed} = [[0x7FFFFFFF]]:
		\\                        set {seed} to zero
		\\                if bit {b} is set:
		\\                        add {seed} to {hash}
		\\return the 32 least significant bits of {hash}
	</description>
	<note>
		OpenXION supports Atkinson, returning an unsigned [[dt:integer]],
		as well as MD2, MD5, SHA-1, SHA-256, SHA-384, and SHA-512,
		returning a [[dt:binary]].
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">head</name>
	<syntax>the head of {factor}</syntax>
	<syntax>head({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s.</syntax-note>
	<description>
		The [[*]] function returns the first element in a list.
	</description>
	<see-also>[[fn:tail]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">hex</name>
	<syntax>the hex of {factor}</syntax>
	<syntax>hex({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put hex(6789) into steve</example>
	<description>
		The [[*]] function converts a real or complex number in decimal,
		or base ten, to the same number in hexadecimal, or base sixteen.
		For example, [[hex(8984)]] gives [["2318"]].
	</description>
	<see-also>[[fn:bc]], [[fn:bin]], [[fn:oct]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">hypot</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">radius</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>put [[*]](3,4) -- yields 5</example>
	<description>
		The [[*]] function returns the square root of the sum of the squares of its arguments.
		For one argument, this is equivalent to the [[fn:abs]] function. For {n} arguments,
		this is equivalent to the distance from the origin of the specified point in {n}-dimensional
		space.
	</description>
	<note>
		This function is similar to the [[fn:abs]] function,
		but can take more than one argument.
	</note>
	<see-also>[[fn:abs]], [[fn:xcoord]], [[fn:ycoord]], [[fn:theta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">Im</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function returns the imaginary part of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], [[cn:zero]] is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], the imaginary part of the argument is returned as a [[dt:number]].
	</description>
	<see-also>[[fn:Re]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">implode</name>
	<syntax>the implode of ({list}, {delimiter})</syntax>
	<syntax>implode({list}, {delimiter})</syntax>
	<syntax-note>{List} yields a [[dt:list]] of [[dt:strings]]. {Delimiter} yields a [[dt:string]].</syntax-note>
	<description>
		The [[*]] function returns the string concatenation of all of its arguments,
		with the specified {delimiter} between each argument.
	</description>
	<see-also>[[fn:concat]], [[fn:concatsp]], [[fn:explode]], [[fn:csExplode]], [[fn:regExplode]]</see-also>
</function>

<function>
	<name dialects="oxn11,oxn12">includeFile</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns a [[dt:file]] that represents the include with the specified name.
		If no such include can be found, the [[*]] function returns [[cn:empty]].
		In OpenXION, the locations searched for includes are determined by the
		[[pr:includePaths]] property.
	</description>
	<note>
		The [[*]] function is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cs:include]], [[cs:require]], [[pr:includePaths]], [[fn:includePath]]</see-also>
</function>

<function>
	<name dialects="oxn11,oxn12">includePath</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the path of the include with the specified name.
		If no such include can be found, the [[*]] function returns [[cn:empty]].
		In OpenXION, the locations searched for includes are determined by the
		[[pr:includePaths]] property.
	</description>
	<note>
		The [[*]] function is specific to OpenXION; it is not part of the XION Scripting Language Standard.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cs:include]], [[cs:require]], [[pr:includePaths]], [[fn:includeFile]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">instr</name>
	<syntax>the instr of ({haystack}, {needle})</syntax>
	<syntax>instr({haystack}, {needle})</syntax>
	<syntax-note>{Haystack} and {needle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the index of the first appearance of
		the string {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csInstr]].
		For a regular expression-based version of this function, see [[fn:regInstr]].
	</description>
	<note>
		This function is similar to [[fn:offset]], but the arguments are in reverse order.
	</note>
	<see-also>
		[[fn:csInstr]], [[fn:regInstr]],
		[[fn:offset]], [[fn:csOffset]], [[fn:regOffset]],
		[[fn:rinstr]], [[fn:csRinstr]], [[fn:regRinstr]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">isFinite</name>
	<syntax>the isFinite of {factor}</syntax>
	<syntax>isFinite({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if the specified value is defined and finite,
		or [[cn:false]] if the specified value is [[cn:NaN]], [[cn:infinity]], or [[-]][[cn:infinity]].
	</description>
	<see-also>[[fn:isInfinite]], [[fn:isNaN]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">isInfinite</name>
	<syntax>the isInfinite of {factor}</syntax>
	<syntax>isInfinite({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if the specified value is [[cn:infinity]] or [[-]][[cn:infinity]],
		or [[cn:false]] if the specified value is defined and finite or [[cn:NaN]].
	</description>
	<see-also>[[fn:isFinite]], [[fn:isNaN]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">isNaN</name>
	<syntax>the isNaN of {factor}</syntax>
	<syntax>isNaN({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if the specified value is [[cn:NaN]],
		or [[cn:false]] if the specified value is defined and finite, [[cn:infinity]], or [[-]][[cn:infinity]].
	</description>
	<see-also>[[fn:isFinite]], [[fn:isInfinite]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">lcase</name>
	<syntax>the lcase of {factor}</syntax>
	<syntax>lcase({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function converts all the letters in the specified [[dt:string]]
		to lowercase and returns the resulting [[dt:string]]. For example,
		[[lcase("Hello, my name is Rebecca. But you can call me Beckie.")
		= "hello, my name is rebecca. but you can call me beckie."]].
	</description>
	<see-also>[[fn:ucase]], [[fn:tcase]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">lcm</name>
	<syntax>the lcm of ({expression}, {expression})</syntax>
	<syntax>lcm({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]].</syntax-note>
	<example>put lcm(steve, bill) into andy</example>
	<description>
		The [[fn:lcm]] function returns the least common multiple of its arguments.
	</description>
	<see-also>[[fn:gcd]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">lconcat</name>
	<syntax>the lconcat of {factor}</syntax>
	<syntax>lconcat({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:lists]].</syntax-note>
	<description>
		The [[*]] function returns the list concatenation of all of its arguments.
	</description>
	<note>
		This is the infinite-arity version of the [[op::]] operator.
	</note>
	<see-also>[[fn:concat]], [[fn:concatsp]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">left</name>
	<syntax>the left of ({string}, {length})</syntax>
	<syntax>left({string}, {length})</syntax>
	<syntax-note>{String} yields any [[dt:string]]. {Length} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] function returns the leftmost {length} characters of the specified {string}.
	</description>
	<note>
		If {length} is zero or negative, [[cn:empty]] is returned.
		If {length} is longer than the specified {string}, the original {string} is returned.
	</note>
	<see-also>[[fn:center]], [[fn:mid]], [[fn:right]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">length</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">len</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<example>put [[*]]("tail") into it -- yields 4</example>
	<example>put [[*]]("Nu är det slut…") -- yields 15</example>
	<example>if the [[*]] of word n of steve > 25¬\\  then add 1 to fogIndex</example>
	<description>
		The [[*]] function returns the number of characters (including spaces,
		tabs, line breaks, and other control and formatting characters) in the
		[[dt:string]] passed to it.
	</description>
	<note>
		The expression [[*]][[({factor})]] is identical in effect to
		[[the number of characters in {factor}]] but is more efficient.
	</note>
</function>

<function>
	<name dialects="xn1,oxn12">llength</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield lists.</syntax-note>
	<description>
		The [[*]] function returns the number of elements in a list.
	</description>
	<see-also>[[fn:number]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">ln</name>
	<syntax>the ln of {factor}</syntax>
	<syntax>ln({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the ln of 10 -- yields 2.302585</example>
	<description>
		The [[*]] function returns the base-{e} (natural) logarithm
		of the number passed to it.
	</description>
	<description>
		If the argument is a positive [[dt:integer]] or [[dt:number]], a [[dt:number]] is returned.
		If the argument is [[cn:zero]], negative [[cn:infinity]] is returned.
		If the argument is a negative [[dt:integer]] or [[dt:number]], [[cn:NaN]] is returned.
		To get a [[dt:complex]] result, convert the argument to a [[dt:complex]].
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp]], [[fn:exp1]], [[fn:exp2]], [[fn:exp10]], [[fn:ln1]], [[fn:log2]], [[fn:log10]], [[fn:log]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">ln1</name>
	<syntax>the ln1 of {factor}</syntax>
	<syntax>ln1({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the ln1 of 10 -- yields 2.397895</example>
	<description>
		The [[*]] function returns the base-{e} (natural) logarithm
		of 1 plus the number passed to it.
		That is, it returns
		\\\\[[ln(1 + {number})]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]] greater than -1, a [[dt:number]] is returned.
		If the argument is -1 exactly, negative [[cn:infinity]] is returned.
		If the argument is an [[dt:integer]] or a [[dt:number]] less than -1, [[cn:NaN]] is returned.
		To get a [[dt:complex]] result, convert the argument to a [[dt:complex]].
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp]], [[fn:exp1]], [[fn:exp2]], [[fn:exp10]], [[fn:ln]], [[fn:log2]], [[fn:log10]], [[fn:log]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">lnbeta</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">lnβ</name>
	<syntax>the [[*]] of ({expression}, {expression})</syntax>
	<syntax>[[*]]({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]], a [[dt:number]], or a [[dt:complex]].</syntax-note>
	<description>
		The [[*]] function computes the natural logarithm of the beta function.
	</description>
	<description>
		The expression [[*]][[(x,y)]] is equivalent to [[lngamma(x) + lngamma(y) - lngamma(x+y)]].
	</description>
	<see-also>[[fn:factorial]], [[fn:gamma]], [[fn:beta]], [[fn:lnfactorial]], [[fn:lngamma]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">lnfact</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">lnfactorial</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the [[*]] of 5 -- yields 4.787492</example>
	<description>
		The [[*]] function returns the natural logarithm of the factorial of its argument.
		For positive integers, the factorial is defined as the product of the integers
		from 1 to the specified integer, e.g. [[fact(5) = 1 * 2 * 3 * 4 * 5 = 120]].
		For other real or complex numbers, the factorial is defined
		in terms of the [[fn:gamma]] function, i.e. [[fact({n}) = gamma({n}+1)]].
	</description>
	<see-also>[[fn:factorial]], [[fn:gamma]], [[fn:beta]], [[fn:lngamma]], [[fn:lnbeta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">lngamma</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">lnΓ</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function computes the natural logarithm of the gamma function.
	</description>
	<see-also>[[fn:factorial]], [[fn:gamma]], [[fn:beta]], [[fn:lnfactorial]], [[fn:lnbeta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">log</name>
	<syntax>the log of ({argument}, {base})</syntax>
	<syntax>log({argument}, {base})</syntax>
	<syntax-note>{Argument} and {base} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put log(10,4) -- yields 1.660964</example>
	<description>
		The [[*]] function returns the base-{base} logarithm
		of {argument}. That is, it returns
		\\\\[[ln({argument}) / ln({base})]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<description>
		If both arguments are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If either argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp]], [[fn:exp1]], [[fn:exp2]], [[fn:exp10]], [[fn:ln]], [[fn:ln1]], [[fn:log2]], [[fn:log10]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">log10</name>
	<syntax>the log10 of {factor}</syntax>
	<syntax>log10({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the log10 of 42 -- yields 1.623249</example>
	<description>
		The [[*]] function returns the base-10 (common) logarithm
		of the number passed to it.
	</description>
	<description>
		If the argument is a positive [[dt:integer]] or [[dt:number]], a [[dt:number]] is returned.
		If the argument is [[cn:zero]], negative [[cn:infinity]] is returned.
		If the argument is a negative [[dt:integer]] or [[dt:number]], [[cn:NaN]] is returned.
		To get a [[dt:complex]] result, convert the argument to a [[dt:complex]].
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp]], [[fn:exp1]], [[fn:exp2]], [[fn:exp10]], [[fn:ln]], [[fn:ln1]], [[fn:log2]], [[fn:log]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">log2</name>
	<syntax>the log2 of {factor}</syntax>
	<syntax>log2({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the log2 of 10 -- yields 3.321928</example>
	<description>
		The [[*]] function returns the base-2 (binary) logarithm
		of the number passed to it.
	</description>
	<description>
		If the argument is a positive [[dt:integer]] or [[dt:number]], a [[dt:number]] is returned.
		If the argument is [[cn:zero]], negative [[cn:infinity]] is returned.
		If the argument is a negative [[dt:integer]] or [[dt:number]], [[cn:NaN]] is returned.
		To get a [[dt:complex]] result, convert the argument to a [[dt:complex]].
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:exp]], [[fn:exp1]], [[fn:exp2]], [[fn:exp10]], [[fn:ln]], [[fn:ln1]], [[fn:log10]], [[fn:log]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">lpad</name>
	<syntax>the lpad of ({string}, {length})</syntax>
	<syntax>the lpad of ({string}, {length}, {padding})</syntax>
	<syntax>lpad({string}, {length})</syntax>
	<syntax>lpad({string}, {length}, {padding})</syntax>
	<syntax-note>{String} and {padding} yield any [[dt:string]]s. {Length} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] function prepends the specified {padding} to the specified
		{string} until the resulting string is longer than the specified {length},
		then returns the rightmost {length} characters of the resulting string.
		In other words, the string is padded on the left to be aligned to the
		right. If no {padding} is specified, spaces are used.
	</description>
	<note>
		If {length} is zero or negative, [[cn:empty]] is returned.
		If {length} is shorter than the specified {string}, only the
		rightmost {length} characters of the original {string} are returned.
	</note>
	<see-also>[[fn:cpad]], [[fn:rpad]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">lreverse</name>
	<syntax>the lreverse of {factor}</syntax>
	<syntax>lreverse({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s.</syntax-note>
	<example>put lreverse(1,2,3,4) -- yields 4,3,2,1</example>
	<description>
		The [[*]] function returns the reversal of the specified [[dt:list]].
		The last element of the given [[dt:list]] becomes the first element
		of the resulting [[dt:list]], and vice versa.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">ltrim</name>
	<syntax>the ltrim of {factor}</syntax>
	<syntax>ltrim({factor})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<example>put ltrim("  Hello, world!  ") -- yields "Hello, world!  "</example>
	<description>
		The [[*]] function trims all spaces, tabs, line breaks, control
		characters, line separators, and paragraph separators from the
		beginning of the given [[dt:string]] and returns the trimmed string.
	</description>
	<see-also>[[fn:trim]], [[fn:rtrim]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">max</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">maximum</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield any kind of [[dt:list]].</syntax-note>
	<description>
		The [[*]] function returns the largest element of its arguments.
		The elements are compared as if by the [[op:&gt;]] operator.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">mid</name>
	<syntax>the mid of ({string}, {offset})</syntax>
	<syntax>the mid of ({string}, {offset}, {length})</syntax>
	<syntax>mid({string}, {offset})</syntax>
	<syntax>mid({string}, {offset}, {length})</syntax>
	<syntax-note>{String} yields any [[dt:string]]. {Offset} and {length} yield [[dt:integer]]s.</syntax-note>
	<description>
		The [[*]] function returns {length} characters of the specified {string}
		starting at the specified {offset}. The first character of the string
		is at offset 1.
	</description>
	<description>
		If no {length} is specified, all characters of the string
		starting at the specified {offset} are returned.
	</description>
	<note>
		If {length} is zero or negative, or {offset} is greater than
		the length of the {string}, [[cn:empty]] is returned.
		If {offset} is zero or negative, the leftmost {length}+{offset}-1
		characters of the {string} are returned.
	</note>
	<see-also>[[fn:left]], [[fn:center]], [[fn:right]], [[fn:substr]], [[fn:substring]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">min</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">minimum</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield any kind of [[dt:list]].</syntax-note>
	<description>
		The [[*]] function returns the smallest element of its arguments.
		The elements are compared as if by the [[op:&lt;]] operator.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">nCr</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">choose</name>
	<syntax>the [[*]] of ({n}, {r})</syntax>
	<syntax>[[*]]({n}, {r})</syntax>
	<syntax-note>{N} and {r} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function returns the number of combinations
		where {n} is the number of things to choose from and
		{r} is the number of things chosen.
	</description>
	<description>
		The formula for the [[*]] function is
		\\\\[[*]][[({n},{r}) = ]][[fn:fact]][[({n}) / (]][[fn:fact]][[({r})]][[ * ]][[fn:fact]][[({n}-{r}))]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<description>
		If both arguments are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If either argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:nPr]], [[fn:pick]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">nPr</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">pick</name>
	<syntax>the [[*]] of ({n}, {r})</syntax>
	<syntax>[[*]]({n}, {r})</syntax>
	<syntax-note>{N} and {r} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function returns the number of permutations
		where {n} is the number of things to choose from and
		{r} is the number of things chosen.
	</description>
	<description>
		The formula for the [[*]] function is
		\\\\[[*]][[({n},{r}) = ]][[fn:fact]][[({n}) / ]][[fn:fact]][[({n}-{r})]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<description>
		If both arguments are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If either argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:nCr]], [[fn:choose]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">nthField</name>
	<syntax>the nthField of ({string}, {delimiter}, {index})</syntax>
	<syntax>nthField({string}, {delimiter}, {index})</syntax>
	<syntax-note>{String} and {delimiter} yield [[dt:string]]s. {Index} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] function returns a chunk of the specified {string}
		delimited by the specified {delimiter}. {Index} starts at 1.
	</description>
	<description>
		If {index} is less than 1 or greater than [[fn:countFields]][[({string}, {delimiter})]],
		[[cn:empty]] is returned.
	</description>
	<description>
		The {delimiter} is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csNthField]].
		For a regular expression-based version of this function, see [[fn:regNthField]].
	</description>
	<see-also>[[fn:csNthField]], [[fn:regNthField]], [[fn:countFields]], [[fn:csCountFields]], [[fn:regCountFields]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">number</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield chunk expressions, lists, or objects.</syntax-note>
	<example>get the [[*]] of elements in steve</example>
	<example>get the [[*]] of words in bill</example>
	<example>get the [[*]] of andy</example>
	<description>
		For chunk expressions, the [[*]] function returns the number of chunks in a range.
	</description>
	<description>
		For lists, the [[*]] function returns the number of elements in a list.
	</description>
	<description>
		For objects, the [[*]] function returns the index of an object.
	</description>
	<see-also>[[pr:number]], [[fn:llength]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">numToChar</name>
	<syntax>the numToChar of {factor}</syntax>
	<syntax>numToChar({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield non-negative [[dt:integer]]s.</syntax-note>
	<example>put numToChar(67) into it -- yields C</example>
	<description>
		The [[*]] function returns the character whose equivalent value
		in the text encoding specified by the [[pr:textEncoding]] property
		is that of the [[dt:integer]] passed to it.
	</description>
	<note>
		In HyperTalk, [[numToChar(0)]] triggers a script error.
		In XION, [[numToChar(0)]] returns [[cn:null]].
	</note>
	<see-also>
		[[fn:binToChar]], [[fn:binToUni]], [[fn:charToBin]], [[fn:charToNum]],
		[[fn:numToUni]], [[fn:uniToBin]], [[fn:uniToNum]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">numToUni</name>
	<syntax>the numToUni of {factor}</syntax>
	<syntax>numToUni({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield non-negative [[dt:integer]]s.</syntax-note>
	<example>put numToUni(915) into it -- yields Γ</example>
	<description>
		The [[*]] function returns the character whose Unicode
		code point is that of the [[dt:integer]] passed to it.
	</description>
	<see-also>
		[[fn:binToChar]], [[fn:binToUni]], [[fn:charToBin]], [[fn:charToNum]],
		[[fn:numToChar]], [[fn:uniToBin]], [[fn:uniToNum]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">oct</name>
	<syntax>the oct of {factor}</syntax>
	<syntax>oct({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put oct(6789) into steve</example>
	<description>
		The [[*]] function converts a real or complex number in decimal,
		or base ten, to the same number in octal, or base eight. For example,
		[[oct(493)]] gives [["755"]].
	</description>
	<see-also>[[fn:bc]], [[fn:bin]], [[fn:hex]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">offset</name>
	<syntax>the offset of ({needle}, {haystack})</syntax>
	<syntax>offset({needle}, {haystack})</syntax>
	<syntax-note>{Haystack} and {needle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the index of the first appearance of
		the string {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csOffset]].
		For a regular expression-based version of this function, see [[fn:regOffset]].
	</description>
	<note>
		This function is similar to [[fn:instr]], but the arguments are in reverse order.
	</note>
	<see-also>
		[[fn:csOffset]], [[fn:regOffset]],
		[[fn:instr]], [[fn:csInstr]], [[fn:regInstr]],
		[[fn:rinstr]], [[fn:csRinstr]], [[fn:regRinstr]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">or</name>
	<syntax>the or of {factor}</syntax>
	<syntax>or({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:booleans]].</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if any of its arguments are [[cn:true]].
		If all arguments are [[cn:false]], it returns [[cn:false]].
	</description>
	<note>
		This is the infinite-arity version of the [[op:or]] operator.
	</note>
	<see-also>[[op:or]], [[op:|||]], [[fn:and]], [[fn:xor]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">param</name>
	<syntax>the param of {factor}</syntax>
	<syntax>param({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s.</syntax-note>
	<example>if param(1) is empty then answer¬\\  "The first parameter is null."</example>
	<description>
		The [[*]] function returns a parameter value from the parameter list
		passed to the currently executing handler. The parameter returned is the
		{n}th parameter, where {n} is the [[dt:integer]] passed to the function.
		The value of [[param(0)]] is the message name.
	</description>
	<script>
		The following example sums the arguments passed to it, regardless of
		how many there are. In other words, it is functionally equivalent to
		the [[fn:sum]] function:
		\\\\[[function addUp\\
		  put 0 into total\\
		  repeat with i = 1 to the paramCount\\
		    add param(i) to total\\
		  end repeat\\
		  return total\\
		end addUp]]
	</script>
	<see-also>[[fn:paramCount]], [[fn:params]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">paramCount</name>
	<syntax>the paramCount</syntax>
	<syntax>paramCount()</syntax>
	<example>if the paramCount &lt; 3 then ¬\\  put "I need at least three arguments."</example>
	<description>
		The [[*]] function returns the number of parameters passed
		to the currently executing handler.
	</description>
	<script>
		The following example multiplies the arguments passed to it,
		regardless of how many there are. In other words, it is functionally
		equivalent to the [[fn:product]] function:
		\\\\[[function theProduct\\
		  put 1 into total\\
		  repeat with i = 1 to the paramCount\\
		    multiply total by param(i)\\
		  end repeat\\
		  return total\\
		end theProduct]]
	</script>
	<see-also>[[fn:param]], [[fn:params]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">params</name>
	<syntax>the params</syntax>
	<syntax>params()</syntax>
	<example>put the params</example>
	<description>
		In XION, the [[*]] function returns a [[dt:list]] of the
		parameters passed to the currently executing handler, not
		including the message name. In other words, [[the params]]
		looks like:
		\\\\[[{parameter},{parameter},{parameter},...]]
	</description>
	<description>
		In HyperTalk, the [[*]] function returns a string containing
		the message name and the entire parameter list passed to the
		currently executing handler. The returned string is suitable
		for the [[cs:do]] keyword (if the handler is a message handler)
		or the [[fn:value]] function (if the handler is a function handler).
		In other words, [[the params]] looks like:
		\\\\[[{messageName} "{parameter}","{parameter}","{parameter}",...]]\\\\
		or:
		\\\\[[{functionName}("{parameter}","{parameter}","{parameter}",...)]]
	</description>
	<see-also>[[fn:param]], [[fn:paramCount]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">parent</name>
	<syntax>the parent of {factor}</syntax>
	<syntax>parent({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield an object with a parent.</syntax-note>
	<example>put the parent of char 3 of "Hello" -- yields "Hello"</example>
	<example>put the parent of file 1</example>
	<description>
		The [[*]] function returns the parent object of its argument.
		This is valid only for certain kinds of objects, such as
		chunks and file system objects. If the specified object does
		not have a parent, a script error is triggered.
	</description>
	<description>
		For chunks, the [[*]] function returns the container originally
		specified in the chunk expression.
	</description>
	<description>
		For [[dt:file]]s and [[dt:folder]]s, the [[*]] function returns
		the containing [[dt:folder]]. For [[dt:fork]]s, the [[*]] function
		returns the containing [[dt:file]].
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">pow</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<description>
		The [[*]] function returns the value of the power tower
		of the numeric values passed to it. For example,
		[[pow(4,3,2)]] evaluates to [[4^3^2]] or 262144.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		This is the infinite-arity version of the [[op:^]] operator.
	</note>
	<see-also>[[op:^]], [[fn:sum]], [[fn:product]], [[fn:root]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">prod</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">product</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>get [[*]](1,2,3,4)</example>
	<description>
		The [[*]] function returns the product of a list of numeric values passed to it.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		This is the infinite-arity version of the [[op:*]] operator.
	</note>
	<see-also>[[op:*]], [[fn:sum]], [[fn:pow]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">pstddev</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">stddev</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>get [[*]](1,2,3,4)</example>
	<description>
		The [[*]] function returns the population standard deviation of a list of numeric values passed to it.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:sstddev]], [[fn:variance]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">pvariance</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">variance</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>get [[*]](1,2,3,4)</example>
	<description>
		The [[*]] function returns the population variance of a list of numeric values passed to it.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:svariance]], [[fn:stddev]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">random</name>
	<syntax>the random of {factor}</syntax>
	<syntax>random({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s.</syntax-note>
	<description>
		The [[*]] function returns a random integer between 1
		and the specified [[dt:integer]], inclusive.
		If the specified [[dt:integer]] is less than 1,
		the [[*]] function always returns 1.
	</description>
	<script>
		The following example draws 10 unique random numbers between 1 and 100:
		\\\\[[on drawRandom\\
		  put empty into randomList\\
		  repeat until the number of items in randomList is 10\\
		    get random of 100\\
		    if (the itemdelimiter &amp; it &amp; the itemdelimiter) is not in ¬\\
		      (the itemdelimiter &amp; randomList &amp; the itemdelimiter) then\\
		      put it &amp; the itemdelimiter after randomList\\
		    end if\\
		  end repeat\\
		  delete last char of randomList\\
		  put randomList\\
		end drawRandom]]
	</script>
	<see-also>[[fn:randomDecimal]], [[fn:randomRange]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">randomDecimal</name>
	<syntax>the randomDecimal</syntax>
	<syntax>randomDecimal()</syntax>
	<description>
		The [[*]] function returns a random real number
		between zero, exclusive, and one, inclusive.
		That is, it is possible for the returned value
		to be one, but not zero.
	</description>
	<note>
		Most programming languages have a random number
		function that returns a number between zero, inclusive,
		and one, exclusive. That is, it is possible for
		the function to return zero, but not one. In XION,
		however, the [[*]] function can return one, but not
		zero. For the terminally curious, this is due to the
		implementation of a [[*]] function in KHyX, an
		extension stack for HyperCard; this also reflects
		the fact that the [[fn:random]] function can return
		the integer passed to it, but cannot return zero.
		To match the functionality of other languages,
		you can subtract the value returned from [[*]]
		from one.
	</note>
	<see-also>[[fn:random]], [[fn:randomRange]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">randomRange</name>
	<syntax>the randomRange of ({start}, {end})</syntax>
	<syntax>randomRange({start}, {end})</syntax>
	<syntax-note>{Start} and {end} yield [[dt:integer]]s.</syntax-note>
	<description>
		The [[*]] function returns a random integer between {start}
		and {end}, inclusive. If {end} is less than {start}, the
		[[*]] function always returns {start}.
	</description>
	<script>
		The following example draws 10 unique 3-digit random numbers:
		\\\\[[on drawRandom\\
		  put empty into randomList\\
		  repeat until the number of items in randomList is 10\\
		    get randomRange(100, 999)\\
		    if (the itemdelimiter &amp; it &amp; the itemdelimiter) is not in ¬\\
		      (the itemdelimiter &amp; randomList &amp; the itemdelimiter) then\\
		      put it &amp; the itemdelimiter after randomList\\
		    end if\\
		  end repeat\\
		  delete last char of randomList\\
		  put randomList\\
		end drawRandom]]
	</script>
	<see-also>[[fn:random]], [[fn:randomDecimal]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">Re</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		The [[*]] function returns the real part of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], the argument itself is returned.
	</description>
	<description>
		If the argument is a [[dt:complex]], the real part of the argument is returned as a [[dt:number]].
	</description>
	<see-also>[[fn:Im]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">replace</name>
	<syntax>the replace of ({haystack}, {needle}, {noodle})</syntax>
	<syntax>replace({haystack}, {needle}, {noodle})</syntax>
	<syntax-note>{Haystack}, {needle}, and {noodle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the string {haystack}
		with the first occurrence of the string {needle}
		replaced with the string {noodle}.
	</description>
	<description>
		{Needle} is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csReplace]].
		For a regular expression-based version of this function, see [[fn:regReplace]].
	</description>
	<see-also>[[fn:replaceAll]], [[fn:csReplace]], [[fn:regReplace]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">replaceAll</name>
	<syntax>the replaceAll of ({haystack}, {needle}, {noodle})</syntax>
	<syntax>replaceAll({haystack}, {needle}, {noodle})</syntax>
	<syntax-note>{Haystack}, {needle}, and {noodle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the string {haystack}
		with every occurrence of the string {needle}
		replaced with the string {noodle}.
	</description>
	<description>
		{Needle} is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csReplaceAll]].
		For a regular expression-based version of this function, see [[fn:regReplaceAll]].
	</description>
	<see-also>[[fn:replace]], [[fn:csReplaceAll]], [[fn:regReplaceAll]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">result</name>
	<syntax>the result</syntax>
	<syntax>result()</syntax>
	<example>if the result is not empty then answer "Try again."</example>
	<description>
		The [[*]] function returns the return value of the last command executed.
		Most built-in commands only set the [[*]] if the command was executed
		unsuccessfully; otherwise, the [[*]] is set to [[cn:empty]]. A user-defined
		command can set the [[*]] with a [[cs:return]] statement. The [[cm:answer]]
		and [[cm:ask]] commands use the [[*]] to tell the script if the user cancelled
		a prompt instead of choosing a proper response.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">reverse</name>
	<syntax>the reverse of {factor}</syntax>
	<syntax>reverse({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<example>put reverse("hello") -- yields "olleh"</example>
	<description>
		The [[*]] function returns the reversal of the specified [[dt:string]].
		The last character of the given [[dt:string]] becomes the first character
		of the resulting [[dt:string]], and vice versa.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">reverseBits</name>
	<syntax>the reverseBits of ({value}, {width})</syntax>
	<syntax>reverseBits({value}, {width})</syntax>
	<syntax-note>{Value} and {width} return [[dt:integer]]s.</syntax-note>
	<description>
		The [[*]] function returns the value obtained by reversing the bits
		of the two's complement representation of the specified {value}.
		{Width} is the number of bytes in the two's complement representation.
	</description>
	<see-also>[[fn:reverseBytes]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">reverseBytes</name>
	<syntax>the reverseBytes of ({value}, {width})</syntax>
	<syntax>reverseBytes({value}, {width})</syntax>
	<syntax-note>{Value} and {width} return [[dt:integer]]s.</syntax-note>
	<description>
		The [[*]] function returns the value obtained by reversing the bytes
		of the two's complement representation of the specified {value}.
		{Width} is the number of bytes in the two's complement representation.
	</description>
	<see-also>[[fn:reverseBits]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">right</name>
	<syntax>the right of ({string}, {length})</syntax>
	<syntax>right({string}, {length})</syntax>
	<syntax-note>{String} yields any [[dt:string]]. {Length} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] function returns the rightmost {length} characters of the specified {string}.
	</description>
	<note>
		If {length} is zero or negative, [[cn:empty]] is returned.
		If {length} is longer than the specified {string}, the original {string} is returned.
	</note>
	<see-also>[[fn:left]], [[fn:center]], [[fn:mid]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">rinstr</name>
	<syntax>the rinstr of ({haystack}, {needle})</syntax>
	<syntax>rinstr({haystack}, {needle})</syntax>
	<syntax-note>{Haystack} and {needle} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the index of the last appearance of
		the string {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csRinstr]].
		For a regular expression-based version of this function, see [[fn:regRinstr]].
	</description>
	<see-also>
		[[fn:csRinstr]], [[fn:regRinstr]],
		[[fn:instr]], [[fn:csInstr]], [[fn:regInstr]],
		[[fn:offset]], [[fn:csOffset]], [[fn:regOffset]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">rint</name>
	<syntax>the rint of {factor}</syntax>
	<syntax>rint({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put rint(steve) into bill</example>
	<description>
		The [[*]] function returns the given value rounded towards the nearest integer.
		If the given value is an [[dt:integer]], the given value is returned.
		Otherwise, the given value is rounded to the nearest integer.
		If the fractional part of the given value is exactly .5, the given value
		is rounded towards the nearest even number.
	</description>
	<description>
		The following table illustrates the behavior of the [[*]] function:\\\\
		::TABLE
		{{argument}} :: {{result}}
		..........................
		       2     ::   2
		..........................
		       1.75  ::   2
		..........................
		       1.5   ::   2
		..........................
		       1.25  ::   1
		..........................
		       1     ::   1
		..........................
		       0.75  ::   1
		..........................
		       0.5   ::   0
		..........................
		       0.25  ::   0
		..........................
		       0     ::   0
		..........................
		      -0.25  ::   0
		..........................
		      -0.5   ::   0
		..........................
		      -0.75  ::  -1
		..........................
		      -1     ::  -1
		..........................
		      -1.25  ::  -1
		..........................
		      -1.5   ::  -2
		..........................
		      -1.75  ::  -2
		..........................
		      -2     ::  -2
		ELBAT::
	</description>
	<description>
		If the given value is a [[dt:complex]], the real and imaginary
		parts of the complex number are each rounded individually.
	</description>
	<note>
		The following table shows the correspondences among the various
		{roundingMethod}s, rounding functions, and division operators:\\\\
		::TABLE
		{{[[rounding]] parameter}} :: {{function}} :: {{operator}}             :: {{[[java.math.RoundingMode]]}}
		........................................................................................................
		[[to ceiling]]             :: [[fn:ceil]]  ::                          :: [[CEILING]]
		........................................................................................................
		[[to floor]]               :: [[fn:floor]] :: [[op:div]] / [[op:mod]]  :: [[FLOOR]]
		........................................................................................................
		[[up]] / [[to infinity]]   :: [[fn:aug]]   ::                          :: [[UP]]
		........................................................................................................
		[[down]] / [[to zero]]     :: [[fn:trunc]] :: [[op:quot]] / [[op:rem]] :: [[DOWN]]
		........................................................................................................
		[[to nearest]]             :: [[fn:round]] ::                          :: [[HALF_UP]]
		........................................................................................................
		[[to even]]                :: [[fn:rint]]  ::                          :: [[HALF_EVEN]]
		ELBAT::
	</note>
	<note>
		The following table illustrates the behavior of the rounding functions side-by-side:\\\\
		::TABLE
		{{argument}} :: {{[[fn:ceil]]}}  :: {{[[fn:floor]]}} :: {{[[fn:aug]]}}   :: {{[[fn:trunc]]}} :: {{[[fn:round]]}} :: {{[[fn:rint]]}}
		...................................................................................................................................
		       2     ::   2              ::   2              ::   2              ::   2              ::   2              ::   2           
		...................................................................................................................................
		       1.75  ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.5   ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.25  ::   2              ::   1              ::   2              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       1     ::   1              ::   1              ::   1              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       0.75  ::   1              ::   0              ::   1              ::   0              ::   1              ::   1           
		...................................................................................................................................
		       0.5   ::   1              ::   0              ::   1              ::   0              ::   1              ::   0           
		...................................................................................................................................
		       0.25  ::   1              ::   0              ::   1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		       0     ::   0              ::   0              ::   0              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.25  ::   0              ::  -1              ::  -1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.5   ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::   0           
		...................................................................................................................................
		      -0.75  ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::  -1           
		...................................................................................................................................
		      -1     ::  -1              ::  -1              ::  -1              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.25  ::  -1              ::  -2              ::  -2              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.5   ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -1.75  ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -2     ::  -2              ::  -2              ::  -2              ::  -2              ::  -2              ::  -2           
		ELBAT::
	</note>
	<see-also>[[fn:ceil]], [[fn:floor]], [[fn:aug]], [[fn:trunc]], [[fn:round]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">rms</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>put [[*]](2,3,4) -- yields 3.109126</example>
	<description>
		The [[*]] function returns the root mean square, or the square root of the arithmetic mean of the squares, of its arguments.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">root</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<description>
		The [[*]] function returns the value of the nested radicals
		represented by the numeric values passed to it. For example,
		[[root(9,8,3)]] evaluates to [[9^(1/(8^(1/3)))]] or 3.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[op:^]], [[fn:pow]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">rot13</name>
	<syntax>the rot13 of {factor}</syntax>
	<syntax>rot13({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function returns the text passed to it enciphered
		(or deciphered) with the ROT13 substitution cipher. All a's
		in the text become n's, b's become o's, c's become p's, and
		so on and vice versa.
	</description>
	<description>
		In the following example, the punchline of the joke has been
		enciphered with ROT13:
		\\\\[[How can you tell an extrovert from an introvert at NSA? Va gur ryringbef, gur rkgebireg ybbxf ng gur BGURE thl'f fubrf.]]\\\\
		Applying the ROT13 function to this text enciphers the setup
		and deciphers the punchline:
		\\\\[[Ubj pna lbh gryy na rkgebireg sebz na vagebireg ng AFN? In the elevators, the extrovert looks at the OTHER guy's shoes.]]\\\\
		A further application of the ROT13 function will return the original text.
	</description>
	<note>
		The ROT13 cipher is often cited as an example of weak encryption.
		It offers no real security and should never be used for cryptographic purposes.
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">round</name>
	<syntax>the round of {factor}</syntax>
	<syntax>round({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put round(steve) into bill</example>
	<description>
		The [[*]] function returns the given value rounded towards the nearest integer.
		If the given value is an [[dt:integer]], the given value is returned.
		Otherwise, the given value is rounded to the nearest integer.
		If the fractional part of the given value is exactly .5, the given value
		is rounded towards unsigned infinity, or away from zero.
	</description>
	<description>
		The following table illustrates the behavior of the [[*]] function:\\\\
		::TABLE
		{{argument}} :: {{result}}
		..........................
		       2     ::   2
		..........................
		       1.75  ::   2
		..........................
		       1.5   ::   2
		..........................
		       1.25  ::   1
		..........................
		       1     ::   1
		..........................
		       0.75  ::   1
		..........................
		       0.5   ::   1
		..........................
		       0.25  ::   0
		..........................
		       0     ::   0
		..........................
		      -0.25  ::   0
		..........................
		      -0.5   ::  -1
		..........................
		      -0.75  ::  -1
		..........................
		      -1     ::  -1
		..........................
		      -1.25  ::  -1
		..........................
		      -1.5   ::  -2
		..........................
		      -1.75  ::  -2
		..........................
		      -2     ::  -2
		ELBAT::
	</description>
	<description>
		If the given value is a [[dt:complex]], the real and imaginary
		parts of the complex number are each rounded individually.
	</description>
	<note>
		The following table shows the correspondences among the various
		{roundingMethod}s, rounding functions, and division operators:\\\\
		::TABLE
		{{[[rounding]] parameter}} :: {{function}} :: {{operator}}             :: {{[[java.math.RoundingMode]]}}
		........................................................................................................
		[[to ceiling]]             :: [[fn:ceil]]  ::                          :: [[CEILING]]
		........................................................................................................
		[[to floor]]               :: [[fn:floor]] :: [[op:div]] / [[op:mod]]  :: [[FLOOR]]
		........................................................................................................
		[[up]] / [[to infinity]]   :: [[fn:aug]]   ::                          :: [[UP]]
		........................................................................................................
		[[down]] / [[to zero]]     :: [[fn:trunc]] :: [[op:quot]] / [[op:rem]] :: [[DOWN]]
		........................................................................................................
		[[to nearest]]             :: [[fn:round]] ::                          :: [[HALF_UP]]
		........................................................................................................
		[[to even]]                :: [[fn:rint]]  ::                          :: [[HALF_EVEN]]
		ELBAT::
	</note>
	<note>
		The following table illustrates the behavior of the rounding functions side-by-side:\\\\
		::TABLE
		{{argument}} :: {{[[fn:ceil]]}}  :: {{[[fn:floor]]}} :: {{[[fn:aug]]}}   :: {{[[fn:trunc]]}} :: {{[[fn:round]]}} :: {{[[fn:rint]]}}
		...................................................................................................................................
		       2     ::   2              ::   2              ::   2              ::   2              ::   2              ::   2           
		...................................................................................................................................
		       1.75  ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.5   ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.25  ::   2              ::   1              ::   2              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       1     ::   1              ::   1              ::   1              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       0.75  ::   1              ::   0              ::   1              ::   0              ::   1              ::   1           
		...................................................................................................................................
		       0.5   ::   1              ::   0              ::   1              ::   0              ::   1              ::   0           
		...................................................................................................................................
		       0.25  ::   1              ::   0              ::   1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		       0     ::   0              ::   0              ::   0              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.25  ::   0              ::  -1              ::  -1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.5   ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::   0           
		...................................................................................................................................
		      -0.75  ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::  -1           
		...................................................................................................................................
		      -1     ::  -1              ::  -1              ::  -1              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.25  ::  -1              ::  -2              ::  -2              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.5   ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -1.75  ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -2     ::  -2              ::  -2              ::  -2              ::  -2              ::  -2              ::  -2           
		ELBAT::
	</note>
	<see-also>[[fn:ceil]], [[fn:floor]], [[fn:aug]], [[fn:trunc]], [[fn:rint]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">rpad</name>
	<syntax>the rpad of ({string}, {length})</syntax>
	<syntax>the rpad of ({string}, {length}, {padding})</syntax>
	<syntax>rpad({string}, {length})</syntax>
	<syntax>rpad({string}, {length}, {padding})</syntax>
	<syntax-note>{String} and {padding} yield any [[dt:string]]s. {Length} yields an [[dt:integer]].</syntax-note>
	<description>
		The [[*]] function appends the specified {padding} to the specified
		{string} until the resulting string is longer than the specified {length},
		then returns the leftmost {length} characters of the resulting string.
		In other words, the string is padded on the right to be aligned to the
		left. If no {padding} is specified, spaces are used.
	</description>
	<note>
		If {length} is zero or negative, [[cn:empty]] is returned.
		If {length} is shorter than the specified {string}, only the
		leftmost {length} characters of the original {string} are returned.
	</note>
	<see-also>[[fn:lpad]], [[fn:cpad]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">rsr</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>put [[*]](2,3,6) -- yields 1</example>
	<description>
		The [[*]] function returns the reciprocal of the sum of the reciprocals of its arguments.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<description>
		One possible application of this function is in electronics.
		The [[fn:rsr]] of a list of resistances is equal to the equivalent resistance of resistors in parallel.
		The [[fn:rsr]] of a list of capacitances is equal to the equivalent capacitance of capacitors in series.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">rtrim</name>
	<syntax>the rtrim of {factor}</syntax>
	<syntax>rtrim({factor})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<example>put rtrim("  Hello, world!  ") -- yields "  Hello, world!"</example>
	<description>
		The [[*]] function trims all spaces, tabs, line breaks, control
		characters, line separators, and paragraph separators from the
		end of the given [[dt:string]] and returns the trimmed string.
	</description>
	<see-also>[[fn:trim]], [[fn:ltrim]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">sec</name>
	<syntax>the sec of {factor}</syntax>
	<syntax>sec({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the sec of 2 -- yields -2.402998</example>
	<description>
		The [[*]] function returns the secant of the angle that is passed to it.
		The angle must be expressed in radians.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		Radians can be converted to degrees with the [[fn:toDegrees]] function,
		or by multiplying by 180 and dividing by [[cn:pi]].
		Degrees can be converted to radians with the [[fn:toRadians]] function,
		or by multiplying by [[cn:pi]] and dividing by 180.
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">sech</name>
	<syntax>the sech of {factor}</syntax>
	<syntax>sech({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the sech of 2 -- yields 0.265802</example>
	<description>
		The [[*]] function returns the hyperbolic secant of the value that is passed to it.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">seconds</name>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">secs</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put (the seconds-startTime) into runTime</example>
	<description>
		The [[*]] function returns an integer representing the number
		of seconds since midnight, January 1, 1904, known as the
		Mac OS epoch.
	</description>
	<see-also>[[cm:convert]], [[fn:date]], [[fn:dateItems]], [[fn:ticks]], [[fn:time]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">sgn</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">signum</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<description>
		If its argument is an [[dt:integer]] or a [[dt:number]],
		the [[*]] function returns -1 if the specified numeric value is negative,
		1 if the specified numeric value is positive, 0 if the specified numeric
		value is zero, and [[cn:NaN]] if the specified numeric value is [[cn:NaN]].
	</description>
	<description>
		If its argument is a [[dt:complex]],
		the [[*]] function returns a [[dt:complex]] with the same complex argument
		but an absolute value of 1. For example, [[*]][[(3,4)]] returns [[0.6,0.8]].
	</description>
	<note>
		For nonzero values of {n}, [[*]][[({n}) = {n} / ]][[fn:abs]][[({n})]].
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">sin</name>
	<syntax>the sin of {factor}</syntax>
	<syntax>sin({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the sin of 2 -- yields 0.909297</example>
	<description>
		The [[*]] function returns the sine of the angle that is passed to it.
		The angle must be expressed in radians.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		Radians can be converted to degrees with the [[fn:toDegrees]] function,
		or by multiplying by 180 and dividing by [[cn:pi]].
		Degrees can be converted to radians with the [[fn:toRadians]] function,
		or by multiplying by [[cn:pi]] and dividing by 180.
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">sinh</name>
	<syntax>the sinh of {factor}</syntax>
	<syntax>sinh({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the sinh of 2 -- yields 3.626860</example>
	<description>
		The [[*]] function returns the hyperbolic sine of the value that is passed to it.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">sqrt</name>
	<syntax>the sqrt of {factor}</syntax>
	<syntax>sqrt({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put sqrt(opposite^2 + adjacent^2) into hypotenuse</example>
	<description>
		The [[fn:sqrt]] function returns the square root of its argument.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the [[dt:integer]] or [[dt:number]] is negative, [[cn:NaN]] is returned.
		To get a [[dt:complex]] result, convert the argument to a [[dt:complex]].
	</description>
	<description>
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:cbrt]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">sstddev</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>get [[*]](1,2,3,4)</example>
	<description>
		The [[*]] function returns the sample standard deviation of a list of numeric values passed to it.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:stddev]], [[fn:svariance]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">strcmp</name>
	<syntax>the strcmp of ({expression}, {expression})</syntax>
	<syntax>strcmp({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields a [[dt:string]].</syntax-note>
	<description>
		The [[fn:strcmp]] function compares the two given [[dt:string]]s by Unicode code point.
		If the first string comes before the second, a negative [[dt:integer]] is returned.
		If the first string comes after the second, a positive [[dt:integer]] is returned.
		If the two strings are equal, [[cn:zero]] is returned.
	</description>
	<description>
		The [[fn:strcmp]] function is case-insensitive.
		For a case-sensitive version of this function, see [[fn:csStrcmp]].
		For a regular expression-based version of this function, see [[fn:regMatch]].
	</description>
	<see-also>[[fn:csStrcmp]], [[fn:regMatch]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">substr</name>
	<syntax>the substr of ({string}, {offset})</syntax>
	<syntax>the substr of ({string}, {offset}, {length})</syntax>
	<syntax>substr({string}, {offset})</syntax>
	<syntax>substr({string}, {offset}, {length})</syntax>
	<syntax-note>{String} yields any [[dt:string]]. {Offset} and {length} yield [[dt:integer]]s.</syntax-note>
	<description>
		The [[*]] function returns {length} characters of the specified {string}
		starting at the specified {offset}. The first character of the string
		is at offset 1.
	</description>
	<description>
		If no {length} is specified, all characters of the string
		starting at the specified {offset} are returned.
	</description>
	<note>
		If {length} is zero or negative, or {offset} is greater than
		the length of the {string}, [[cn:empty]] is returned.
		If {offset} is zero or negative, the leftmost {length}+{offset}-1
		characters of the {string} are returned.
	</note>
	<see-also>[[fn:mid]], [[fn:substring]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">substring</name>
	<syntax>the substring of ({string}, {begin})</syntax>
	<syntax>the substring of ({string}, {begin}, {end})</syntax>
	<syntax>substring({string}, {begin})</syntax>
	<syntax>substring({string}, {begin}, {end})</syntax>
	<syntax-note>{String} yields any [[dt:string]]. {Begin} and {end} yield [[dt:integer]]s.</syntax-note>
	<description>
		The [[*]] function returns {end}-{begin} characters of the specified {string}
		starting at {begin}. The first character of the string is at offset 1.
	</description>
	<description>
		If no {end} is specified, all characters of the string
		starting at {begin} are returned.
	</description>
	<note>
		If {end} is less than or equal to {begin}, [[cn:empty]] is returned.
	</note>
	<see-also>[[fn:mid]], [[fn:substr]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">sum</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>get [[*]](1,2,3,4)</example>
	<description>
		The [[*]] function returns the sum of a list of numeric values passed to it.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		This is the infinite-arity version of the [[op:+]] operator.
	</note>
	<see-also>[[op:+]], [[fn:product]], [[fn:pow]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">svariance</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:integers]], [[dt:numbers]], or [[dt:complexes]].</syntax-note>
	<example>get [[*]](1,2,3,4)</example>
	<description>
		The [[*]] function returns the sample variance of a list of numeric values passed to it.
	</description>
	<description>
		If all the values are [[dt:integer]]s or [[dt:number]]s, a [[dt:number]] is returned.
		If any value is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<see-also>[[fn:variance]], [[fn:sstddev]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">systemName</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns the name of the operating system.
		You might use this to determine whether a script will run correctly
		under that operating system.
	</description>
	<note>
		OpenXION gets the value of this function from the [[os.name]] system property.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">systemVersion</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns the version of the operating system.
		You might use this to determine whether a script will run correctly
		under that version of the operating system.
	</description>
	<note>
		In HyperTalk, the resulting value of this function is a [[dt:number]].
		In XION, the resulting value of this function cannot be guaranteed
		to be anything other than a [[dt:string]].
	</note>
	<note>
		OpenXION gets the value of this function from the [[os.version]] system property.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">tail</name>
	<syntax>the tail of {factor}</syntax>
	<syntax>tail({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s.</syntax-note>
	<description>
		The [[*]] function returns all but the first element of a list.
	</description>
	<see-also>[[fn:head]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">tan</name>
	<syntax>the tan of {factor}</syntax>
	<syntax>tan({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the tan of 2 -- yields -2.185040</example>
	<description>
		The [[*]] function returns the tangent of the angle that is passed to it.
		The angle must be expressed in radians.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
	<note>
		Radians can be converted to degrees with the [[fn:toDegrees]] function,
		or by multiplying by 180 and dividing by [[cn:pi]].
		Degrees can be converted to radians with the [[fn:toRadians]] function,
		or by multiplying by [[cn:pi]] and dividing by 180.
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">tanh</name>
	<syntax>the tanh of {factor}</syntax>
	<syntax>tanh({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put the tanh of 2 -- yields 0.964027</example>
	<description>
		The [[*]] function returns the hyperbolic tangent of the value that is passed to it.
	</description>
	<description>
		If the argument is an [[dt:integer]] or a [[dt:number]], a [[dt:number]] is returned.
		If the argument is a [[dt:complex]], a [[dt:complex]] is returned.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">tcase</name>
	<syntax>the tcase of {factor}</syntax>
	<syntax>tcase({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function converts the specified [[dt:string]] to title case
		and returns the resulting [[dt:string]]. Letters are converted to
		lowercase if they are preceded by a letter, and converted to uppercase
		if they are preceded by a non-letter. For example,
		[[tcase("Hello, my name is Rebecca. But you can call me Beckie.")
		= "Hello, My Name Is Rebecca. But You Can Call Me Beckie."]].
	</description>
	<see-also>[[fn:ucase]], [[fn:lcase]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">theta</name>
	<syntax>the theta of ({expression}, {expression})</syntax>
	<syntax>theta({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]] or a [[dt:number]].</syntax-note>
	<example>put theta(bill, steve) into andy</example>
	<description>
		The [[fn:theta]] function returns the angle, in radians, of the specified
		coordinates from the positive x-axis. The first argument is the x coordinate,
		and the second argument is the y coordinate.
	</description>
	<note>
		This function is similar to the [[fn:atan2]] function, but the arguments are in opposite order.
		It is also similar to the [[fn:arg]] function, but it takes two arguments rather than one.
	</note>
	<see-also>[[fn:atan2]], [[fn:arg]], [[fn:xcoord]], [[fn:ycoord]], [[fn:radius]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">ticks</name>
	<syntax>the ticks</syntax>
	<syntax>ticks()</syntax>
	<example>put the ticks into dog</example>
	<description>
		The [[*]] function returns the number of ticks (sixtieths of a second)
		since an implementation-specific reference point in time.
	</description>
	<note>
		In HyperTalk, the reference point is the last time the computer
		was turned on or restarted. In OpenXION, the reference point is
		roughly the release date of the interpreter. The XION Scripting
		Language Standard states only that the reference point must remain
		constant during the same instance of the interpreter program.
	</note>
	<see-also>[[fn:date]], [[fn:dateItems]], [[fn:seconds]], [[fn:time]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">time</name>
	<syntax>the time</syntax>
	<syntax>the {modifier} time</syntax>
	<syntax>time()</syntax>
	<syntax-note>{Modifier} is [[kw:short]], [[kw:abbreviated]], [[kw:long]], or [[kw:English]]. The default is [[kw:short]].</syntax-note>
	<example>put the time</example>
	<description>
		The [[*]] function returns a [[dt:date]] representing the current time.
		There are three forms of the [[*]] function:\\\\
		::TABLE
		[[the short time]] or [[the abbrev time]] :: [[12.34 PM]]
		.................................
		[[the long time]] :: [[12.34.56 PM]]
		.................................
		[[the English time]] :: [[12:34:56 PM]]
		ELBAT::
	</description>
	<note>
		The format of the time is dependent on the current locale.
		This is important if you want to write scripts that work anywhere without modification.
		You cannot assume that the [[*]] function will always return a time in the same format.
	</note>
	<note>
		To prevent issues caused by differing local time formats, use the
		[[fn:seconds]] or the [[fn:dateItems]] to store and perform calculations
		with dates and times.
	</note>
	<see-also>[[cm:convert]], [[fn:date]], [[fn:dateItems]], [[fn:seconds]], [[fn:ticks]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">toDeg</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">toDegrees</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s or [[dt:number]]s.</syntax-note>
	<description>
		The [[*]] function returns the value passed to it converted from radians to degrees.
	</description>
	<description>
		The formula for this function is
		\\\\[[*]][[({angle}) = {angle} * 180 / pi]]\\\\
		The [[*]] function is faster, more accurate, and easier to remember than using the above formula.
	</description>
	<see-also>[[fn:toRadians]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">toRad</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">toRadians</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s or [[dt:number]]s.</syntax-note>
	<description>
		The [[*]] function returns the value passed to it converted from degrees to radians.
	</description>
	<description>
		The formula for this function is
		\\\\[[*]][[({angle}) = {angle} * pi / 180]]\\\\
		The [[*]] function is faster, more accurate, and easier to remember than using the above formula.
	</description>
	<see-also>[[fn:toDegrees]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">trim</name>
	<syntax>the trim of {factor}</syntax>
	<syntax>trim({factor})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<example>put trim("  Hello, world!  ") -- yields "Hello, world!"</example>
	<description>
		The [[*]] function trims all spaces, tabs, line breaks, control
		characters, line separators, and paragraph separators from the
		beginning and end of the given [[dt:string]] and returns the trimmed string.
	</description>
	<see-also>[[fn:ltrim]], [[fn:rtrim]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">trunc</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">int</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:integer]]s, [[dt:number]]s, or [[dt:complex]]es.</syntax-note>
	<example>put [[*]](steve) into bill</example>
	<description>
		The [[*]] function returns the given value rounded towards zero.
		If the given value is an [[dt:integer]], the given value is returned.
		Otherwise, the given value is rounded to the integer with the next lowest absolute value and the same sign.
		In other words, the [[*]] function returns the integer part of the given value,
		discarding the fractional part, regardless of sign.
	</description>
	<description>
		The following table illustrates the behavior of the [[*]] function:\\\\
		::TABLE
		{{argument}} :: {{result}}
		..........................
		       2     ::   2
		..........................
		       1.75  ::   1
		..........................
		       1.5   ::   1
		..........................
		       1.25  ::   1
		..........................
		       1     ::   1
		..........................
		       0.75  ::   0
		..........................
		       0.5   ::   0
		..........................
		       0.25  ::   0
		..........................
		       0     ::   0
		..........................
		      -0.25  ::   0
		..........................
		      -0.5   ::   0
		..........................
		      -0.75  ::   0
		..........................
		      -1     ::  -1
		..........................
		      -1.25  ::  -1
		..........................
		      -1.5   ::  -1
		..........................
		      -1.75  ::  -1
		..........................
		      -2     ::  -2
		ELBAT::
	</description>
	<description>
		If the given value is a [[dt:complex]], the real and imaginary
		parts of the complex number are each rounded individually.
	</description>
	<note>
		The following table shows the correspondences among the various
		{roundingMethod}s, rounding functions, and division operators:\\\\
		::TABLE
		{{[[rounding]] parameter}} :: {{function}} :: {{operator}}             :: {{[[java.math.RoundingMode]]}}
		........................................................................................................
		[[to ceiling]]             :: [[fn:ceil]]  ::                          :: [[CEILING]]
		........................................................................................................
		[[to floor]]               :: [[fn:floor]] :: [[op:div]] / [[op:mod]]  :: [[FLOOR]]
		........................................................................................................
		[[up]] / [[to infinity]]   :: [[fn:aug]]   ::                          :: [[UP]]
		........................................................................................................
		[[down]] / [[to zero]]     :: [[fn:trunc]] :: [[op:quot]] / [[op:rem]] :: [[DOWN]]
		........................................................................................................
		[[to nearest]]             :: [[fn:round]] ::                          :: [[HALF_UP]]
		........................................................................................................
		[[to even]]                :: [[fn:rint]]  ::                          :: [[HALF_EVEN]]
		ELBAT::
	</note>
	<note>
		The following table illustrates the behavior of the rounding functions side-by-side:\\\\
		::TABLE
		{{argument}} :: {{[[fn:ceil]]}}  :: {{[[fn:floor]]}} :: {{[[fn:aug]]}}   :: {{[[fn:trunc]]}} :: {{[[fn:round]]}} :: {{[[fn:rint]]}}
		...................................................................................................................................
		       2     ::   2              ::   2              ::   2              ::   2              ::   2              ::   2           
		...................................................................................................................................
		       1.75  ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.5   ::   2              ::   1              ::   2              ::   1              ::   2              ::   2           
		...................................................................................................................................
		       1.25  ::   2              ::   1              ::   2              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       1     ::   1              ::   1              ::   1              ::   1              ::   1              ::   1           
		...................................................................................................................................
		       0.75  ::   1              ::   0              ::   1              ::   0              ::   1              ::   1           
		...................................................................................................................................
		       0.5   ::   1              ::   0              ::   1              ::   0              ::   1              ::   0           
		...................................................................................................................................
		       0.25  ::   1              ::   0              ::   1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		       0     ::   0              ::   0              ::   0              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.25  ::   0              ::  -1              ::  -1              ::   0              ::   0              ::   0           
		...................................................................................................................................
		      -0.5   ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::   0           
		...................................................................................................................................
		      -0.75  ::   0              ::  -1              ::  -1              ::   0              ::  -1              ::  -1           
		...................................................................................................................................
		      -1     ::  -1              ::  -1              ::  -1              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.25  ::  -1              ::  -2              ::  -2              ::  -1              ::  -1              ::  -1           
		...................................................................................................................................
		      -1.5   ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -1.75  ::  -1              ::  -2              ::  -2              ::  -1              ::  -2              ::  -2           
		...................................................................................................................................
		      -2     ::  -2              ::  -2              ::  -2              ::  -2              ::  -2              ::  -2           
		ELBAT::
	</note>
	<see-also>[[fn:ceil]], [[fn:floor]], [[fn:aug]], [[fn:round]], [[fn:rint]], [[fn:frac]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">ucase</name>
	<syntax>the ucase of {factor}</syntax>
	<syntax>ucase({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function converts all the letters in the specified [[dt:string]]
		to uppercase and returns the resulting [[dt:string]]. For example,
		[[ucase("Hello, my name is Rebecca. But you can call me Beckie.")
		= "HELLO, MY NAME IS REBECCA. BUT YOU CAN CALL ME BECKIE."]].
	</description>
	<see-also>[[fn:tcase]], [[fn:lcase]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">uniToBin</name>
	<syntax>the uniToBin of {factor}</syntax>
	<syntax>uniToBin({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield a [[dt:string]].</syntax-note>
	<example>put the uniToBin of "αβ" -- yields "CEB1CEB2"</example>
	<description>
		The [[*]] function returns a [[dt:binary]] of the string
		passed to it encoded in the UTF-8 text encoding.
	</description>
	<see-also>
		[[fn:binToChar]], [[fn:binToUni]], [[fn:charToBin]], [[fn:charToNum]],
		[[fn:numToChar]], [[fn:numToUni]], [[fn:uniToNum]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">uniToNum</name>
	<syntax>the uniToNum of {factor}</syntax>
	<syntax>uniToNum({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield a character.</syntax-note>
	<example>put the uniToNum of "α" -- yields 945</example>
	<description>
		The [[*]] function returns the Unicode code point of the character passed to it.
	</description>
	<note>
		If more than one character is passed, [[*]] returns the value of the first character.
	</note>
	<see-also>
		[[fn:binToChar]], [[fn:binToUni]], [[fn:charToBin]], [[fn:charToNum]],
		[[fn:numToChar]], [[fn:numToUni]], [[fn:uniToBin]]
	</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">value</name>
	<syntax>the value of {factor}</syntax>
	<syntax>value({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield any [[dt:string]].</syntax-note>
	<example>put the value of myFormula into myResult</example>
	<description>
		The [[*]] function evaluates the string passed to it
		as an XION expression. The string is evaluated as if it were
		inserted inside parentheses in place of the [[*]] function call.
	</description>
	<description>
		If the string does not form a single valid expression,
		the string itself is returned.
	</description>
	<script>
		The following example demonstrates the [[*]] function:
		\\\\[[on demoValue\\
		  put "3 + 4" into expression\\
		  put expression -- yields "3 + 4"\\
		  put the value of expression -- yields 7\\
		end demoValue]]
	</script>
	<security>
		To evaluate arbitrary XION expressions with this function,
		OpenXION's security settings must allow the [[DO_AND_VALUE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cs:do]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">version</name>
	<syntax>the version of {factor}</syntax>
	<syntax>version({expression})</syntax>
	<syntax-note>
		{Factor} and {expression} yield some object or the name of some component
		that has a version number.
	</syntax-note>
	<description>
		The [[*]] function returns the version number of an object
		or component.
	</description>
	<security>
		To use this function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">xcoord</name>
	<syntax>the [[*]] of ({expression}, {expression})</syntax>
	<syntax>[[*]]({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]] or a [[dt:number]].</syntax-note>
	<description>
		The [[*]] function returns the x coordinate of the specified polar coordinates.
		The first argument is the distance from the origin and the second argument
		is the angle from the positive x-axis in radians.
	</description>
	<description>
		The formula for the [[*]] function is
		\\\\[[*]][[({r}, {th}) = {r} * cos({th})]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<see-also>[[fn:ycoord]], [[fn:radius]], [[fn:theta]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">xionName</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns the name of the XION interpreter.
		You might use this to determine whether a script will run correctly
		under that interpreter.
	</description>
	<note>
		OpenXION returns the [[dt:string]] [["OpenXION"]].
	</note>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">xionVersion</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns the version of the XION interpreter.
		You might use this to determine whether a script will run correctly
		under that version of the interpreter.
	</description>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">xor</name>
	<syntax>the xor of {factor}</syntax>
	<syntax>xor({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:list]]s of [[dt:booleans]].</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if and only if an odd number of its arguments are [[cn:true]].
		If an even number of arguments are [[cn:true]], it returns [[cn:false]].
	</description>
	<note>
		This is the infinite-arity version of the [[op:xor]] operator.
	</note>
	<see-also>[[op:xor]], [[op:^^^]], [[fn:and]], [[fn:or]]</see-also>
</function>

<function>
	<name dialects="xn1,oxn1,oxn11,oxn12">ycoord</name>
	<syntax>the [[*]] of ({expression}, {expression})</syntax>
	<syntax>[[*]]({expression}, {expression})</syntax>
	<syntax-note>{Expression} yields an [[dt:integer]] or a [[dt:number]].</syntax-note>
	<description>
		The [[*]] function returns the y coordinate of the specified polar coordinates.
		The first argument is the distance from the origin and the second argument
		is the angle from the positive x-axis in radians.
	</description>
	<description>
		The formula for the [[*]] function is
		\\\\[[*]][[({r}, {th}) = {r} * sin({th})]]\\\\
		The [[*]] function is faster and more accurate than using the above formula.
	</description>
	<see-also>[[fn:xcoord]], [[fn:radius]], [[fn:theta]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12,hyp">heapSpace</name>
	<syntax>the heapSpace</syntax>
	<syntax>heapSpace()</syntax>
	<example>put the heapSpace into heapOFun</example>
	<description>
		In OpenXION, the [[*]] function returns the number of bytes
		of heap space currently available to the Java virtual machine.
	</description>
	<description>
		In HyperTalk, the [[*]] function returns the number of bytes
		of heap space currently available to HyperCard.
	</description>
	<security>
		To use this function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">htmlDecode</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function decodes any HTML entities in the specified string
		and returns the decoded string.
	</description>
	<description>
		The [[*]] function recognizes the sequences [[&amp;#{dec};]]
		and [[&amp;#x{hex};]] where {dec} is a decimal integer and {hex}
		is a hexadecimal integer representing a Unicode code point, as
		well as the following named sequences:
		\\\\
		::TABLE
		[[&amp;amp;]]      :: &amp;    :: [[&amp;Ucirc;]]    :: &#x00DB; :: [[&amp;Upsilon;]]  :: &#x03A5; :: [[&amp;alefsym;]]  :: &#x2135;
		....................................................................................................................................
		[[&amp;lt;]]       :: &lt;     :: [[&amp;Uuml;]]     :: &#x00DC; :: [[&amp;Phi;]]      :: &#x03A6; :: [[&amp;larr;]]     :: &#x2190;
		....................................................................................................................................
		[[&amp;gt;]]       :: &gt;     :: [[&amp;Yacute;]]   :: &#x00DD; :: [[&amp;Chi;]]      :: &#x03A7; :: [[&amp;uarr;]]     :: &#x2191;
		....................................................................................................................................
		[[&amp;quot;]]     :: &quot;   :: [[&amp;THORN;]]    :: &#x00DE; :: [[&amp;Psi;]]      :: &#x03A8; :: [[&amp;rarr;]]     :: &#x2192;
		....................................................................................................................................
		[[&amp;apos;]]     :: &apos;   :: [[&amp;szlig;]]    :: &#x00DF; :: [[&amp;Omega;]]    :: &#x03A9; :: [[&amp;darr;]]     :: &#x2193;
		....................................................................................................................................
		[[&amp;nbsp;]]     :: &#x00A0; :: [[&amp;agrave;]]   :: &#x00E0; :: [[&amp;alpha;]]    :: &#x03B1; :: [[&amp;harr;]]     :: &#x2194;
		....................................................................................................................................
		[[&amp;iexcl;]]    :: &#x00A1; :: [[&amp;aacute;]]   :: &#x00E1; :: [[&amp;beta;]]     :: &#x03B2; :: [[&amp;crarr;]]    :: &#x21B5;
		....................................................................................................................................
		[[&amp;cent;]]     :: &#x00A2; :: [[&amp;acirc;]]    :: &#x00E2; :: [[&amp;gamma;]]    :: &#x03B3; :: [[&amp;lArr;]]     :: &#x21D0;
		....................................................................................................................................
		[[&amp;pound;]]    :: &#x00A3; :: [[&amp;atilde;]]   :: &#x00E3; :: [[&amp;delta;]]    :: &#x03B4; :: [[&amp;uArr;]]     :: &#x21D1;
		....................................................................................................................................
		[[&amp;curren;]]   :: &#x00A4; :: [[&amp;auml;]]     :: &#x00E4; :: [[&amp;epsilon;]]  :: &#x03B5; :: [[&amp;rArr;]]     :: &#x21D2;
		....................................................................................................................................
		[[&amp;yen;]]      :: &#x00A5; :: [[&amp;aring;]]    :: &#x00E5; :: [[&amp;zeta;]]     :: &#x03B6; :: [[&amp;dArr;]]     :: &#x21D3;
		....................................................................................................................................
		[[&amp;brvbar;]]   :: &#x00A6; :: [[&amp;aelig;]]    :: &#x00E6; :: [[&amp;eta;]]      :: &#x03B7; :: [[&amp;hArr;]]     :: &#x21D4;
		....................................................................................................................................
		[[&amp;sect;]]     :: &#x00A7; :: [[&amp;ccedil;]]   :: &#x00E7; :: [[&amp;theta;]]    :: &#x03B8; :: [[&amp;forall;]]   :: &#x2200;
		....................................................................................................................................
		[[&amp;uml;]]      :: &#x00A8; :: [[&amp;egrave;]]   :: &#x00E8; :: [[&amp;iota;]]     :: &#x03B9; :: [[&amp;part;]]     :: &#x2202;
		....................................................................................................................................
		[[&amp;copy;]]     :: &#x00A9; :: [[&amp;eacute;]]   :: &#x00E9; :: [[&amp;kappa;]]    :: &#x03BA; :: [[&amp;exist;]]    :: &#x2203;
		....................................................................................................................................
		[[&amp;ordf;]]     :: &#x00AA; :: [[&amp;ecirc;]]    :: &#x00EA; :: [[&amp;lambda;]]   :: &#x03BB; :: [[&amp;empty;]]    :: &#x2205;
		....................................................................................................................................
		[[&amp;laquo;]]    :: &#x00AB; :: [[&amp;euml;]]     :: &#x00EB; :: [[&amp;mu;]]       :: &#x03BC; :: [[&amp;nabla;]]    :: &#x2207;
		....................................................................................................................................
		[[&amp;not;]]      :: &#x00AC; :: [[&amp;igrave;]]   :: &#x00EC; :: [[&amp;nu;]]       :: &#x03BD; :: [[&amp;isin;]]     :: &#x2208;
		....................................................................................................................................
		[[&amp;shy;]]      :: &#x00AD; :: [[&amp;iacute;]]   :: &#x00ED; :: [[&amp;xi;]]       :: &#x03BE; :: [[&amp;notin;]]    :: &#x2209;
		....................................................................................................................................
		[[&amp;reg;]]      :: &#x00AE; :: [[&amp;icirc;]]    :: &#x00EE; :: [[&amp;omicron;]]  :: &#x03BF; :: [[&amp;ni;]]       :: &#x220B;
		....................................................................................................................................
		[[&amp;macr;]]     :: &#x00AF; :: [[&amp;iuml;]]     :: &#x00EF; :: [[&amp;pi;]]       :: &#x03C0; :: [[&amp;prod;]]     :: &#x220F;
		....................................................................................................................................
		[[&amp;deg;]]      :: &#x00B0; :: [[&amp;eth;]]      :: &#x00F0; :: [[&amp;rho;]]      :: &#x03C1; :: [[&amp;sum;]]      :: &#x2211;
		....................................................................................................................................
		[[&amp;plusmn;]]   :: &#x00B1; :: [[&amp;ntilde;]]   :: &#x00F1; :: [[&amp;sigmaf;]]   :: &#x03C2; :: [[&amp;minus;]]    :: &#x2212;
		....................................................................................................................................
		[[&amp;sup2;]]     :: &#x00B2; :: [[&amp;ograve;]]   :: &#x00F2; :: [[&amp;sigma;]]    :: &#x03C3; :: [[&amp;lowast;]]   :: &#x2217;
		....................................................................................................................................
		[[&amp;sup3;]]     :: &#x00B3; :: [[&amp;oacute;]]   :: &#x00F3; :: [[&amp;tau;]]      :: &#x03C4; :: [[&amp;radic;]]    :: &#x221A;
		....................................................................................................................................
		[[&amp;acute;]]    :: &#x00B4; :: [[&amp;ocirc;]]    :: &#x00F4; :: [[&amp;upsilon;]]  :: &#x03C5; :: [[&amp;prop;]]     :: &#x221D;
		....................................................................................................................................
		[[&amp;micro;]]    :: &#x00B5; :: [[&amp;otilde;]]   :: &#x00F5; :: [[&amp;phi;]]      :: &#x03C6; :: [[&amp;infin;]]    :: &#x221E;
		....................................................................................................................................
		[[&amp;para;]]     :: &#x00B6; :: [[&amp;ouml;]]     :: &#x00F6; :: [[&amp;chi;]]      :: &#x03C7; :: [[&amp;ang;]]      :: &#x2220;
		....................................................................................................................................
		[[&amp;middot;]]   :: &#x00B7; :: [[&amp;divide;]]   :: &#x00F7; :: [[&amp;psi;]]      :: &#x03C8; :: [[&amp;and;]]      :: &#x2227;
		....................................................................................................................................
		[[&amp;cedil;]]    :: &#x00B8; :: [[&amp;oslash;]]   :: &#x00F8; :: [[&amp;omega;]]    :: &#x03C9; :: [[&amp;or;]]       :: &#x2228;
		....................................................................................................................................
		[[&amp;sup1;]]     :: &#x00B9; :: [[&amp;ugrave;]]   :: &#x00F9; :: [[&amp;thetasym;]] :: &#x03D1; :: [[&amp;cap;]]      :: &#x2229;
		....................................................................................................................................
		[[&amp;ordm;]]     :: &#x00BA; :: [[&amp;uacute;]]   :: &#x00FA; :: [[&amp;upsih;]]    :: &#x03D2; :: [[&amp;cup;]]      :: &#x222A;
		....................................................................................................................................
		[[&amp;raquo;]]    :: &#x00BB; :: [[&amp;ucirc;]]    :: &#x00FB; :: [[&amp;piv;]]      :: &#x03D6; :: [[&amp;int;]]      :: &#x222B;
		....................................................................................................................................
		[[&amp;frac14;]]   :: &#x00BC; :: [[&amp;uuml;]]     :: &#x00FC; :: [[&amp;ensp;]]     :: &#x2002; :: [[&amp;there4;]]   :: &#x2234;
		....................................................................................................................................
		[[&amp;frac12;]]   :: &#x00BD; :: [[&amp;yacute;]]   :: &#x00FD; :: [[&amp;emsp;]]     :: &#x2003; :: [[&amp;sim;]]      :: &#x223C;
		....................................................................................................................................
		[[&amp;frac34;]]   :: &#x00BE; :: [[&amp;thorn;]]    :: &#x00FE; :: [[&amp;thinsp;]]   :: &#x2009; :: [[&amp;cong;]]     :: &#x2245;
		....................................................................................................................................
		[[&amp;iquest;]]   :: &#x00BF; :: [[&amp;yuml;]]     :: &#x00FF; :: [[&amp;zwnj;]]     :: &#x200C; :: [[&amp;asymp;]]    :: &#x2248;
		....................................................................................................................................
		[[&amp;Agrave;]]   :: &#x00C0; :: [[&amp;OElig;]]    :: &#x0152; :: [[&amp;zwj;]]      :: &#x200D; :: [[&amp;ne;]]       :: &#x2260;
		....................................................................................................................................
		[[&amp;Aacute;]]   :: &#x00C1; :: [[&amp;oelig;]]    :: &#x0153; :: [[&amp;lrm;]]      :: &#x200E; :: [[&amp;equiv;]]    :: &#x2261;
		....................................................................................................................................
		[[&amp;Acirc;]]    :: &#x00C2; :: [[&amp;Scaron;]]   :: &#x0160; :: [[&amp;rlm;]]      :: &#x200F; :: [[&amp;le;]]       :: &#x2264;
		....................................................................................................................................
		[[&amp;Atilde;]]   :: &#x00C3; :: [[&amp;scaron;]]   :: &#x0161; :: [[&amp;ndash;]]    :: &#x2013; :: [[&amp;ge;]]       :: &#x2265;
		....................................................................................................................................
		[[&amp;Auml;]]     :: &#x00C4; :: [[&amp;Yuml;]]     :: &#x0178; :: [[&amp;mdash;]]    :: &#x2014; :: [[&amp;sub;]]      :: &#x2282;
		....................................................................................................................................
		[[&amp;Aring;]]    :: &#x00C5; :: [[&amp;fnof;]]     :: &#x0192; :: [[&amp;lsquo;]]    :: &#x2018; :: [[&amp;sup;]]      :: &#x2283;
		....................................................................................................................................
		[[&amp;AElig;]]    :: &#x00C6; :: [[&amp;circ;]]     :: &#x02C6; :: [[&amp;rsquo;]]    :: &#x2019; :: [[&amp;nsub;]]     :: &#x2284;
		....................................................................................................................................
		[[&amp;Ccedil;]]   :: &#x00C7; :: [[&amp;tilde;]]    :: &#x02DC; :: [[&amp;sbquo;]]    :: &#x201A; :: [[&amp;sube;]]     :: &#x2286;
		....................................................................................................................................
		[[&amp;Egrave;]]   :: &#x00C8; :: [[&amp;Alpha;]]    :: &#x0391; :: [[&amp;ldquo;]]    :: &#x201C; :: [[&amp;supe;]]     :: &#x2287;
		....................................................................................................................................
		[[&amp;Eacute;]]   :: &#x00C9; :: [[&amp;Beta;]]     :: &#x0392; :: [[&amp;rdquo;]]    :: &#x201D; :: [[&amp;oplus;]]    :: &#x2295;
		....................................................................................................................................
		[[&amp;Ecirc;]]    :: &#x00CA; :: [[&amp;Gamma;]]    :: &#x0393; :: [[&amp;bdquo;]]    :: &#x201E; :: [[&amp;otimes;]]   :: &#x2297;
		....................................................................................................................................
		[[&amp;Euml;]]     :: &#x00CB; :: [[&amp;Delta;]]    :: &#x0394; :: [[&amp;dagger;]]   :: &#x2020; :: [[&amp;perp;]]     :: &#x22A5;
		....................................................................................................................................
		[[&amp;Igrave;]]   :: &#x00CC; :: [[&amp;Epsilon;]]  :: &#x0395; :: [[&amp;Dagger;]]   :: &#x2021; :: [[&amp;sdot;]]     :: &#x22C5;
		....................................................................................................................................
		[[&amp;Iacute;]]   :: &#x00CD; :: [[&amp;Zeta;]]     :: &#x0396; :: [[&amp;bull;]]     :: &#x2022; :: [[&amp;lceil;]]    :: &#x2308;
		....................................................................................................................................
		[[&amp;Icirc;]]    :: &#x00CE; :: [[&amp;Eta;]]      :: &#x0397; :: [[&amp;hellip;]]   :: &#x2026; :: [[&amp;rceil;]]    :: &#x2309;
		....................................................................................................................................
		[[&amp;Iuml;]]     :: &#x00CF; :: [[&amp;Theta;]]    :: &#x0398; :: [[&amp;permil;]]   :: &#x2030; :: [[&amp;lfloor;]]   :: &#x230A;
		....................................................................................................................................
		[[&amp;ETH;]]      :: &#x00D0; :: [[&amp;Iota;]]     :: &#x0399; :: [[&amp;prime;]]    :: &#x2032; :: [[&amp;rfloor;]]   :: &#x230B;
		....................................................................................................................................
		[[&amp;Ntilde;]]   :: &#x00D1; :: [[&amp;Kappa;]]    :: &#x039A; :: [[&amp;Prime;]]    :: &#x2033; :: [[&amp;lang;]]     :: &#x2329;
		....................................................................................................................................
		[[&amp;Ograve;]]   :: &#x00D2; :: [[&amp;Lambda;]]   :: &#x039B; :: [[&amp;lsaquo;]]   :: &#x2039; :: [[&amp;rang;]]     :: &#x232A;
		....................................................................................................................................
		[[&amp;Oacute;]]   :: &#x00D3; :: [[&amp;Mu;]]       :: &#x039C; :: [[&amp;rsaquo;]]   :: &#x203A; :: [[&amp;loz;]]      :: &#x25CA;
		....................................................................................................................................
		[[&amp;Ocirc;]]    :: &#x00D4; :: [[&amp;Nu;]]       :: &#x039D; :: [[&amp;oline;]]    :: &#x203E; :: [[&amp;spades;]]   :: &#x2660;
		....................................................................................................................................
		[[&amp;Otilde;]]   :: &#x00D5; :: [[&amp;Xi;]]       :: &#x039E; :: [[&amp;frasl;]]    :: &#x2044; :: [[&amp;clubs;]]    :: &#x2663;
		....................................................................................................................................
		[[&amp;Ouml;]]     :: &#x00D6; :: [[&amp;Omicron;]]  :: &#x039F; :: [[&amp;euro;]]     :: &#x20AC; :: [[&amp;hearts;]]   :: &#x2665;
		....................................................................................................................................
		[[&amp;times;]]    :: &#x00D7; :: [[&amp;Pi;]]       :: &#x03A0; :: [[&amp;image;]]    :: &#x2111; :: [[&amp;diams;]]    :: &#x2666;
		....................................................................................................................................
		[[&amp;Oslash;]]   :: &#x00D8; :: [[&amp;Rho;]]      :: &#x03A1; :: [[&amp;weierp;]]   :: &#x2118; ::                    ::         
		....................................................................................................................................
		[[&amp;Ugrave;]]   :: &#x00D9; :: [[&amp;Sigma;]]    :: &#x03A3; :: [[&amp;real;]]     :: &#x211C; ::                    ::         
		....................................................................................................................................
		[[&amp;Uacute;]]   :: &#x00DA; :: [[&amp;Tau;]]      :: &#x03A4; :: [[&amp;trade;]]    :: &#x2122; ::                    ::         
		ELBAT::
	</description>
	<see-also>[[fn:htmlEncode]], [[fn:urlEncode]], [[fn:urlDecode]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">htmlEncode</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function encodes XML tag characters, control characters,
		and non-ASCII characters in the specified string as HTML entities
		and returns the encoded string.
	</description>
	<description>
		The characters [[&amp;]], [[&lt;]], [[&gt;]], [[&quot;]], [[&#39;]],
		and non-breaking space are encoded as [[&amp;amp;]], [[&amp;lt;]],
		[[&amp;gt;]], [[&amp;quot;]], [[&amp;#39;]], and [[&amp;nbsp;]],
		respectively. Control characters and non-ASCII characters are encoded
		as [[&amp;#{codepoint};]] where {codepoint} is the decimal integer
		representing that character's Unicode code point.
	</description>
	<see-also>[[fn:htmlDecode]], [[fn:urlEncode]], [[fn:urlDecode]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">javaName</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns the name of the Java runtime environment.
		You might use this to determine whether a script will run correctly
		under that runtime environment.
	</description>
	<note>
		OpenXION gets the value of this function from the [[java.name]] system property.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">javaVersion</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns the version of the Java runtime environment.
		You might use this to determine whether a script will run correctly
		under that version of the runtime environment.
	</description>
	<note>
		OpenXION gets the value of this function from the [[java.version]] system property.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</function>

<function>
	<name dialects="oxne12">pack</name>
	<syntax>the pack of ({format}, {value}, {value}, {...})</syntax>
	<syntax>pack({format}, {value}, {value}, {...})</syntax>
	<syntax-note>
		{Format} yields a [[dt:string]] describing a binary data structure.
		{Value} yields an appropriate [[dt:variant]] for the corresponding field.
	</syntax-note>
	<description>
		The [[*]] function packs the given {value}s into a [[dt:binary]] according
		to the binary data structure specified by {format}. It is inspired by the
		[[pack]] functions in Perl and PHP, but has a much more powerful syntax.
	</description>
	<description>
		The {format} string can be specified in one of two ways.
		Using the short format, each field in the binary data structure is specified
		using the following syntax:
		\\\\
		{type} {size} {elaboration} {count} {name} {description}
		\\\\
		Only {type} is required. The {type} is a single character from the table below.
		Uppercase indicates big-endian values, and lowercase indicates little-endian values.
		The {size} is the number of bits. The {elaboration} is a type-specific string that must
		be enclosed in braces; for further details, see the table below. If a {count} is specified,
		the unpacked {value} is a [[dt:list]], and the {count} must be a number enclosed in brackets
		indicating the number of elements in the list; otherwise, the unpacked {value} is a
		single value. (Except for the [[ * ]] and [[ @ ]] types, where the {count} is the number of
		bytes and the offset, respectively.) The {name} is a string enclosed in backticks ([[`]]).
		The {description} is a string enclosed in quotes. The {name} and {description} have no effect
		on the packing or unpacking of the data. Whitespace in the format string is ignored
		except for inside quotes and as a token separator.
	</description>
	<description>
		Using the long format, each field in the binary data structure is specified
		using the following syntax:
		\\\\
		{type} {size} {endianness} {elaboration} {count} {name} {description} [[;]]
		\\\\
		Only {type} is required. The {type} is a type name from the table below. The {size}
		is the number of bits. The {endianness} is [[be]] for big-endian or [[le]] for little-endian;
		if {endianness} is not specified, big-endian is assumed. The {elaboration} is a type-specific
		string that must be enclosed in braces; for further details, see the table below. If a {count}
		is specified, the unpacked {value} is a [[dt:list]], and the {count} must be a number
		enclosed in brackets indicating the number of elements in the list; otherwise, the unpacked
		{value} is a single value. (Except for the [[binary]] and [[offset]] types, where the {count} is
		the number of bytes and the offset, respectively.) The {name} is either a sequence of alphanumeric
		characters, or a string enclosed in backticks ([[`]]). The {description} is a string enclosed in
		quotes, or any sequence of characters following the name and preceding the terminating semicolon.
		The {name} and {description} have no effect on the packing or unpacking of the data.
		Whitespace in the format string is ignored except for inside quotes and as a token separator.
	</description>
	<description>
		The possible field {type}s are:
		\\\\
		::TABLE
		[[T]], [[t]] :: [[bool]], [[boolean]] ::
		A boolean value ([[T]] for "truth value"). The unpacked {value} is [[cn:false]] for a packed value of zero
		or [[cn:true]] for a packed value of one (or any other value when unpacking).
		........
		[[E]], [[e]] :: [[enum]] ::
		An enumeration. The {elaboration} is a list of key-value pairs, delimited by semicolons, with the key and value separated by an equals sign.
		Each key is an integer representing a possible packed value and each value is a string. The unpacked {value} is one of those strings.
		........
		[[J]], [[j]] :: [[bitfield]] ::
		A bit field ([[J]] for "jumper"). The {elaboration} is a list of key-value pairs, delimited by semicolons, with the key and value separated by an equals sign.
		Each key is an integer representing a bit in the packed value (from 0 for the least-significant bit to {size-1} for the most-significant bit)
		and each value is a string. The unpacked {value} is a comma-delimited list of such strings.
		........
		[[B]], [[b]] :: [[bint]] ::
		An unsigned integer in binary. The unpacked {value} is a [[dt:string]] of binary digits.
		........
		[[O]], [[o]] :: [[oint]] ::
		An unsigned integer in octal. The unpacked {value} is a [[dt:string]] of octal digits.
		........
		[[H]], [[h]] :: [[hint]] ::
		An unsigned integer in hexadecimal. The unpacked {value} is a [[dt:string]] of hexadecimal digits.
		........
		[[U]], [[u]] :: [[uint]] ::
		An unsigned integer. The unpacked {value} is an [[dt:integer]].
		........
		[[I]], [[i]] :: [[int]], [[sint]] ::
		A signed integer. The unpacked {value} is an [[dt:integer]].
		........
		[[R]], [[r]] :: [[ufixed]] ::
		An unsigned fixed-point number ([[R]] for "ratio"). The radix point is fixed in the center of the packed value (e.g., at bit 8 if the {size} is 16).
		The unpacked {value} is a [[dt:number]].
		........
		[[Q]], [[q]] :: [[fixed]], [[sfixed]] ::
		A signed fixed-point number ([[Q]] for "quotient"). The radix point is fixed in the center of the packed value (e.g., at bit 8 if the {size} is 16).
		The unpacked {value} is a [[dt:number]].
		........
		[[F]], [[f]] :: [[float]] ::
		A floating-point number. The {elaboration} is the number of sign bits, the number of exponent bits, the number of mantissa bits,
		and the exponent bias, separated by periods. If the {elaboration} is not specified, a best guess is made at the appropriate number
		of bits and the appropriate bias based on the {size}. For {size}s of 16, 32, 64, and 128 bits, this "best guess" is guaranteed to be
		[[1.5.10.15]], [[1.8.23.127]], [[1.11.52.1023]], and [[1.15.112.16383]], respectively, corresponding to IEEE half-, single-, double-,
		and quad-precision floating-point numbers. The unpacked {value} is a [[dt:number]].
		........
		[[K]], [[k]] :: [[complex]] ::
		A complex number, composed of two floating-point numbers (the real part followed by the imaginary part). The {size} is the number
		of bits per part, rather than total. The {elaboration} is the same as for [[float]] above. The unpacked {value} is a [[dt:complex]].
		........
		[[C]], [[c]] :: [[char]], [[character]] ::
		A character constant. The {size} must be a multiple of 8.
		The {elaboration} is the name of a text encoding. If the {elaboration} is unspecified, [[ISO-8859-1]] is assumed.
		The unpacked {value} is a [[dt:string]].
		........
		[[P]], [[p]] :: [[pstring]] ::
		A Pascal-style string. The {size} is the number of bits in the count preceding the actual string data.
		The {elaboration} is the name of a text encoding. If the {elaboration} is unspecified, [[ISO-8859-1]] is assumed.
		The unpacked {value} is a [[dt:string]].
		........
		[[S]], [[s]] :: [[string]], [[cstring]] ::
		A C-style string. The {size} is the number of zero bits following the actual string data and must be a multiple of 8.
		The {elaboration} is the name of a text encoding. If the {elaboration} is unspecified, [[ISO-8859-1]] is assumed.
		The unpacked {value} is a [[dt:string]].
		........
		[[D]], [[d]] :: [[date]], [[time]], [[datetime]] ::
		A date. The {elaboration} is the year, month, day, hour, minute, and second of the epoch, and the scale (0 for seconds,
		-3 for milliseconds, -6 for microseconds, etc.), each delimited by commas. If the {elaboration} is unspecified,
		[[1970,1,1,0,0,0,0]] is assumed, corresponding to the number of seconds since January 1, 1970 (the Unix epoch).
		To use the Macintosh epoch, use [[1904,1,1,0,0,0,0]]. For milliseconds, replace the last number with -3.
		The unpacked {value} is a [[dt:date]].
		........
		[[X]], [[x]] :: [[color]], [[colour]] ::
		A color ([[X]] for Greek {χρώμα}, {chroma}, meaning "color"). The {elaboration} is a string determining the color model
		and the order and width of the color channels. The default is true color with alpha in ARGB order with {size/4} bits per channel.
		For a {size} of 32 bits, this would be equivalent to an {elaboration} of [[a8r8g8b8]]. 
		The unpacked {value} is a [[dt:color]].
		........
		[[Z]], [[z]] :: [[filler]] ::
		A series of {size} filler bits ([[Z]] for "zero"). When packing, {size} bits are filled with zero.
		When unpacking, {size} bits are skipped and ignored. There is no unpacked {value} for this data type.
		........
		[[M]], [[m]] :: [[magic]] ::
		The {elaboration} is a magic number. When packing, the resulting packed value is the magic number.
		When unpacking, the packed value is checked against the magic number; if they don't match, a script error is triggered.
		There is no unpacked {value} for this data type.
		........
		[[A]], [[a]] :: [[align]] ::
		Alignment to a multiple of {size} bits. There is no unpacked {value} for this data type.
		........
		[[ * ]] :: [[blob]], [[binary]] ::
		The {size}, {endianness}, and {elaboration} are ignored. The {count} is the number of bytes to pack or unpack.
		If the {count} is unspecified when unpacking, zero bytes are unpacked. If the {count} is unspecified when packing,
		however many bytes are in the unpacked {value} are packed. The unpacked {value} is a [[dt:binary]].
		........
		[[ $ ]] :: [[struct]] ::
		A substructure. The {elaboration} is a format string describing the binary data substructure.
		The unpacked {value} is a [[dt:list]] of unpacked {value}s from the specified substructure.
		........
		[[ @ ]] :: [[offset]] ::
		The {size}, {endianness}, and {elaboration} are ignored. The {count} is an offset from the beginning of the
		packed [[dt:binary]] where future values are packed to or unpacked from. When unpacking, the offset may be
		anywhere in the [[dt:binary]]. When packing, the offset must be greater than or equal to the number of bytes
		already packed.
		ELBAT::
	</description>
	<description>
		In addition to the type names listed above, the following special type names are allowed in a long-format {format} string.
		These special type names specify a size and, for some, an endianness and an {elaboration} in addition to a data type.
		\\\\
		::TABLE
		[[bbyte]]     :: alias for [[bint8]]
		........
		[[obyte]]     :: alias for [[oint8]]
		........
		[[hbyte]]     :: alias for [[hint8]]
		........
		[[ubyte]]     :: alias for [[uint8]]
		........
		[[sbyte]]     :: alias for [[sint8]]
		........
		[[byte]]      :: alias for [[int8]]
		........
		[[bshort]]    :: alias for [[bint16]]
		........
		[[oshort]]    :: alias for [[oint16]]
		........
		[[hshort]]    :: alias for [[hint16]]
		........
		[[ushort]]    :: alias for [[uint16]]
		........
		[[sshort]]    :: alias for [[sint16]]
		........
		[[short]]     :: alias for [[int16]]
		........
		[[blong]]     :: alias for [[bint64]]
		........
		[[olong]]     :: alias for [[oint64]]
		........
		[[hlong]]     :: alias for [[hint64]]
		........
		[[ulong]]     :: alias for [[uint64]]
		........
		[[slong]]     :: alias for [[sint64]]
		........
		[[long]]      :: alias for [[int64]]
		........
		[[half]]      :: alias for [[float16]]
		........
		[[single]]    :: alias for [[float32]]
		........
		[[real]]      :: alias for [[float32]]
		........
		[[double]]    :: alias for [[float64]]
		........
		[[quad]]      :: alias for [[float128]]
		........
		[[onecc]]     :: alias for [[char8]]
		........
		[[occ]]       :: alias for [[char8]]
		........
		[[twocc]]     :: alias for [[char16]]
		........
		[[tcc]]       :: alias for [[char16]]
		........
		[[fourcc]]    :: alias for [[char32]]
		........
		[[fcc]]       :: alias for [[char32]]
		........
		[[eightcc]]   :: alias for [[char64]]
		........
		[[ecc]]       :: alias for [[char64]]
		........
		[[wstring]]   :: alias for [[pstring16]]
		........
		[[lstring]]   :: alias for [[pstring32]]
		........
		[[wchar]]     :: alias for [[char16be&#123;UTF-16&#125;]]
		........
		[[wcharbe]]   :: alias for [[char16be&#123;UTF-16&#125;]]
		........
		[[wcharle]]   :: alias for [[char16le&#123;UTF-16&#125;]]
		........
		[[ostype]]    :: alias for [[char32be&#123;MacRoman&#125;]]
		........
		[[symbol]]    :: alias for [[char64be&#123;ISO-8859-1&#125;]]
		........
		[[point]]     :: alias for [[struct&#123;sint16be y; sint16be x;&#125;]]
		........
		[[rect]]      :: alias for [[struct&#123;sint16be top; sint16be left; sint16be bottom; sint16be right;&#125;]]
		........
		[[rectangle]] :: alias for [[struct&#123;sint16be top; sint16be left; sint16be bottom; sint16be right;&#125;]]
		........
		[[rgbcolor]]  :: alias for [[struct&#123;uint16be red; uint16be green; uint16be blue;&#125;]]
		........
		[[rgbcolour]] :: alias for [[struct&#123;uint16be red; uint16be green; uint16be blue;&#125;]]
		ELBAT::
	</description>
	<note>
		If the {format} string is not properly formed, a script error is triggered.
	</note>
	<note>
		If any {value} is not of an appropriate type for its corresponding field, a script error is triggered.
	</note>
	<note>
		If there are fewer {value}s passed to the function than are specified by the {format}, the missing
		{value}s are assumed to be [[cn:empty]]. If the corresponding fields are, e.g., [[char]] or [[string]],
		this will have no ill effect, but if the corresponding fields are, e.g., [[boolean]] or [[date]],
		this will trigger a script error.
	</note>
	<note>
		If there are more {value}s passed to the function than are specified by the format, the extra {value}s are ignored.
	</note>
	<note>
		The {value}s to be packed must be passed directly as parameters to the [[*]] function.
		If you already have the {value}s you need in a [[dt:list]], either [[cm:put]] the format string [[kw:before]]
		the [[dt:list]] then pass the [[dt:list]] to the [[*]] function, or pass the [[dt:list]] as the {value} for a [[struct]]
		whose {elaboration} is the original format string.
	</note>
	<see-also>[[fn:unpack]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regCountFields</name>
	<syntax>the regCountFields of ({string}, {delimiter})</syntax>
	<syntax>regCountFields({string}, {delimiter})</syntax>
	<syntax-note>{String} yields any [[dt:string]]. {Delimiter} yields a [[dt:string]] describing a regular expression.</syntax-note>
	<description>
		The [[*]] function returns the number of chunks in the specified {string}
		delimited by the specified {delimiter}, not including any trailing empty
		chunks.
	</description>
	<description>
		The {delimiter} is a regular expression.
		For a literal version of this function, see [[fn:countFields]] or [[fn:csCountFields]].
	</description>
	<see-also>[[fn:countFields]], [[fn:csCountFields]], [[fn:nthField]], [[fn:csNthField]], [[fn:regNthField]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regExplode</name>
	<syntax>the regExplode of ({string}, {delimiter})</syntax>
	<syntax>regExplode({string}, {delimiter})</syntax>
	<syntax-note>{String} yields any [[dt:string]]. {Delimiter} yields a [[dt:string]] describing a regular expression.</syntax-note>
	<description>
		The [[*]] function returns a [[dt:list]] of the chunks in the specified {string}
		delimited by the specified {delimiter}, not including any trailing empty chunks.
	</description>
	<description>
		The {delimiter} is a regular expression.
		For a literal version of this function, see [[fn:explode]] or [[fn:csExplode]].
	</description>
	<see-also>[[fn:explode]], [[fn:csExplode]], [[fn:implode]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regInstr</name>
	<syntax>the regInstr of ({haystack}, {needle})</syntax>
	<syntax>regInstr({haystack}, {needle})</syntax>
	<syntax-note>{Haystack} yields any [[dt:string]]. {Needle} yields a [[dt:string]] describing a regular expression.</syntax-note>
	<description>
		The [[*]] function returns the index of the first appearance of
		the regular expression {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is regular expression-based.
		For a literal version of this function, see [[fn:instr]] or [[fn:csInstr]].
	</description>
	<note>
		This function is similar to [[fn:regOffset]], but the arguments are in reverse order.
	</note>
	<see-also>
		[[fn:instr]], [[fn:csInstr]],
		[[fn:offset]], [[fn:csOffset]], [[fn:regOffset]],
		[[fn:rinstr]], [[fn:csRinstr]], [[fn:regRinstr]]
	</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regMatch</name>
	<syntax>the regMatch of ({expression}, {pattern})</syntax>
	<syntax>regMatch({expression}, {pattern})</syntax>
	<syntax-note>{Expression} yields a [[dt:string]]. {Pattern} yields a string describing a regular expression.</syntax-note>
	<description>
		The [[*]] function returns [[cn:true]] if and only if
		the specified {expression} matches the regular expression
		specified by {pattern}.
	</description>
	<description>
		{Pattern} is a regular expression.
		For a literal version of this function, see [[fn:strcmp]] or [[fn:csStrcmp]].
	</description>
	<see-also>[[fn:strcmp]], [[fn:csStrcmp]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regNthField</name>
	<syntax>the regNthField of ({string}, {delimiter}, {index})</syntax>
	<syntax>regNthField({string}, {delimiter}, {index})</syntax>
	<syntax-note>
		{String} yields any [[dt:string]].
		{Delimiter} yields a [[dt:string]] describing a regular expression.
		{Index} yields an [[dt:integer]].
	</syntax-note>
	<description>
		The [[*]] function returns a chunk of the specified {string}
		delimited by the specified {delimiter}. {Index} starts at 1.
	</description>
	<description>
		If {index} is less than 1 or greater than [[fn:regCountFields]][[({string}, {delimiter})]],
		[[cn:empty]] is returned.
	</description>
	<description>
		The {delimiter} is a regular expression.
		For a literal version of this function, see [[fn:nthField]] or [[fn:csNthField]].
	</description>
	<see-also>[[fn:nthField]], [[fn:csNthField]], [[fn:countFields]], [[fn:csCountFields]], [[fn:regCountFields]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regOffset</name>
	<syntax>the regOffset of ({needle}, {haystack})</syntax>
	<syntax>regOffset({needle}, {haystack})</syntax>
	<syntax-note>{Haystack} yields any [[dt:string]]. {Needle} yields a [[dt:string]] describing a regular expression.</syntax-note>
	<description>
		The [[*]] function returns the index of the first appearance of
		the regular expression {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is regular expression-based.
		For a literal version of this function, see [[fn:offset]] or [[fn:csOffset]].
	</description>
	<note>
		This function is similar to [[fn:regInstr]], but the arguments are in reverse order.
	</note>
	<see-also>
		[[fn:offset]], [[fn:csOffset]],
		[[fn:instr]], [[fn:csInstr]], [[fn:regInstr]],
		[[fn:rinstr]], [[fn:csRinstr]], [[fn:regRinstr]]
	</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regReplace</name>
	<syntax>the regReplace of ({haystack}, {needle}, {noodle})</syntax>
	<syntax>regReplace({haystack}, {needle}, {noodle})</syntax>
	<syntax-note>
		{Haystack} yields any [[dt:string]].
		{Needle} yields a [[dt:string]] describing a regular expression.
		{Noodle} yields a [[dt:string]] describing a replacement expression.
	</syntax-note>
	<description>
		The [[*]] function returns the string {haystack}
		with the first occurrence of the regular expression {needle}
		replaced with the replacement expression {noodle}.
	</description>
	<description>
		{Needle} is a regular expression.
		{Noodle} is more-or-less a literal string; however, backslashes
		or dollar signs in {noodle} will refer to groups in the found
		expression rather than literal backslashes or dollar signs.
		For a literal version of this function, see [[fn:replace]] or [[fn:csReplace]].
	</description>
	<see-also>[[fn:regReplaceAll]], [[fn:replace]], [[fn:csReplace]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regReplaceAll</name>
	<syntax>the regReplaceAll of ({haystack}, {needle}, {noodle})</syntax>
	<syntax>regReplaceAll({haystack}, {needle}, {noodle})</syntax>
	<syntax-note>
		{Haystack} yields any [[dt:string]].
		{Needle} yields a [[dt:string]] describing a regular expression.
		{Noodle} yields a [[dt:string]] describing a replacement expression.
	</syntax-note>
	<description>
		The [[*]] function returns the string {haystack}
		with every occurrence of the regular expression {needle}
		replaced with the replacement expression {noodle}.
	</description>
	<description>
		{Needle} is a regular expression.
		{Noodle} is more-or-less a literal string; however, backslashes
		or dollar signs in {noodle} will refer to groups in the found
		expression rather than literal backslashes or dollar signs.
		For a literal version of this function, see [[fn:replaceAll]] or [[fn:csReplaceAll]].
	</description>
	<see-also>[[fn:regReplace]], [[fn:replaceAll]], [[fn:csReplaceAll]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">regRinstr</name>
	<syntax>the regRinstr of ({haystack}, {needle})</syntax>
	<syntax>regRinstr({haystack}, {needle})</syntax>
	<syntax-note>{Haystack} yields any [[dt:string]]. {Needle} yields a [[dt:string]] describing a regular expression.</syntax-note>
	<description>
		The [[*]] function returns the index of the last appearance of
		the regular expression {needle} in the string {haystack}, starting at 1.
		If {needle} cannot be found in {haystack}, [[cn:zero]] is returned.
	</description>
	<description>
		This function is regular expression-based.
		For a literal version of this function, see [[fn:rinstr]] or [[fn:csRinstr]].
	</description>
	<see-also>
		[[fn:rinstr]], [[fn:csRinstr]],
		[[fn:instr]], [[fn:csInstr]], [[fn:regInstr]],
		[[fn:offset]], [[fn:csOffset]], [[fn:regOffset]]
	</see-also>
</function>

<function>
	<name dialects="oxne12">unpack</name>
	<syntax>the unpack of ({format}, {data})</syntax>
	<syntax>unpack({format}, {data})</syntax>
	<syntax-note>
		{Format} yields a [[dt:string]] describing a binary data structure.
		{Data} yields a [[dt:binary]].
	</syntax-note>
	<description>
		The [[*]] function unpacks values from a [[dt:binary]] according
		to the binary data structure specified by {format}. It is inspired by the
		[[unpack]] functions in Perl and PHP, but has a much more powerful syntax.
	</description>
	<description>
		The {format} string can be specified in one of two ways.
		Using the short format, each field in the binary data structure is specified
		using the following syntax:
		\\\\
		{type} {size} {elaboration} {count} {name} {description}
		\\\\
		Only {type} is required. The {type} is a single character from the table below.
		Uppercase indicates big-endian values, and lowercase indicates little-endian values.
		The {size} is the number of bits. The {elaboration} is a type-specific string that must
		be enclosed in braces; for further details, see the table below. If a {count} is specified,
		the unpacked value is a [[dt:list]], and the {count} must be a number enclosed in brackets
		indicating the number of elements in the list; otherwise, the unpacked value is a
		single value. (Except for the [[ * ]] and [[ @ ]] types, where the {count} is the number of
		bytes and the offset, respectively.) The {name} is a string enclosed in backticks ([[`]]).
		The {description} is a string enclosed in quotes. The {name} and {description} have no effect
		on the packing or unpacking of the data. Whitespace in the format string is ignored
		except for inside quotes and as a token separator.
	</description>
	<description>
		Using the long format, each field in the binary data structure is specified
		using the following syntax:
		\\\\
		{type} {size} {endianness} {elaboration} {count} {name} {description} [[;]]
		\\\\
		Only {type} is required. The {type} is a type name from the table below. The {size}
		is the number of bits. The {endianness} is [[be]] for big-endian or [[le]] for little-endian;
		if {endianness} is not specified, big-endian is assumed. The {elaboration} is a type-specific
		string that must be enclosed in braces; for further details, see the table below. If a {count}
		is specified, the unpacked value is a [[dt:list]], and the {count} must be a number
		enclosed in brackets indicating the number of elements in the list; otherwise, the unpacked
		value is a single value. (Except for the [[binary]] and [[offset]] types, where the {count} is
		the number of bytes and the offset, respectively.) The {name} is either a sequence of alphanumeric
		characters, or a string enclosed in backticks ([[`]]). The {description} is a string enclosed in
		quotes, or any sequence of characters following the name and preceding the terminating semicolon.
		The {name} and {description} have no effect on the packing or unpacking of the data.
		Whitespace in the format string is ignored except for inside quotes and as a token separator.
	</description>
	<description>
		The possible field {type}s are:
		\\\\
		::TABLE
		[[T]], [[t]] :: [[bool]], [[boolean]] ::
		A boolean value ([[T]] for "truth value"). The unpacked value is [[cn:false]] for a packed value of zero
		or [[cn:true]] for a packed value of one (or any other value when unpacking).
		........
		[[E]], [[e]] :: [[enum]] ::
		An enumeration. The {elaboration} is a list of key-value pairs, delimited by semicolons, with the key and value separated by an equals sign.
		Each key is an integer representing a possible packed value and each value is a string. The unpacked value is one of those strings.
		........
		[[J]], [[j]] :: [[bitfield]] ::
		A bit field ([[J]] for "jumper"). The {elaboration} is a list of key-value pairs, delimited by semicolons, with the key and value separated by an equals sign.
		Each key is an integer representing a bit in the packed value (from 0 for the least-significant bit to {size-1} for the most-significant bit)
		and each value is a string. The unpacked value is a comma-delimited list of such strings.
		........
		[[B]], [[b]] :: [[bint]] ::
		An unsigned integer in binary. The unpacked value is a [[dt:string]] of binary digits.
		........
		[[O]], [[o]] :: [[oint]] ::
		An unsigned integer in octal. The unpacked value is a [[dt:string]] of octal digits.
		........
		[[H]], [[h]] :: [[hint]] ::
		An unsigned integer in hexadecimal. The unpacked value is a [[dt:string]] of hexadecimal digits.
		........
		[[U]], [[u]] :: [[uint]] ::
		An unsigned integer. The unpacked value is an [[dt:integer]].
		........
		[[I]], [[i]] :: [[int]], [[sint]] ::
		A signed integer. The unpacked value is an [[dt:integer]].
		........
		[[R]], [[r]] :: [[ufixed]] ::
		An unsigned fixed-point number ([[R]] for "ratio"). The radix point is fixed in the center of the packed value (e.g., at bit 8 if the {size} is 16).
		The unpacked value is a [[dt:number]].
		........
		[[Q]], [[q]] :: [[fixed]], [[sfixed]] ::
		A signed fixed-point number ([[Q]] for "quotient"). The radix point is fixed in the center of the packed value (e.g., at bit 8 if the {size} is 16).
		The unpacked value is a [[dt:number]].
		........
		[[F]], [[f]] :: [[float]] ::
		A floating-point number. The {elaboration} is the number of sign bits, the number of exponent bits, the number of mantissa bits,
		and the exponent bias, separated by periods. If the {elaboration} is not specified, a best guess is made at the appropriate number
		of bits and the appropriate bias based on the {size}. For {size}s of 16, 32, 64, and 128 bits, this "best guess" is guaranteed to be
		[[1.5.10.15]], [[1.8.23.127]], [[1.11.52.1023]], and [[1.15.112.16383]], respectively, corresponding to IEEE half-, single-, double-,
		and quad-precision floating-point numbers. The unpacked value is a [[dt:number]].
		........
		[[K]], [[k]] :: [[complex]] ::
		A complex number, composed of two floating-point numbers (the real part followed by the imaginary part). The {size} is the number
		of bits per part, rather than total. The {elaboration} is the same as for [[float]] above. The unpacked value is a [[dt:complex]].
		........
		[[C]], [[c]] :: [[char]], [[character]] ::
		A character constant. The {size} must be a multiple of 8.
		The {elaboration} is the name of a text encoding. If the {elaboration} is unspecified, [[ISO-8859-1]] is assumed.
		The unpacked value is a [[dt:string]].
		........
		[[P]], [[p]] :: [[pstring]] ::
		A Pascal-style string. The {size} is the number of bits in the count preceding the actual string data.
		The {elaboration} is the name of a text encoding. If the {elaboration} is unspecified, [[ISO-8859-1]] is assumed.
		The unpacked value is a [[dt:string]].
		........
		[[S]], [[s]] :: [[string]], [[cstring]] ::
		A C-style string. The {size} is the number of zero bits following the actual string data and must be a multiple of 8.
		The {elaboration} is the name of a text encoding. If the {elaboration} is unspecified, [[ISO-8859-1]] is assumed.
		The unpacked value is a [[dt:string]].
		........
		[[D]], [[d]] :: [[date]], [[time]], [[datetime]] ::
		A date. The {elaboration} is the year, month, day, hour, minute, and second of the epoch, and the scale (0 for seconds,
		-3 for milliseconds, -6 for microseconds, etc.), each delimited by commas. If the {elaboration} is unspecified,
		[[1970,1,1,0,0,0,0]] is assumed, corresponding to the number of seconds since January 1, 1970 (the Unix epoch).
		To use the Macintosh epoch, use [[1904,1,1,0,0,0,0]]. For milliseconds, replace the last number with -3.
		The unpacked value is a [[dt:date]].
		........
		[[X]], [[x]] :: [[color]], [[colour]] ::
		A color ([[X]] for Greek {χρώμα}, {chroma}, meaning "color"). The {elaboration} is a string determining the color model
		and the order and width of the color channels. The default is true color with alpha in ARGB order with {size/4} bits per channel.
		For a {size} of 32 bits, this would be equivalent to an {elaboration} of [[a8r8g8b8]]. 
		The unpacked value is a [[dt:color]].
		........
		[[Z]], [[z]] :: [[filler]] ::
		A series of {size} filler bits ([[Z]] for "zero"). When packing, {size} bits are filled with zero.
		When unpacking, {size} bits are skipped and ignored. There is no unpacked value for this data type.
		........
		[[M]], [[m]] :: [[magic]] ::
		The {elaboration} is a magic number. When packing, the resulting packed value is the magic number.
		When unpacking, the packed value is checked against the magic number; if they don't match, a script error is triggered.
		There is no unpacked value for this data type.
		........
		[[A]], [[a]] :: [[align]] ::
		Alignment to a multiple of {size} bits. There is no unpacked value for this data type.
		........
		[[ * ]] :: [[blob]], [[binary]] ::
		The {size}, {endianness}, and {elaboration} are ignored. The {count} is the number of bytes to pack or unpack.
		If the {count} is unspecified when unpacking, zero bytes are unpacked. If the {count} is unspecified when packing,
		however many bytes are in the unpacked value are packed. The unpacked value is a [[dt:binary]].
		........
		[[ $ ]] :: [[struct]] ::
		A substructure. The {elaboration} is a format string describing the binary data substructure.
		The unpacked value is a [[dt:list]] of unpacked values from the specified substructure.
		........
		[[ @ ]] :: [[offset]] ::
		The {size}, {endianness}, and {elaboration} are ignored. The {count} is an offset from the beginning of the
		packed [[dt:binary]] where future values are packed to or unpacked from. When unpacking, the offset may be
		anywhere in the [[dt:binary]]. When packing, the offset must be greater than or equal to the number of bytes
		already packed.
		ELBAT::
	</description>
	<description>
		In addition to the type names listed above, the following special type names are allowed in a long-format {format} string.
		These special type names specify a size and, for some, an endianness and an {elaboration} in addition to a data type.
		\\\\
		::TABLE
		[[bbyte]]     :: alias for [[bint8]]
		........
		[[obyte]]     :: alias for [[oint8]]
		........
		[[hbyte]]     :: alias for [[hint8]]
		........
		[[ubyte]]     :: alias for [[uint8]]
		........
		[[sbyte]]     :: alias for [[sint8]]
		........
		[[byte]]      :: alias for [[int8]]
		........
		[[bshort]]    :: alias for [[bint16]]
		........
		[[oshort]]    :: alias for [[oint16]]
		........
		[[hshort]]    :: alias for [[hint16]]
		........
		[[ushort]]    :: alias for [[uint16]]
		........
		[[sshort]]    :: alias for [[sint16]]
		........
		[[short]]     :: alias for [[int16]]
		........
		[[blong]]     :: alias for [[bint64]]
		........
		[[olong]]     :: alias for [[oint64]]
		........
		[[hlong]]     :: alias for [[hint64]]
		........
		[[ulong]]     :: alias for [[uint64]]
		........
		[[slong]]     :: alias for [[sint64]]
		........
		[[long]]      :: alias for [[int64]]
		........
		[[half]]      :: alias for [[float16]]
		........
		[[single]]    :: alias for [[float32]]
		........
		[[real]]      :: alias for [[float32]]
		........
		[[double]]    :: alias for [[float64]]
		........
		[[quad]]      :: alias for [[float128]]
		........
		[[onecc]]     :: alias for [[char8]]
		........
		[[occ]]       :: alias for [[char8]]
		........
		[[twocc]]     :: alias for [[char16]]
		........
		[[tcc]]       :: alias for [[char16]]
		........
		[[fourcc]]    :: alias for [[char32]]
		........
		[[fcc]]       :: alias for [[char32]]
		........
		[[eightcc]]   :: alias for [[char64]]
		........
		[[ecc]]       :: alias for [[char64]]
		........
		[[wstring]]   :: alias for [[pstring16]]
		........
		[[lstring]]   :: alias for [[pstring32]]
		........
		[[wchar]]     :: alias for [[char16be&#123;UTF-16&#125;]]
		........
		[[wcharbe]]   :: alias for [[char16be&#123;UTF-16&#125;]]
		........
		[[wcharle]]   :: alias for [[char16le&#123;UTF-16&#125;]]
		........
		[[ostype]]    :: alias for [[char32be&#123;MacRoman&#125;]]
		........
		[[symbol]]    :: alias for [[char64be&#123;ISO-8859-1&#125;]]
		........
		[[point]]     :: alias for [[struct&#123;sint16be y; sint16be x;&#125;]]
		........
		[[rect]]      :: alias for [[struct&#123;sint16be top; sint16be left; sint16be bottom; sint16be right;&#125;]]
		........
		[[rectangle]] :: alias for [[struct&#123;sint16be top; sint16be left; sint16be bottom; sint16be right;&#125;]]
		........
		[[rgbcolor]]  :: alias for [[struct&#123;uint16be red; uint16be green; uint16be blue;&#125;]]
		........
		[[rgbcolour]] :: alias for [[struct&#123;uint16be red; uint16be green; uint16be blue;&#125;]]
		ELBAT::
	</description>
	<note>
		If the {format} string is not properly formed, a script error is triggered.
	</note>
	<note>
		If the {data} are shorter than required by the {format}, the missing bytes are assumed to be zero.
		If the {data} are longer than required by the {format}, the extra bytes are ignored.
	</note>
	<see-also>[[fn:pack]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">urlDecode</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function decodes any sequences of the form [[%{XX}]] in
		the specified string, replaces plus signs with spaces, and returns
		the decoded string. The string is decoded in the same way that posted
		data from an HTML form is decoded.
	</description>
	<description>
		The decoding of sequences for non-ASCII characters is determined by
		the text encoding specified by the [[pr:textEncoding]] property.
	</description>
	<see-also>[[fn:urlEncode]], [[fn:htmlEncode]], [[fn:htmlDecode]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">urlEncode</name>
	<syntax>the [[*]] of {factor}</syntax>
	<syntax>[[*]]({expression})</syntax>
	<syntax-note>{Factor} and {expression} yield [[dt:string]]s.</syntax-note>
	<description>
		The [[*]] function encodes non-alphabetic characters (other than hyphen,
		underscore, and period), control characters, and non-ASCII characters
		in the specified string as a percent sign followed by two hexadecimal
		digits, and spaces in the specified string as plus signs, and returns
		the encoded string. The string is encoded in the same way that posted
		data from an HTML form is encoded.
	</description>
	<description>
		The encoding for non-ASCII characters is determined by the text encoding
		specified by the [[pr:textEncoding]] property.
	</description>
	<see-also>[[fn:urlDecode]], [[fn:htmlEncode]], [[fn:htmlDecode]]</see-also>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">vmName</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns the name of the Java virtual machine.
		You might use this to determine whether a script will run correctly
		under that virtual machine.
	</description>
	<note>
		OpenXION gets the value of this function from the [[java.vm.name]] system property.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</function>

<function>
	<name dialects="oxne1,oxne11,oxne12">vmVersion</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns the version of the Java virtual machine.
		You might use this to determine whether a script will run correctly
		under that version of the virtual machine.
	</description>
	<note>
		OpenXION gets the value of this function from the [[java.vm.version]] system property.
	</note>
	<security>
		To use this function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
</function>

<function>
	<name dialects="oxna12,hyp">serialPorts</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns a [[pr:lineEnding]]-delimited list of communications ports.
		These are the possible values of the [[pr:dialingPort]] property, which determines the
		port used to dial phone numbers with a modem.
	</description>
	<note>
		In HyperTalk, this function existed but was undocumented.
	</note>
	<security>
		To use the [[*]] function, OpenXION's security settings must allow the [[SYSTEM_INFO]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:dial]], [[pr:dialingPort]]</see-also>
</function>

<function>
	<name dialects="oxna12,hyp">sound</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<example>wait until the [[*]] is "done"</example>
	<description>
		The [[*]] function returns the name of the instrument currently playing on the current
		[[pr:soundChannel]], or the string [["done"]] if no instrument is currently playing.
	</description>
	<note>
		The [["done"]] string is a literal; it is not a constant like [[cn:zero]] or [[cn:true]].
		In HyperTalk code, the [["done"]] literal is often left unquoted, but in XION this is
		highly discouraged.
	</note>
	<see-also>[[cm:play]], [[fn:sounds]]</see-also>
</function>

<function>
	<name dialects="oxna12">sounds</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns a [[pr:lineEnding]]-delimited list of instrument names
		currently available for use with the [[cm:play]] command.
	</description>
	<see-also>[[cm:play]], [[fn:sound]]</see-also>
</function>

<function>
	<name dialects="oxna12,hyp">speech</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<example>wait until the [[*]] is "done"</example>
	<description>
		The [[*]] function returns the currently generated speech text,
		or the string [["done"]] if no speech is currently being generated.
	</description>
	<note>
		The [["done"]] string is a literal; it is not a constant like [[cn:zero]] or [[cn:true]].
		In HyperTalk code, the [["done"]] literal is often left unquoted, but in XION this is
		highly discouraged.
	</note>
	<see-also>[[cm:speak]], [[fn:voice]]</see-also>
</function>

<function>
	<name dialects="oxna12">tone</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<example>wait until the [[*]] is "done"</example>
	<description>
		The [[*]] function returns the frequency of the tone currently being
		generated by the [[cm:tone]] command, or the string [["done"]] if no
		tone is currently playing.
	</description>
	<note>
		The [["done"]] string is a literal; it is not a constant like [[cn:zero]] or [[cn:true]].
		In HyperTalk code, the [["done"]] literal is often left unquoted, but in XION this is
		highly discouraged.
	</note>
	<see-also>[[cm:tone]]</see-also>
</function>

<function>
	<name dialects="oxna12">voice</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<example>wait until the [[*]] is "done"</example>
	<description>
		The [[*]] function returns the name of the voice currently speaking,
		or the string [["done"]] if no speech is currently being generated.
	</description>
	<note>
		The [["done"]] string is a literal; it is not a constant like [[cn:zero]] or [[cn:true]].
		In HyperTalk code, the [["done"]] literal is often left unquoted, but in XION this is
		highly discouraged.
	</note>
	<see-also>[[cm:speak]], [[fn:speech]], [[fn:voices]]</see-also>
</function>

<function>
	<name dialects="oxna12,hyp">voices</name>
	<syntax>the [[*]]</syntax>
	<syntax>[[*]]()</syntax>
	<example>put the [[*]]</example>
	<description>
		The [[*]] function returns a [[pr:lineEnding]]-delimited list of voices
		currently available for use with the [[cm:speak]] command.
	</description>
	<see-also>[[cm:speak]], [[fn:voice]]</see-also>
</function>

<version>
	<name dialects="oxn1,oxn11,oxn12">standardModule</name>
	<syntax>the version of "standardModule"</syntax>
	<syntax>version("standardModule")</syntax>
	<description>
		The version number of the OpenXION Standard Module.
	</description>
</version>

<version>
	<name dialects="xn1,oxn1,oxn11,oxn12">interpreter</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">xion</name>
	<name dialects="oxn1,oxn11,oxn12">openxion</name>
	<syntax>the version of "[[*]]"</syntax>
	<syntax>version("[[*]]")</syntax>
	<description>
		The version number of the XION interpreter.
	</description>
	<see-also>[[dt:interpreter]], [[fn:xionName]], [[fn:xionVersion]]</see-also>
</version>

<version>
	<name dialects="xn1,oxn1,oxn11,oxn12">system</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">operatingSystem</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">opSys</name>
	<name dialects="xn1,oxn1,oxn11,oxn12">os</name>
	<syntax>the version of "[[*]]"</syntax>
	<syntax>version("[[*]]")</syntax>
	<description>
		The version number of the operating system.
	</description>
	<see-also>[[fn:systemName]], [[fn:systemVersion]]</see-also>
</version>

<version>
	<name dialects="oxne1,oxne11,oxne12">extendedModule</name>
	<syntax>the version of "extendedModule"</syntax>
	<syntax>version("extendedModule")</syntax>
	<description>
		The version number of the OpenXION Extended Module.
	</description>
</version>

<version>
	<name dialects="oxne1,oxne11,oxne12">java</name>
	<syntax>the version of "java"</syntax>
	<syntax>version("java")</syntax>
	<description>
		The version number of the Java Runtime Environment.
	</description>
	<see-also>[[vr:javavm]], [[fn:javaName]], [[fn:javaVersion]]</see-also>
</version>

<version>
	<name dialects="oxne1,oxne11,oxne12">javavm</name>
	<name dialects="oxne1,oxne11,oxne12">vm</name>
	<syntax>the version of "[[*]]"</syntax>
	<syntax>version("[[*]]")</syntax>
	<description>
		The version number of the Java Virtual Machine.
	</description>
	<see-also>[[vr:java]], [[fn:vmName]], [[fn:vmVersion]]</see-also>
</version>

<version>
	<name dialects="oxna12">audioModule</name>
	<syntax>the version of "audioModule"</syntax>
	<syntax>version("audioModule")</syntax>
	<description>
		The version number of the OpenXION Audio Module.
	</description>
</version>

<extlang>
	<name dialects="oxnb1,oxnb11,oxnb12,hyp">hyperTalk</name>
	<name dialects="oxnb1,oxnb11,oxnb12">xion</name>
	<name dialects="oxnb1,oxnb11,oxnb12">openxion</name>
	<syntax>do {script}</syntax>
	<syntax>do {script} as "[[*]]"</syntax>
	<description>
		Executes the specified text as a script. The string is executed as though
		it were inserted in place of the [[cs:do]] statement.
	</description>
	<note>
		In OpenXION, the [[xl:hyperTalk]] "language" is provided as a synonym of
		[[xl:xion]] and [[xl:openxion]] for compatibility purposes.
	</note>
	<see-also>[[cs:do]]</see-also>
</extlang>

<extlang>
	<name dialects="oxne1,oxne11,oxne12,hyp">appleScript</name>
	<syntax>do {script} as "[[*]]"</syntax>
	<description>
		Executes the specified text as an AppleScript script.
	</description>
	<note>
		This external language is only available when OpenXION is running under Mac OS X.
	</note>
	<note>
		In OpenXION 1.2 and later, the output of the script, if any, can be retrieved
		using the [[fn:result]] function. (OpenXION 1.0 and 1.1 did not capture any output.)
	</note>
	<see-also>[[cs:do]]</see-also>
</extlang>

<extlang>
	<name dialects="oxne11,oxne12">vbScript</name>
	<syntax>do {script} as "[[*]]"</syntax>
	<description>
		Executes the specified text as a VBScript script.
	</description>
	<note>
		This external language is only available when OpenXION is running under Windows.
	</note>
	<note>
		In OpenXION 1.2 and later, the output of the script, if any, can be retrieved
		using the [[fn:result]] function. (OpenXION 1.0 and 1.1 did not capture any output.)
	</note>
	<see-also>[[cs:do]]</see-also>
</extlang>

<extlang>
	<name dialects="oxne1,oxne11,oxne12">bash</name>
	<syntax>do {script} as "[[*]]"</syntax>
	<description>
		Executes the specified text as a [[bash]] script.
	</description>
	<note>
		This external language is only available when OpenXION is running under a system other than Windows.
	</note>
	<note>
		In OpenXION 1.2 and later, the output of the script, if any, can be retrieved
		using the [[fn:result]] function. (OpenXION 1.0 and 1.1 did not capture any output.)
	</note>
	<see-also>[[cs:do]]</see-also>
</extlang>

<extlang>
	<name dialects="oxne1,oxne11,oxne12">perl</name>
	<syntax>do {script} as "[[*]]"</syntax>
	<description>
		Executes the specified text as a Perl script.
	</description>
	<note>
		This external language is only available when OpenXION is running under a system other than Windows.
	</note>
	<note>
		In OpenXION 1.2 and later, the output of the script, if any, can be retrieved
		using the [[fn:result]] function. (OpenXION 1.0 and 1.1 did not capture any output.)
	</note>
	<see-also>[[cs:do]]</see-also>
</extlang>

<extlang>
	<name dialects="oxne1,oxne11,oxne12">php</name>
	<syntax>do {script} as "[[*]]"</syntax>
	<description>
		Executes the specified text as a PHP script.
	</description>
	<note>
		This external language is only available when OpenXION is running under a system other than Windows.
	</note>
	<note>
		In OpenXION 1.2 and later, the output of the script, if any, can be retrieved
		using the [[fn:result]] function. (OpenXION 1.0 and 1.1 did not capture any output.)
	</note>
	<see-also>[[cs:do]]</see-also>
</extlang>

<extlang>
	<name dialects="oxne1,oxne11,oxne12">python</name>
	<syntax>do {script} as "[[*]]"</syntax>
	<description>
		Executes the specified text as a Python script.
	</description>
	<note>
		This external language is only available when OpenXION is running under a system other than Windows.
	</note>
	<note>
		In OpenXION 1.2 and later, the output of the script, if any, can be retrieved
		using the [[fn:result]] function. (OpenXION 1.0 and 1.1 did not capture any output.)
	</note>
	<see-also>[[cs:do]]</see-also>
</extlang>

<extlang>
	<name dialects="oxne1,oxne11,oxne12">ruby</name>
	<syntax>do {script} as "[[*]]"</syntax>
	<description>
		Executes the specified text as a Ruby script.
	</description>
	<note>
		This external language is only available when OpenXION is running under a system other than Windows.
	</note>
	<note>
		In OpenXION 1.2 and later, the output of the script, if any, can be retrieved
		using the [[fn:result]] function. (OpenXION 1.0 and 1.1 did not capture any output.)
	</note>
	<see-also>[[cs:do]]</see-also>
</extlang>

<iomanager>
	<name dialects="xn1,oxn1,oxn11,oxn12,hyp">file</name>
	<syntax>open {file}</syntax>
	<syntax>open {file} as {ioMethod}</syntax>
	<syntax-note>
		{File} yields a [[dt:file]].
		{IoMethod} yields the name of an I/O method.
	</syntax-note>
	<example>open file "XION.tex"</example>
	<example>open file "XION.tex" as "ISO-8859-1"</example>
	<example>open file "XION.tex" as "UTF-8"</example>
	<example>open file "Resources.dff" as "binary"</example>
	<description>
		The [[mg:file]] I/O manager allows reading and writing to
		[[dt:file]]s using the I/O commands [[cm:open]], [[cm:read]],
		[[cm:write]], [[cm:truncate]], and [[cm:close]]. See the
		documentation for each I/O command for more information.
	</description>
	<note>
		If no I/O method is given, the [[mg:file]] I/O manager
		assumes the [[mt:text]] I/O method using the current value of
		the [[pr:textEncoding]] property as the text encoding to use.
	</note>
	<note>
		HyperTalk does not support the [[as]] keyword.
		HyperTalk assumes the MacRoman text encoding.
	</note>
	<security>
		To open files, OpenXION's security settings must allow one or both of the [[FILE_SYSTEM_READ]] and [[FILE_SYSTEM_WRITE]] security keys.
		To read from files, OpenXION's security settings must allow the [[FILE_SYSTEM_READ]] security key.
		To write to files, OpenXION's security settings must allow the [[FILE_SYSTEM_WRITE]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</iomanager>

<iomanager>
	<name dialects="oxne1,oxne11,oxne12,hyp">URL</name>
	<syntax>open {url}</syntax>
	<syntax>open {url} as {ioMethod}</syntax>
	<syntax-note>
		{Url} yields a [[dt:URL]].
		{IoMethod} yields the name of an I/O method.
	</syntax-note>
	<example>open URL "http://www.kreativekorp.com"</example>
	<example>open URL "http://www.kreativekorp.com" as "text"</example>
	<description>
		If {no} I/O method is given, the [[mg:URL]] I/O manager
		will open the specified URL with the user's default web browser.
	</description>
	<description>
		If an I/O method {is} given, the [[mg:URL]] I/O manager allows reading
		and writing to [[dt:URL]]s using the I/O commands [[cm:open]], [[cm:read]],
		[[cm:write]], [[cm:truncate]], and [[cm:close]]. See the
		documentation for each I/O command for more information.
	</description>
	<note>
		HyperTalk does not support the [[as]] keyword.
		HyperTalk can only launch URLs, and cannot read from or write to them.
	</note>
	<security>
		To launch URLs, OpenXION's security settings must allow the [[BROWSER_LAUNCH]] security key.
		To read from or write to URLs, OpenXION's security settings must allow the [[INTERNET_ACCESS]] security key.
		If the required security key is denied, a script error will be triggered.
	</security>
	<see-also>[[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</iomanager>

<iomethod>
	<name dialects="xn1,oxn1,oxn11,oxn12">binary</name>
	<syntax>open {object} as "binary"</syntax>
	<syntax-note>{Object} yields a [[dt:variant]] with an appropriate I/O manager.</syntax-note>
	<description>
		The [[mt:binary]] I/O method allows reading and writing as binary data.
		The [[dt:variant]]s read and written will be [[dt:binary]]s.
	</description>
	<note>
		[[cm:Read]]ing something opened as [[mt:binary]] without specifying
		a length will result in reading all the remaining data.
	</note>
	<see-also>[[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</iomethod>

<iomethod>
	<name dialects="xn1,oxn1,oxn11,oxn12">text</name>
	<syntax>open {object} as "text"</syntax>
	<syntax>open {object} as {textEncoding}</syntax>
	<syntax-note>
		{Object} yields a [[dt:variant]] with an appropriate I/O manager.
		{TextEncoding} yields the name of a text encoding.
	</syntax-note>
	<description>
		The [[mt:text]] I/O method allows reading and writing as text.
		The [[dt:variant]]s read and written will be [[dt:string]]s.
	</description>
	<note>
		If the I/O method is specified as simply [["text"]], the value
		of the [[pr:textEncoding]] property is used to determine the text
		encoding to use. Otherwise, the name specified as the I/O method
		is used to determine the text encoding to use.
	</note>
	<note>
		[[cm:Read]]ing something opened as [[mt:text]] without specifying
		a length will result in reading characters up to and including the
		next line break. The [[mt:text]] I/O method uses [[cn:return]][[op:&amp;]][[cn:newline]],
		[[cn:newline]], [[cn:return]], [[cn:linesep]], and [[cn:parasep]] as possible
		line endings.
	</note>
	<see-also>[[cm:open]], [[cm:read]], [[cm:write]], [[cm:truncate]], [[cm:close]]</see-also>
</iomethod>

<article>
	<name>keywords</name>
	<title>Keywords at a Glance</title>
	<summary>
		An at-a-glance view of all the control structures and other keywords available in OpenXION.
	</summary>
	<content>
		{{{{Includes}}}}
		\\\\
		::TABLE
		[[cs:include]] :: [[cs:require]] :: [[cs:use]]
		ELBAT::
		\\\\
		{{{{Declarations}}}}
		\\\\
		::TABLE
		[[cs:global]] :: [[cs:shared]]  :: [[cs:static]] :: [[cs:local]] :: [[cs:const]] :: [[cs:ordinal]]
		ELBAT::
		\\\\
		{{{{Conditionals}}}}
		\\\\
		::TABLE
		[[cs:if]]     :: [[cs:then]] :: [[cs:else]]    :: [[cs:exit]] :: [[cs:end]]  ::  
		..........................................................................................
		[[cs:switch]] :: [[cs:case]] :: [[cs:default]] :: [[cs:next]] :: [[cs:exit]] :: [[cs:end]]
		ELBAT::
		\\\\
		{{{{Loops}}}}
		\\\\
		::TABLE
		[[cs:repeat]]       :: [[cs:repeat for]]    :: [[cs:repeat for each]] :: [[cs:repeat foreach]]
		..............................................................................................
		[[cs:repeat until]] :: [[cs:repeat while]]  :: [[cs:repeat with]]     ::  
		..............................................................................................
		[[cs:next]]         :: [[cs:exit]]          :: [[cs:end]]             ::  
		ELBAT::
		\\\\
		{{{{Exception Handling}}}}
		\\\\
		::TABLE
		[[cs:try]] :: [[cs:throw]] :: [[cs:catch]] :: [[cs:finally]] :: [[cs:exit]] :: [[cs:end]]
		ELBAT::
		\\\\
		{{{{Messages & Handlers}}}}
		\\\\
		::TABLE
		[[cs:on]]   :: [[cs:function]] :: [[cs:return]]
		...............................................
		[[cs:pass]] :: [[cs:exit]]     :: [[cs:end]]
		...............................................
		[[cs:do]]   :: [[cs:send]]     :: [[cs:tell]]
		ELBAT::
		\\\\
		{{{{User-Defined Objects}}}}
		\\\\
		::TABLE
		[[cs:object type]] :: [[cs:pl]] :: [[cs:aka]] :: [[cs:extends]]
		ELBAT::::TABLE
		[[cs:to create]]       :: [[cs:to delete]]
		................................................
		[[cs:to get contents]] :: [[cs:to put contents]]
		................................................
		[[cs:to get]]          :: [[cs:to set]]
		................................................
		[[kw:me]]              :: [[kw:super]]
		................................................
		[[cs:exit]]            :: [[cs:end]]
		ELBAT::
		\\\\
		{{{{Adjectives}}}}
		\\\\
		::TABLE
		[[kw:short]]  :: [[kw:med]]         :: [[kw:medium]] :: [[kw:abbr]]
		......................................................................
		[[kw:abbrev]] :: [[kw:abbreviated]] :: [[kw:long]]   :: [[kw:English]]
		ELBAT::
		\\\\
		{{{{Prepositions}}}}
		\\\\
		::TABLE
		[[kw:into]] :: [[kw:before]] :: [[kw:after]]
		ELBAT::
		\\\\
		{{{{Other Keywords}}}}
		\\\\
		::TABLE
		[[kw:in]] :: [[kw:of]] :: [[kw:to]] :: [[kw:thru]] :: [[kw:through]] :: [[kw:the]]
		ELBAT::
		\\\\
		{{{{Metakeywords}}}}
		\\\\
		::TABLE
		[[kw:__LINE__]] :: [[kw:__FILE__]]
		ELBAT::
	</content>
</article>

<article>
	<name>commands</name>
	<title>Commands at a Glance</title>
	<summary>
		An at-a-glance view of all the commands available in OpenXION.
	</summary>
	<content>
		{{{{Basic Commands}}}}
		\\\\
		::TABLE
		[[cm:get]] :: [[cm:put]] :: [[cm:let]] :: [[cm:set]]
		ELBAT::
		\\\\
		{{{{Arithmetic}}}}
		\\\\
		::TABLE
		[[cm:add]] :: [[cm:subtract]] :: [[cm:multiply]] :: [[cm:divide]] :: [[cm:modulo]]
		ELBAT::
		\\\\
		{{{{Object Manipulation}}}}
		\\\\
		::TABLE
		[[cm:create]] :: [[cm:delete]]
		ELBAT::
		\\\\
		{{{{Human-Computer Interaction}}}}
		\\\\
		::TABLE
		[[cm:answer]] :: [[cm:ask]] :: [[cm:beep]] :: [[cm:put]]
		ELBAT::
		\\\\
		{{{{File I/O}}}}
		\\\\
		::TABLE
		[[cm:open]] :: [[cm:read]] :: [[cm:write]] :: [[cm:truncate]] :: [[cm:close]]
		ELBAT::
		\\\\
		{{{{Sound}}}}
		\\\\
		::TABLE
		[[cm:beep]] :: [[cm:dial]] :: [[cm:play]] :: [[cm:speak]] :: [[cm:stop]] :: [[cm:tone]]
		ELBAT::
		\\\\
		{{{{Miscellaneous Commands}}}}
		\\\\
		::TABLE
		[[cm:convert]] :: [[cm:sort]] :: [[cm:sql]] :: [[cm:wait]]
		ELBAT::
	</content>
</article>

<article>
	<name>functions</name>
	<title>Functions at a Glance</title>
	<summary>
		An at-a-glance view of all the functions available in OpenXION.
	</summary>
	<content>
		{{{{{Mathematical Functions}}}}}
		\\\\
		{{{{Basic}}}}
		\\\\
		::TABLE
		[[fn:abs]]      :: [[fn:arg]]         :: [[fn:conj]]          :: [[fn:Re]]        :: [[fn:Im]]
		................................................................................................
		[[fn:sgn]]      :: [[fn:signum]]      :: [[fn:sqrt]]          :: [[fn:cbrt]]      ::  
		ELBAT::::TABLE
		[[fn:toDeg]]    :: [[fn:toDegrees]]   :: [[fn:toRad]]         :: [[fn:toRadians]] ::  
		ELBAT::::TABLE
		[[fn:isFinite]] :: [[fn:isInfinite]]  :: [[fn:isNaN]]         ::                  ::  
		ELBAT::::TABLE
		[[fn:sum]]      :: [[fn:prod]]        :: [[fn:product]]       :: [[fn:rsr]]       :: [[fn:rms]]
		ELBAT::::TABLE
		[[fn:random]]   :: [[fn:randomRange]] :: [[fn:randomDecimal]] ::                  ::  
		ELBAT::
		\\\\
		{{{{Rounding}}}}
		\\\\
		::TABLE
		[[fn:ceil]]  :: [[fn:floor]]
		.............................
		[[fn:aug]]   :: [[fn:trunc]]
		.............................
		[[fn:round]] :: [[fn:rint]]
		.............................
		[[fn:int]]   :: [[fn:frac]]
		ELBAT::
		\\\\
		{{{{Logarithms &amp; Exponentials}}}}
		\\\\
		::TABLE
		[[fn:exp]]   :: [[fn:exp1]]  :: [[fn:exp2]]  :: [[fn:exp10]]
		.............................................................
		[[fn:ln]]    :: [[fn:ln1]]   :: [[fn:log2]]  :: [[fn:log10]]
		.............................................................
		[[fn:log]]   :: [[fn:pow]]   :: [[fn:root]]  ::  
		ELBAT::
		\\\\
		{{{{Trigonometry}}}}
		\\\\
		::TABLE
		[[fn:sin]]   :: [[fn:cos]]   :: [[fn:tan]]   :: [[fn:cot]]   :: [[fn:sec]]   :: [[fn:csc]]
		.............................................................................................
		[[fn:asin]]  :: [[fn:acos]]  :: [[fn:atan]]  :: [[fn:acot]]  :: [[fn:asec]]  :: [[fn:acsc]]
		.............................................................................................
		[[fn:sinh]]  :: [[fn:cosh]]  :: [[fn:tanh]]  :: [[fn:coth]]  :: [[fn:sech]]  :: [[fn:csch]]
		.............................................................................................
		[[fn:asinh]] :: [[fn:acosh]] :: [[fn:atanh]] :: [[fn:acoth]] :: [[fn:asech]] :: [[fn:acsch]]
		ELBAT::
		\\\\
		{{{{Coordinate Transformation}}}}
		\\\\
		::TABLE
		[[fn:hypot]]   :: [[fn:atan2]]
		...............................
		[[fn:radius]]  :: [[fn:theta]]
		...............................
		[[fn:xcoord]]  :: [[fn:ycoord]]
		ELBAT::
		\\\\
		{{{{Statistics}}}}
		\\\\
		::TABLE
		[[fn:avg]]     :: [[fn:average]]
		...................................
		[[fn:geom]]    :: [[fn:geomean]]
		...................................
		[[fn:min]]     :: [[fn:minimum]]
		...................................
		[[fn:max]]     :: [[fn:maximum]]
		...................................
		[[fn:stddev]]  :: [[fn:variance]]
		...................................
		[[fn:pstddev]] :: [[fn:pvariance]]
		...................................
		[[fn:sstddev]] :: [[fn:svariance]]
		ELBAT::
		\\\\
		{{{{Finance}}}}
		\\\\
		::TABLE
		[[fn:annuity]] :: [[fn:compound]]
		ELBAT::
		\\\\
		{{{{Factorials &amp; Probability}}}}
		\\\\
		::TABLE
		[[fn:fact]]    :: [[fn:factorial]]   :: [[fn:Γ]]   :: [[fn:gamma]]   :: [[fn:β]]   :: [[fn:beta]]
		...................................................................................................
		[[fn:lnfact]]  :: [[fn:lnfactorial]] :: [[fn:lnΓ]] :: [[fn:lngamma]] :: [[fn:lnβ]] :: [[fn:lnbeta]]
		...................................................................................................
		[[fn:nCr]]     :: [[fn:choose]]      :: [[fn:nPr]] :: [[fn:pick]]    ::            ::  
		ELBAT::
		\\\\
		{{{{Number Theory &amp; Representation}}}}
		\\\\
		::TABLE
		[[fn:agm]]         :: [[fn:gcd]]           :: [[fn:lcm]] ::  
		ELBAT::::TABLE
		[[fn:bin]]         :: [[fn:oct]]           :: [[fn:hex]] :: [[fn:bc]]
		ELBAT::::TABLE
		[[fn:reverseBits]] :: [[fn:reverseBytes]]  ::            ::  
		ELBAT::
		\\\\
		{{{{Infinite-arity Relative &amp; Boolean Operators}}}}
		\\\\
		::TABLE
		[[fn:and]]   :: [[fn:or]]          :: [[fn:xor]]   ::  
		ELBAT::::TABLE
		[[fn:asc]]   :: [[fn:ascending]]   :: [[fn:desc]]  :: [[fn:descending]]
		.......................................................................
		[[fn:inc]]   :: [[fn:increasing]]  :: [[fn:dec]]   :: [[fn:decreasing]]
		ELBAT::::TABLE
		[[fn:equal]] ::                    ::              ::  
		ELBAT::
		\\\\
		{{{{{String Functions}}}}}
		\\\\
		{{{{String Manipulation}}}}
		\\\\
		::TABLE
		[[fn:len]]         :: [[fn:length]]        :: [[fn:reverse]]
		...................................................................
		[[fn:concat]]      :: [[fn:concatsp]]      :: [[fn:implode]]
		...................................................................
		[[fn:strcmp]]      :: [[fn:csStrcmp]]      :: [[fn:regMatch]]
		...................................................................
		[[fn:offset]]      :: [[fn:csOffset]]      :: [[fn:regOffset]]
		...................................................................
		[[fn:instr]]       :: [[fn:csInstr]]       :: [[fn:regInstr]]
		...................................................................
		[[fn:rinstr]]      :: [[fn:csRinstr]]      :: [[fn:regRinstr]]
		...................................................................
		[[fn:countFields]] :: [[fn:csCountFields]] :: [[fn:regCountFields]]
		...................................................................
		[[fn:nthField]]    :: [[fn:csNthField]]    :: [[fn:regNthField]]
		...................................................................
		[[fn:explode]]     :: [[fn:csExplode]]     :: [[fn:regExplode]]
		...................................................................
		[[fn:replace]]     :: [[fn:csReplace]]     :: [[fn:regReplace]]
		...................................................................
		[[fn:replaceAll]]  :: [[fn:csReplaceAll]]  :: [[fn:regReplaceAll]]
		...................................................................
		[[fn:left]]        :: [[fn:center]]        :: [[fn:right]]
		...................................................................
		[[fn:mid]]         :: [[fn:substr]]        :: [[fn:substring]]
		...................................................................
		[[fn:lpad]]        :: [[fn:cpad]]          :: [[fn:rpad]]
		...................................................................
		[[fn:trim]]        :: [[fn:ltrim]]         :: [[fn:rtrim]]
		...................................................................
		[[fn:ucase]]       :: [[fn:tcase]]         :: [[fn:lcase]]
		ELBAT::
		\\\\
		{{{{Text Encoding}}}}
		\\\\
		::TABLE
		[[fn:numToChar]] :: [[fn:charToNum]]
		.....................................
		[[fn:numToUni]]  :: [[fn:uniToNum]]
		.....................................
		[[fn:binToChar]] :: [[fn:charToBin]]
		.....................................
		[[fn:binToUni]]  :: [[fn:uniToBin]]
		ELBAT::
		\\\\
		{{{{Encoding &amp; Decoding}}}}
		\\\\
		::TABLE
		[[fn:hash]]        :: [[fn:rot13]]
		.......................................
		[[fn:htmlEncode]]  :: [[fn:htmlDecode]]
		.......................................
		[[fn:urlEncode]]   :: [[fn:urlDecode]]
		ELBAT::
		\\\\
		{{{{{Other Functions}}}}}
		\\\\
		{{{{Date &amp; Time}}}}
		\\\\
		::TABLE
		[[fn:date]]  :: [[fn:time]]    :: [[fn:dateItems]]
		...................................................
		[[fn:secs]]  :: [[fn:seconds]] :: [[fn:ticks]]
		ELBAT::
		\\\\
		{{{{List Manipulation}}}}
		\\\\
		::TABLE
		[[fn:head]]    :: [[fn:tail]]
		.................................
		[[fn:lconcat]] :: [[fn:lreverse]]
		.................................
		[[fn:llength]] :: [[fn:number]]
		ELBAT::
		\\\\
		{{{{Binary Data}}}}
		\\\\
		::TABLE
		[[fn:pack]] :: [[fn:unpack]]
		ELBAT::
		\\\\
		{{{{Sound}}}}
		\\\\
		::TABLE
		[[fn:sound]]  :: [[fn:speech]] :: [[fn:voice]]
		...............................................
		[[fn:sounds]] :: [[fn:tone]]   :: [[fn:voices]]
		ELBAT::
		\\\\
		{{{{Runtime State}}}}
		\\\\
		::TABLE
		[[fn:paramCount]]  :: [[fn:param]]   :: [[fn:params]]
		.....................................................
		[[fn:parent]]      :: [[fn:result]]  :: [[fn:value]]
		ELBAT::
		\\\\
		{{{{System Information}}}}
		\\\\
		::TABLE
		[[fn:systemName]]  :: [[fn:systemVersion]]
		...........................................
		[[fn:vmName]]      :: [[fn:vmVersion]]
		...........................................
		[[fn:javaName]]    :: [[fn:javaVersion]]
		...........................................
		[[fn:xionName]]    :: [[fn:xionVersion]]
		...........................................
		[[fn:version]]     ::  
		ELBAT::::TABLE
		[[fn:heapSpace]] :: [[fn:serialPorts]]
		ELBAT::
		\\\\
		{{{{File System}}}}
		\\\\
		::TABLE
		[[fn:appPath]]       :: [[fn:applicationPath]]           :: [[fn:progPath]]      :: [[fn:programPath]]
		.................................................................................................................
		[[fn:appFile]]       :: [[fn:applicationFile]]           :: [[fn:progFile]]      :: [[fn:programFile]]
		.................................................................................................................
		[[fn:docPath]]       :: [[fn:documentPath]]              :: [[fn:docFile]]       :: [[fn:documentFile]]
		.................................................................................................................
		[[fn:appOrDocPath]]  :: [[fn:applicationOrDocumentPath]] :: [[fn:progOrDocPath]] :: [[fn:programOrDocumentPath]]
		.................................................................................................................
		[[fn:appOrDocFile]]  :: [[fn:applicationOrDocumentFile]] :: [[fn:progOrDocFile]] :: [[fn:programOrDocumentFile]]
		.................................................................................................................
		[[fn:includePath]]   :: [[fn:includeFile]]               :: [[fn:path]]          ::  
		ELBAT::
	</content>
</article>

</documentationset>
