<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xiondoc PUBLIC "-//Kreative//DTD XIONDoc 1.3//EN" "xiondoc-1.3.dtd">
<xiondoc>

<summary>
	This is the official documentation for the XION scripting language
	and OpenXION, the reference implementation of XION.
	XION is a modern xTalk language based on the original HyperTalk.
	It is easy to learn and has the most English-like syntax
	of any programming language.
</summary>
<description>
	<p>
		This is the official documentation for the XION scripting language
		and OpenXION, the reference implementation of XION.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</p>
	<p>
		This manual describes every vocabulary term in XION and OpenXION
		in detail. It is intended to be used as a comprehensive reference
		for XION programmers. If you are just getting started with XION,
		the documentation may seem overwhelming at first, but over time
		you will find its depth and detail to be very useful.
		For a general introduction to XION programming,
		<a href="http://openxion.org">openxion.org</a>
		has a good tutorial and is available to help you.
	</p>
	<p>
		A particular implementation of XION is known as a <i>dialect</i>.
		OpenXION is just one such dialect. OpenXION not only provides all the
		standard XION features, but can also be extended through the use
		of <i>modules.</i> Dialects and modules are listed at the top left.
		Below the list of dialects and modules is a list of types of vocabulary
		terms, which you can use to narrow down the vocabulary you are
		looking for, as well as appendices for quick reference.
	</p>
</description>

<dialect>
	<name>xn</name>
	<title>XION Scripting Language Standard</title>
	<versions>1.0</versions>
	<summary>
		This is the official documentation for the XION Scripting
		Language Standard. XION is a modern xTalk language based
		on the original HyperTalk. It is easy to learn and has the
		most English-like syntax of any programming language.
	</summary>
	<description>
		<p>
			This is the official documentation for the XION Scripting
			Language Standard. XION is a modern xTalk language based
			on the original HyperTalk. It is easy to learn and has the
			most English-like syntax of any programming language.
		</p>
	</description>
</dialect>

<dialect>
	<name>oxn</name>
	<title>OpenXION</title>
	<versions>1.0, 1.1, 1.2, 1.3, 1.4</versions>
	<summary>
		This is the official documentation for OpenXION,
		the reference implementation of the XION Scripting Language Standard.
		XION is a modern xTalk language based on the original HyperTalk.
		It is easy to learn and has the most English-like syntax
		of any programming language.
	</summary>
	<description>
		<p>
			This is the official documentation for version <ver/> of OpenXION,
			the reference implementation of the XION Scripting Language Standard.
			XION is a modern xTalk language based on the original HyperTalk.
			It is easy to learn and has the most English-like syntax
			of any programming language.
		</p>
	</description>
</dialect>

<module>
	<name>oxnb</name>
	<title>OpenXION Base</title>
	<versions>1.0, 1.1, 1.2, 1.3, 1.4</versions>
	<summary>
		This is the official documentation for the core
		functionality of OpenXION.
	</summary>
	<description>
		<p>
			This is the official documentation for the core functionality
			of version <ver/> of OpenXION. These terms are always available
			regardless of which modules have been loaded.
		</p>
		<p>
			OpenXION is the reference implementation of XION, a modern
			xTalk language based on the original HyperTalk.
			It is easy to learn and has the most English-like syntax
			of any programming language.
		</p>
	</description>
</module>

<module>
	<name>oxns</name>
	<title>OpenXION Standard Module</title>
	<versions>1.0, 1.1, 1.2, 1.3, 1.4</versions>
	<summary>
		This is the official documentation for the standard
		functionality of OpenXION.
	</summary>
	<description>
		<p>
			This is the official documentation for the standard functionality
			of version <ver/> of OpenXION. These terms are loaded as part of
			the <code>XNStandardModule</code> module.
		</p>
		<p>
			OpenXION is the reference implementation of XION, a modern
			xTalk language based on the original HyperTalk.
			It is easy to learn and has the most English-like syntax
			of any programming language.
		</p>
	</description>
</module>

<module>
	<name>oxne</name>
	<title>OpenXION Extended Module</title>
	<versions>1.0, 1.1, 1.2, 1.3, 1.4</versions>
	<summary>
		This is the official documentation for the nonstandard
		functionality of OpenXION.
	</summary>
	<description>
		<p>
			This is the official documentation for the nonstandard functionality
			of version <ver/> of OpenXION. These terms are loaded as part of
			the <code>XNExtendedModule</code> module.
		</p>
		<p>
			OpenXION is the reference implementation of XION, a modern
			xTalk language based on the original HyperTalk.
			It is easy to learn and has the most English-like syntax
			of any programming language.
		</p>
	</description>
</module>

<module>
	<name>oxna</name>
	<title>OpenXION Audio Module</title>
	<versions>1.2, 1.3, 1.4</versions>
	<summary>
		This is the official documentation for the nonstandard audio-related
		functionality of OpenXION.
	</summary>
	<description>
		<p>
			This is the official documentation for the nonstandard audio-related
			functionality of version <ver/> of OpenXION. These terms are loaded
			as part of the <code>XNAudioModule</code> module.
		</p>
		<p>
			OpenXION is the reference implementation of XION, a modern
			xTalk language based on the original HyperTalk.
			It is easy to learn and has the most English-like syntax
			of any programming language.
		</p>
	</description>
</module>

<dialect>
	<name>hyp</name>
	<title>HyperTalk</title>
	<versions>2.2</versions>
	<summary>
		This is a subset of the documentation for OpenXION that includes
		only the parts of OpenXION that were originally present in HyperTalk.
		Only vocabulary terms available in both OpenXION and HyperTalk
		are listed here.
	</summary>
	<description>
		<p>
			This is a subset of the documentation for OpenXION that includes
			only the parts of OpenXION that were originally present in HyperTalk.
			Only vocabulary terms available in both OpenXION and HyperTalk
			are listed here.
		</p>
		<p>
			This may be useful for comparison, or if you are a HyperCard user
			who is getting started with OpenXION and is overwhelmed by all of
			OpenXION's additional functionality.
		</p>
	</description>
</dialect>

<operator>
	<name dialects="xn,oxn" modules="oxnb">if</name>
	<precedence>unary</precedence>
	<description-short>Conditional expression</description-short>
	<syntax>
		<syn>
			<me/> <mv>condition</mv> then <mv>true-expression</mv>
			else <mv>false-expression</mv>
		</syn>
		<p>
			<mv>Condition</mv> yields a <a>dt:boolean</a>.
			<mv>True-expression</mv> and <mv>false-expression</mv> yield
			any <a>dt:variant</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator introduces a conditional expression.
			If the condition given in the <kwd>if</kwd> clause is <a>cn:true</a>,
			the entire expression evaluates to the value given in the <kwd>then</kwd>
			clause. If the condition is <a>cn:false</a>, the entire expression
			evaluates to the value given in the <kwd>else</kwd> clause.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is short-circuited.
			If the condition given in the <kwd>if</kwd> clause is <a>cn:true</a>,
			only the expression given in the <kwd>then</kwd> clause is evaluated.
			If the condition given in the <kwd>if</kwd> clause is <a>cn:false</a>,
			only the expression given in the <kwd>else</kwd> clause is evaluated.
			Never are both expressions evaluated.
			This has considerable implications if either expression
			calls a function that has side-effects.
		</p>
	</notes>
	<see-also>
		cs:if, cs:switch
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">new</name>
	<name dialects="xn,oxn" modules="oxnb">a new</name>
	<precedence>unary</precedence>
	<description-short>Construction of objects</description-short>
	<syntax>
		<syn>
			<me/> <mv>type</mv>
		</syn>
		<p>
			<mv>Type</mv> is the name of a data type.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator constructs a new object of the specified
			<mv>type</mv> and evaluates to the new object.
		</p>
	</description>
	<notes>
		<p>
			If objects of the specified <mv>type</mv> cannot be constructed
			(as is the case with <a>dt:boolean</a> or <a>dt:number</a>),
			or if constructing a new object requires a name or ID number
			(as is the case with <a>dt:file</a>), a script error will be
			triggered.
		</p>
		<p>
			If <me/> is used with the <a>cm:create</a> command, the new
			object will be returned in the <code>it</code> variable.
		</p>
	</notes>
	<see-also>
		cm:create
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">−</name>
	<precedence>unary</precedence>
	<description-short>Negation for numbers</description-short>
	<syntax>
		<syn>
			<me/> <mv>factor</mv>
		</syn>
		<p>
			<mv>Factor</mv> yields an <a>dt:integer</a>, a <a>dt:number</a>,
			or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the negation of the given value.
			If the given value is positive, the evaluated value will be
			negative, and vice versa.
		</p>
	</description>
	<notes>
		<p>
			The data type of the evaluated value will be the same as the
			data type of the given value.
		</p>
	</notes>
	<see-also>
		op:-
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">not</name>
	<name dialects="xn,oxn" modules="oxnb">!</name>
	<precedence>unary</precedence>
	<description-short>Negation for boolean values</description-short>
	<syntax>
		<syn>
			<me/> <mv>factor</mv>
		</syn>
		<p>
			<mv>Factor</mv> yields a <a>dt:boolean</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the logical negation of the
			given value. If the given value is <a>cn:true</a>, the evaluated
			value will be <a>cn:false</a>, and vice versa.
		</p>
	</description>
	<see-also>
		op:bitnot
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">bitnot</name>
	<precedence>unary</precedence>
	<description-short>Bitwise negation</description-short>
	<syntax>
		<syn>
			<me/> <mv>factor</mv>
		</syn>
		<p>
			<mv>Factor</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the bitwise NOT of the given value.
			Each bit in the resulting value will be opposite the corresponding
			bit in the given value.
		</p>
	</description>
	<notes>
		<p>
			The expression <code><me/> <mv>x</mv></code> is equivalent
			to the expression <code>-<mv>x</mv>-1</code> when
			<mv>x</mv> is an <a>dt:integer</a>.
		</p>
	</notes>
	<see-also>
		op:not
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">there is a</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">there is an</name>
	<name dialects="xn,oxn" modules="oxnb">there's a</name>
	<name dialects="xn,oxn" modules="oxnb">there's an</name>
	<precedence>unary</precedence>
	<description-short>Boolean test for existence</description-short>
	<syntax>
		<syn>
			<me/> <mv>factor</mv>
		</syn>
		<p>
			<mv>Factor</mv> is a descriptor.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if a <a>dt:variant</a>
			with the given descriptor exists, or <a>cn:false</a> if no variant
			with the given descriptor exists.
		</p>
	</description>
	<see-also>
		op:there is not a, op:there is not an
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">there is not a</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">there is not an</name>
	<name dialects="xn,oxn" modules="oxnb">there isn't a</name>
	<name dialects="xn,oxn" modules="oxnb">there isn't an</name>
	<name dialects="xn,oxn" modules="oxnb">there is no</name>
	<name dialects="xn,oxn" modules="oxnb">there's no</name>
	<precedence>unary</precedence>
	<description-short>Boolean test for existence</description-short>
	<syntax>
		<syn>
			<me/> <mv>factor</mv>
		</syn>
		<p>
			<mv>Factor</mv> is a descriptor.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if no <a>dt:variant</a>
			with the given descriptor exists, or <a>cn:false</a> if a variant
			with the given descriptor does exist.
		</p>
	</description>
	<see-also>
		op:there is a, op:there is an
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">a reference to</name>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">reference to</name>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">a ref to</name>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">ref to</name>
	<precedence>unary</precedence>
	<description-short>Referencing</description-short>
	<syntax>
		<syn>
			<me/> <mv>factor</mv>
		</syn>
		<p>
			<mv>Factor</mv> is a descriptor.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to a <a>dt:reference</a> to a variant.
			References are most useful when you want to pass in a container
			to a command or function instead of the container's contents
			without requiring the creation of <a>dt:string</a>s resembling
			descriptors or the use of the <a>fn:value</a> function.
		</p>
	</description>
	<see-also>
		op:the referent of, dt:reference
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">the referent of</name>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">referent of</name>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">the ref of</name>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">ref of</name>
	<precedence>unary</precedence>
	<description-short>Dereferencing</description-short>
	<syntax>
		<syn>
			<me/> <mv>factor</mv>
		</syn>
		<p>
			<mv>Factor</mv> yields a <a>dt:reference</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the <a>dt:variant</a> to which
			the given <a>dt:reference</a> refers.
		</p>
	</description>
	<see-also>
		op:a reference to, dt:reference
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">^</name>
	<name dialects="xn,oxn" modules="oxnb">**</name>
	<precedence>exponentiation</precedence>
	<description-short>Exponentiation for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the exponentiation of the
			given values.
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
		<p>
			The <me/> operator has mathematically correct associativity
			but mathematically <i>incorrect</i> precedence. For example:
			The expression <code>2^3^2</code> will evaluate to the
			mathematically correct 512 (<code>2^(3^2)</code>) rather than
			the mathematically incorrect 64 (<code>(2^3)^2</code>).
			However, the expression <code>-2^2</code> will evaluate to
			the mathematically incorrect 4 (<code>(-2)^2</code>) rather
			than the mathematically correct -4 (<code>-(2^2)</code>).
		</p>
	</notes>
	<see-also>
		fn:pow
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">*</name>
	<name dialects="xn,oxn" modules="oxnb">·</name>
	<name dialects="xn,oxn" modules="oxnb">×</name>
	<precedence>multiplication</precedence>
	<description-short>Multiplication for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the product of the
			given values.
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
	</notes>
	<see-also>
		cm:multiply, fn:prod, fn:product
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">/</name>
	<name dialects="xn,oxn" modules="oxnb">÷</name>
	<precedence>multiplication</precedence>
	<description-short>Division for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the quotient of the
			given values.
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
	</notes>
	<see-also>
		cm:divide, op:quot, op:div, op:rem, op:mod
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">quot</name>
	<precedence>multiplication</precedence>
	<description-short>Division for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the truncated quotient of the
			given values.
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
		<p>
			The expression <code><mv>x</mv> <me/> <mv>y</mv></code> is
			equivalent to <code><a>fn:trunc</a>(<mv>x</mv>/<mv>y</mv>)</code>.
		</p>
	</notes>
	<see-also>
		cm:divide, op:/, op:div, op:rem, op:mod, fn:trunc
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">%</name>
	<name dialects="xn,oxn" modules="oxnb">rem</name>
	<precedence>multiplication</precedence>
	<description-short>Modulus for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the remainder after division
			of the given values.
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
		<p>
			The expression <code><mv>x</mv> <me/> <mv>y</mv></code> is equivalent to
			<code><mv>x</mv>-<mv>y</mv>*<a>fn:trunc</a>(<mv>x</mv>/<mv>y</mv>)</code>.
		</p>
	</notes>
	<see-also>
		cm:modulo, op:mod, op:/, op:quot, op:div, fn:trunc
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">div</name>
	<precedence>multiplication</precedence>
	<description-short>Division for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the floor of the quotient of the
			given values. (In HyperTalk, the <me/> operator evaluates to the
			truncated quotient instead.)
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
		<p>
			In XION, the expression <code><mv>x</mv> <me/> <mv>y</mv></code>
			is equivalent to <code><a>fn:floor</a>(<mv>x</mv>/<mv>y</mv>)</code>.
		</p>
	</notes>
	<compatibility>
		<p>
			In HyperTalk, the expression <code><mv>x</mv> <me/> <mv>y</mv></code>
			is equivalent to <code><a>fn:trunc</a>(<mv>x</mv>/<mv>y</mv>)</code>.
			What HyperTalk calls the <a>op:div</a> operator is implemented in
			XION as the <a>op:quot</a> operator instead. This does not change
			the value of the operator for positive values, but does change the
			value of the operator for negative values.
		</p>
	</compatibility>
	<see-also>
		cm:divide, op:/, op:quot, op:rem, op:mod, fn:floor, fn:trunc
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">mod</name>
	<precedence>multiplication</precedence>
	<description-short>Modulus for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the modulus of the given values.
			(In HyperTalk, the <me/> operator evaluates to the remainder after
			division instead.)
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
		<p>
			In XION, the expression <code><mv>x</mv> <me/> <mv>y</mv></code> is equivalent
			to <code><mv>x</mv>-<mv>y</mv>*<a>fn:floor</a>(<mv>x</mv>/<mv>y</mv>)</code>.
		</p>
	</notes>
	<compatibility>
		<p>
			In HyperTalk, the expression <code><mv>x</mv> <me/> <mv>y</mv></code> is equivalent
			to <code><mv>x</mv>-<mv>y</mv>*<a>fn:trunc</a>(<mv>x</mv>/<mv>y</mv>)</code>.
			What HyperTalk calls the <a>op:mod</a> operator is implemented in
			XION as the <a>op:rem</a> operator instead. This does not change
			the value of the operator for positive values, but does change the
			value of the operator for negative values.
		</p>
	</compatibility>
	<see-also>
		cm:modulo, op:rem, op:/, op:quot, op:div, fn:floor, fn:trunc
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">+</name>
	<precedence>addition</precedence>
	<description-short>Addition for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the sum of the given values.
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
	</notes>
	<see-also>
		cm:add, fn:sum
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">-</name>
	<precedence>addition</precedence>
	<description-short>Subtraction for numbers</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the difference between
			the given values.
		</p>
	</description>
	<notes>
		<p>
			If either given value is a <a>dt:complex</a>, the evaluated value
			will be a <a>dt:complex</a>. Otherwise, the evaluated value will
			be a <a>dt:number</a>.
		</p>
	</notes>
	<see-also>
		cm:subtract, op:−
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">&lt;&lt;</name>
	<precedence>bit shift</precedence>
	<description-short>Bitwise shift</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator shifts a given value a specified number of
			bits to the left.
		</p>
	</description>
	<notes>
		<p>
			The expression <code><mv>x</mv> <me/> <mv>y</mv></code> is
			equivalent to <code><mv>x</mv>*2^<mv>y</mv></code>
			when <mv>x</mv> and <mv>y</mv> are integers and the result
			is in the range of the <a>dt:integer</a> data type.
		</p>
		<p>
			In OpenXION, since the <a>dt:integer</a> data type has
			arbitrary range, no bits will ever be lost, and the value
			will never change sign.
		</p>
	</notes>
	<see-also>
		op:&gt;&gt;, op:&gt;&gt;&gt;
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">&gt;&gt;</name>
	<precedence>bit shift</precedence>
	<description-short>Bitwise shift</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator shifts a given value a specified number of
			bits to the right using sign extension. Missing bits are filled
			with the value of the most significant bit.
		</p>
	</description>
	<notes>
		<p>
			The expression <code><mv>x</mv> <me/> <mv>y</mv></code> is
			equivalent to <code><a>fn:floor</a>(<mv>x</mv>/2^<mv>y</mv>)</code>
			when <mv>x</mv> and <mv>y</mv> are integers.
		</p>
	</notes>
	<see-also>
		op:&lt;&lt;, op:&gt;&gt;&gt;
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">&gt;&gt;&gt;</name>
	<precedence>bit shift</precedence>
	<description-short>Bitwise shift</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator shifts a given value a specified number of
			bits to the right, without sign extension if possible.
			Missing bits are filled with zero.
		</p>
	</description>
	<notes>
		<p>
			The expression <code><mv>x</mv> <me/> <mv>y</mv></code> is
			equivalent to <code><a>fn:floor</a>(<mv>x</mv>/2^<mv>y</mv>)</code>
			when <mv>x</mv> and <mv>y</mv> are positive integers.
		</p>
		<p>
			In OpenXION, since the <a>dt:integer</a> data type has
			arbitrary range, <me/> is a synonym of <a>op:&gt;&gt;</a>.
		</p>
	</notes>
	<see-also>
		op:&lt;&lt;, op:&gt;&gt;
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">bitand</name>
	<precedence>bitwise and</precedence>
	<description-short>Bitwise AND</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the bitwise AND of the
			given values. Each bit in the evaluated value will be set
			if and only if both of the corresponding bits from each
			of the given values are set.
		</p>
	</description>
	<see-also>
		op:bitxor, op:bitor, op:and
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">bitxor</name>
	<precedence>bitwise xor</precedence>
	<description-short>Bitwise XOR</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the bitwise XOR of the
			given values. Each bit in the evaluated value will be set
			if and only if the corresponding bit from one of the
			given values is set but not the corresponding bit from
			the other given value.
		</p>
	</description>
	<see-also>
		op:bitand, op:bitor, op:xor
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">bitor</name>
	<precedence>bitwise or</precedence>
	<description-short>Bitwise OR</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Each <mv>expression</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the bitwise OR of the
			given values. Each bit in the evaluated value will be set
			if and only if at least one of the corresponding bits
			from each of the given values is set.
		</p>
	</description>
	<see-also>
		op:bitand, op:bitxor, op:or
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">&amp;</name>
	<name dialects="xn,oxn" modules="oxnb">||</name>
	<precedence>string concatenation</precedence>
	<description-short>Concatenation for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the concatenation of
			the given strings.
		</p>
	</description>
	<see-also>
		op:&amp;&amp;
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">&amp;&amp;</name>
	<precedence>string concatenation</precedence>
	<description-short>Concatenation for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the concatenation of
			the given strings, with a space inserted between the
			two strings.
		</p>
	</description>
	<see-also>
		op:&amp;
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">:</name>
	<name dialects="xn,oxn" modules="oxnb">::</name>
	<precedence>list concatenation</precedence>
	<description-short>Construction of lists</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to a new list containing
			all of the elements of the list on the left with the
			addition of the value on the right. If the left expression
			is a single value rather than a list, it will be converted
			to a list of one value.
		</p>
	</description>
	<compatibility>
		<p>
			In versions of OpenXION before 1.4, this operator
			was a synonym of <a>op:@</a>.
		</p>
	</compatibility>
	<see-also>
		op:@
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">@</name>
	<name dialects="xn,oxn" modules="oxnb">@@</name>
	<precedence>list concatenation</precedence>
	<description-short>Concatenation of lists</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the concatenation of the
			given lists. If either expression is a single value rather
			than a list, it will be converted to a list of one value.
		</p>
	</description>
	<see-also>
		op::
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">&lt;</name>
	<name dialects="xn,oxn" modules="oxnb">comes before</name>
	<name dialects="xn,oxn" modules="oxnb">is less than</name>
	<name dialects="xn,oxn" modules="oxnb">is smaller than</name>
	<name dialects="xn,oxn" modules="oxnb">is fewer than</name>
	<name dialects="xn,oxn" modules="oxnb">is before</name>
	<precedence>relational</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the two given values.
			If the first value is less than the second,
			the <me/> operator evaluates to <a>cn:true</a>.
			If the first value is greater than or equal to the second,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
		<p>
			If both given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If both given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&lt;=, op:lt, op:le, op:between,
		fn:decreasing, fn:descending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">&gt;</name>
	<name dialects="xn,oxn" modules="oxnb">comes after</name>
	<name dialects="xn,oxn" modules="oxnb">is greater than</name>
	<name dialects="xn,oxn" modules="oxnb">is bigger than</name>
	<name dialects="xn,oxn" modules="oxnb">is more than</name>
	<name dialects="xn,oxn" modules="oxnb">is after</name>
	<precedence>relational</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the two given values.
			If the first value is greater than the second,
			the <me/> operator evaluates to <a>cn:true</a>.
			If the first value is less than or equal to the second,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
		<p>
			If both given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If both given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&gt;=, op:gt, op:ge, op:between,
		fn:increasing, fn:ascending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">≤</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">&lt;=</name>
	<name dialects="xn,oxn" modules="oxnb">=&lt;</name>
	<name dialects="xn,oxn" modules="oxnb">is not greater than</name>
	<name dialects="xn,oxn" modules="oxnb">is not bigger than</name>
	<name dialects="xn,oxn" modules="oxnb">is not more than</name>
	<name dialects="xn,oxn" modules="oxnb">is not after</name>
	<name dialects="xn,oxn" modules="oxnb">isn't greater than</name>
	<name dialects="xn,oxn" modules="oxnb">isn't bigger than</name>
	<name dialects="xn,oxn" modules="oxnb">isn't more than</name>
	<name dialects="xn,oxn" modules="oxnb">isn't after</name>
	<precedence>relational</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the two given values.
			If the first value is less than or equal to the second,
			the <me/> operator evaluates to <a>cn:true</a>.
			If the first value is greater than the second,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
		<p>
			If both given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If both given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&lt;, op:lt, op:le, op:between,
		fn:decreasing, fn:descending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">≥</name>
	<name dialects="xn,oxn" modules="oxnb">=&gt;</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">&gt;=</name>
	<name dialects="xn,oxn" modules="oxnb">is not less than</name>
	<name dialects="xn,oxn" modules="oxnb">is not smaller than</name>
	<name dialects="xn,oxn" modules="oxnb">is not fewer than</name>
	<name dialects="xn,oxn" modules="oxnb">is not before</name>
	<name dialects="xn,oxn" modules="oxnb">isn't less than</name>
	<name dialects="xn,oxn" modules="oxnb">isn't smaller than</name>
	<name dialects="xn,oxn" modules="oxnb">isn't fewer than</name>
	<name dialects="xn,oxn" modules="oxnb">isn't before</name>
	<precedence>relational</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the two given values.
			If the first value is greater than or equal to the second,
			the <me/> operator evaluates to <a>cn:true</a>.
			If the first value is less than the second,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
		<p>
			If both given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If both given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&gt;, op:gt, op:ge, op:between,
		fn:increasing, fn:ascending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">lt</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the two given values as strings.
			If the first string is less than the second,
			the <me/> operator evaluates to <a>cn:true</a>.
			If the first string is greater than or equal to the second,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&lt;, op:&lt;=, op:le, op:between,
		fn:decreasing, fn:descending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">gt</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
		The <me/> operator
		</p>
		<p>
			The <me/> operator compares the two given values as strings.
			If the first string is greater than the second,
			the <me/> operator evaluates to <a>cn:true</a>.
			If the first string is less than or equal to the second,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&gt;, op:&gt;=, op:ge, op:between,
		fn:increasing, fn:ascending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">le</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the two given values as strings.
			If the first string is less than or equal to the second,
			the <me/> operator evaluates to <a>cn:true</a>.
			If the first string is greater than the second,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&lt;, op:&lt;=, op:lt, op:between,
		fn:decreasing, fn:descending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">ge</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the two given values as strings.
			If the first string is greater than or equal to the second,
			the <me/> operator evaluates to <a>cn:true</a>.
			If the first string is less than the second,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&gt;, op:&gt;=, op:gt, op:between,
		fn:increasing, fn:ascending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">between</name>
	<name dialects="xn,oxn" modules="oxnb">is between</name>
	<precedence>relational</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv> and <mv>expression</mv>
			<opt><ch>
				<ci>
					<opt><ch>
						<ci>left</ci>
						<ci>right</ci>
					</ch></opt>
					inclusive
				</ci>
				<ci>exclusive</ci>
			</ch></opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the given value on the left
			to the two given values on the right.
			If the first given value falls between the second and third,
			the <me/> operator evaluates to <a>cn:true</a>.
			Otherwise, the <me/> operator evaluates to <a>cn:false</a>.
		</p>
		<p>
			The <kwd>inclusive</kwd>, <kwd>left-inclusive</kwd>,
			<kwd>right-inclusive</kwd>, and <kwd>exclusive</kwd> options
			specify the <me/> operator's behavior when the first value
			is equal to the second or third. If the first value is equal
			to the second, <me/> will evaluate to <a>cn:true</a> only if
			<kwd>inclusive</kwd> or <kwd>left-inclusive</kwd> is specified.
			If the first value is equal to the third, <me/> will evaluate
			to <a>cn:true</a> only if <kwd>inclusive</kwd> or
			<kwd>right-inclusive</kwd> is specified. If none of these
			options is specified, <kwd>inclusive</kwd> is assumed to be
			the default.
		</p>
		<p>
			If all given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If all given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&lt;, op:&lt;=, op:&gt;, op:&gt;=,
		op:lt, op:le, op:gt, op:ge, op:not between,
		fn:increasing, fn:ascending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">is not between</name>
	<name dialects="xn,oxn" modules="oxnb">isn't between</name>
	<name dialects="xn,oxn" modules="oxnb">not between</name>
	<precedence>relational</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv> and <mv>expression</mv>
			<opt><ch>
				<ci>
					<opt><ch>
						<ci>left</ci>
						<ci>right</ci>
					</ch></opt>
					inclusive
				</ci>
				<ci>exclusive</ci>
			</ch></opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator compares the given value on the left
			to the two given values on the right.
			If the first given value falls between the second and third,
			the <me/> operator evaluates to <a>cn:false</a>.
			Otherwise, the <me/> operator evaluates to <a>cn:true</a>.
		</p>
		<p>
			The <kwd>inclusive</kwd>, <kwd>left-inclusive</kwd>,
			<kwd>right-inclusive</kwd>, and <kwd>exclusive</kwd> options
			specify the <me/> operator's behavior when the first value
			is equal to the second or third. If the first value is equal
			to the second, <me/> will evaluate to <a>cn:false</a> only if
			<kwd>inclusive</kwd> or <kwd>left-inclusive</kwd> is specified.
			If the first value is equal to the third, <me/> will evaluate
			to <a>cn:false</a> only if <kwd>inclusive</kwd> or
			<kwd>right-inclusive</kwd> is specified. If none of these
			options is specified, <kwd>inclusive</kwd> is assumed to be
			the default.
		</p>
		<p>
			If all given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If all given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&lt;, op:&lt;=, op:&gt;, op:&gt;=,
		op:lt, op:le, op:gt, op:ge, op:between,
		fn:increasing, fn:ascending,
		fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">contains</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the string to
			the left of the operator contains the string to the right of the
			operator as a substring. Otherwise, it evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csoffset</a> function.
		</p>
	</notes>
	<see-also>
		op:is in, op:starts with, op:ends with, op:does not contain,
		op:is not in, op:does not start with, op:does not end with,
		fn:offset, fn:csoffset
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">does not contain</name>
	<name dialects="xn,oxn" modules="oxnb">doesn't contain</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the string to
			the left of the operator <i>does not</i> contain the string to
			the right of the operator as a substring. Otherwise, it evaluates
			to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csoffset</a> function.
		</p>
	</notes>
	<see-also>
		op:is not in, op:does not start with, op:does not end with,
		op:contains, op:is in, op:starts with, op:ends with,
		fn:offset, fn:csoffset
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">begins with</name>
	<name dialects="xn,oxn" modules="oxnb">starts with</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the string to
			the left of the operator starts with the string to the right of
			the operator. Otherwise, it evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csoffset</a> function.
		</p>
	</notes>
	<see-also>
		op:contains, op:is in, op:ends with, op:does not contain,
		op:is not in, op:does not start with, op:does not end with,
		fn:offset, fn:csoffset
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">does not begin with</name>
	<name dialects="xn,oxn" modules="oxnb">does not start with</name>
	<name dialects="xn,oxn" modules="oxnb">doesn't begin with</name>
	<name dialects="xn,oxn" modules="oxnb">doesn't start with</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the string to
			the left of the operator <i>does not</i> start with the string to
			the right of the operator. Otherwise, it evaluates to
			<a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csoffset</a> function.
		</p>
	</notes>
	<see-also>
		op:does not contain, op:is not in, op:does not end with,
		op:contains, op:is in, op:starts with, op:ends with,
		fn:offset, fn:csoffset
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">ends with</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the string to
			the left of the operator ends with the string to the right of
			the operator. Otherwise, it evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csoffset</a> function.
		</p>
	</notes>
	<see-also>
		op:contains, op:is in, op:starts with, op:does not contain,
		op:is not in, op:does not start with, op:does not end with,
		fn:offset, fn:csoffset
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">does not end with</name>
	<name dialects="xn,oxn" modules="oxnb">doesn't end with</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the string to
			the left of the operator <i>does not</i> end with the string to
			the right of the operator. Otherwise, it evaluates to
			<a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csoffset</a> function.
		</p>
	</notes>
	<see-also>
		op:does not contain, op:is not in, op:does not start with,
		op:contains, op:is in, op:starts with, op:ends with,
		fn:offset, fn:csoffset
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">is in</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">is of</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the string to
			the right of the operator contains the string to the left of the
			operator as a substring. Otherwise, it evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csoffset</a> function.
		</p>
	</notes>
	<see-also>
		op:contains, op:starts with, op:ends with, op:does not contain,
		op:is not in, op:does not start with, op:does not end with,
		fn:offset, fn:csoffset
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">is not in</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">is not of</name>
	<name dialects="xn,oxn" modules="oxnb">isn't in</name>
	<name dialects="xn,oxn" modules="oxnb">isn't of</name>
	<precedence>relational</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the string to
			the right of the operator <i>does not</i> contain the string to
			the left of the operator as a substring. Otherwise, it evaluates
			to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csoffset</a> function.
		</p>
	</notes>
	<see-also>
		op:does not contain, op:does not start with, op:does not end with,
		op:contains, op:is in, op:starts with, op:ends with,
		fn:offset, fn:csoffset
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">is within</name>
	<precedence>relational</precedence>
	<description-short>Boolean test for point within rectangle</description-short>
	<syntax>
		<syn>
			<mv>left-expression</mv> <me/> <mv>right-expression</mv>
		</syn>
		<p>
			<mv>Left-expression</mv> yields a <a>dt:point</a> or a
			<a>dt:rectangle</a>. <mv>Right-expression</mv> yields a
			<a>dt:rectangle</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the
			<a>dt:rectangle</a> specified on the right of the operator
			contains the <a>dt:point</a> specified on the left,
			or intersects the <a>dt:rectangle</a> specified on the left.
			Otherwise, it evaluates to <a>cn:false</a>.
		</p>
	</description>
	<compatibility>
		<p>
			HyperTalk only supports testing for a point inside a rectangle.
			It does not support testing for the intersection of two rectangles.
		</p>
	</compatibility>
	<see-also>
		op:is not within
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">is not within</name>
	<name dialects="xn,oxn" modules="oxnb">isn't within</name>
	<precedence>relational</precedence>
	<description-short>Boolean test for point within rectangle</description-short>
	<syntax>
		<syn>
			<mv>left-expression</mv> <me/> <mv>right-expression</mv>
		</syn>
		<p>
			<mv>Left-expression</mv> yields a <a>dt:point</a> or a
			<a>dt:rectangle</a>. <mv>Right-expression</mv> yields a
			<a>dt:rectangle</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the
			<a>dt:rectangle</a> specified on the right of the operator
			<i>does not</i> contain the <a>dt:point</a> specified on the left,
			or <i>does not</i> intersect the <a>dt:rectangle</a> specified
			on the left. Otherwise, it evaluates to <a>cn:false</a>.
		</p>
	</description>
	<compatibility>
		<p>
			HyperTalk only supports testing for a point inside a rectangle.
			It does not support testing for the intersection of two rectangles.
		</p>
	</compatibility>
	<see-also>
		op:is within
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">is an element of</name>
	<name dialects="xn,oxn" modules="oxnb">is an element in</name>
	<precedence>relational</precedence>
	<description-short>Comparison for lists</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>list</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if any of the
			elements of the given <mv>list</mv> are equal to the given
			<mv>expression</mv>. If none of the elements of the given
			<mv>list</mv> are equal to the given <mv>expression</mv>,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			Equality is determined as specified for the <a>op:=</a> operator.
			For a stricter definition of equality (as specified for the
			<a>op:===</a> operator), see <a>op:is precisely an element of</a>.
		</p>
	</notes>
	<see-also>
		op:is precisely an element of, op:is not an element of,
		op:is not precisely an element of
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">is not an element of</name>
	<name dialects="xn,oxn" modules="oxnb">is not an element in</name>
	<name dialects="xn,oxn" modules="oxnb">isn't an element of</name>
	<name dialects="xn,oxn" modules="oxnb">isn't an element in</name>
	<precedence>relational</precedence>
	<description-short>Comparison for lists</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>list</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if none of the
			elements of the given <mv>list</mv> are equal to the given
			<mv>expression</mv>. If any of the elements of the given
			<mv>list</mv> are equal to the given <mv>expression</mv>,
			the <me/> operator evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			Equality is determined as specified for the <a>op:=</a> operator.
			For a stricter definition of equality (as specified for the
			<a>op:===</a> operator), see <a>op:is not precisely an element
			of</a>.
		</p>
	</notes>
	<see-also>
		op:is an element of, op:is precisely an element of,
		op:is not precisely an element of
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">is precisely an element of</name>
	<name dialects="xn,oxn" modules="oxnb">is precisely an element in</name>
	<precedence>relational</precedence>
	<description-short>Comparison for lists</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>list</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if any of the
			elements of the given <mv>list</mv> are the same type as and
			identical to the given <mv>expression</mv>. Otherwise, it
			evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			For a looser definition of equality (as specified for the
			<a>op:=</a> operator as opposed to the <a>op:===</a> operator),
			see <a>op:is an element of</a>.
		</p>
	</notes>
	<see-also>
		op:is an element of, op:is not an element of,
		op:is not precisely an element of
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">is not precisely an element of</name>
	<name dialects="xn,oxn" modules="oxnb">is not precisely an element in</name>
	<name dialects="xn,oxn" modules="oxnb">isn't precisely an element of</name>
	<name dialects="xn,oxn" modules="oxnb">isn't precisely an element in</name>
	<precedence>relational</precedence>
	<description-short>Comparison for lists</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>list</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if none of the
			elements of the given <mv>list</mv> are the same type as and
			identical to the given <mv>expression</mv>. Otherwise, it
			evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			For a looser definition of equality (as specified for the
			<a>op:=</a> operator as opposed to the <a>op:===</a> operator),
			see <a>op:is not an element of</a>.
		</p>
	</notes>
	<see-also>
		op:is an element of, op:is precisely an element of,
		op:is not an element of
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">is an</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">is a</name>
	<name dialects="xn,oxn" modules="oxnb">isa</name>
	<name dialects="xn,oxn" modules="oxnb">instanceof</name>
	<name dialects="xn,oxn" modules="oxnb">are</name>
	<precedence>polymorphic</precedence>
	<description-short>Comparison for types</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>type</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the given
			value can be converted to the given type. If the given value
			cannot be converted to the given type, the <me/> operator
			evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			In HyperTalk, you can only use <me/> to test if some value is
			an <a>dt:integer</a>, a <a>dt:number</a>, a <a>dt:date</a>, a
			<a>dt:point</a>, or a <a>dt:rectangle</a>. However, the test
			for a <a>dt:date</a> will accept just about any string to the
			point of being nearly useless, and the tests for <a>dt:point</a>
			and <a>dt:rectangle</a> are broken: if the value is not a
			comma-delimited list of integers, the expression will trigger
			an "Expected integer here" script error instead of evaluating
			to <a>cn:false</a>. XION will only consider something a
			<a>dt:date</a> if it can actually be converted to one, and
			will never trigger a script error when evaluating the <me/>
			operator.
		</p>
	</notes>
	<see-also>
		op:is not a, op:is precisely a, op:is not precisely a, op:as a
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">is not an</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">is not a</name>
	<name dialects="xn,oxn" modules="oxnb">isn't an</name>
	<name dialects="xn,oxn" modules="oxnb">isn't a</name>
	<name dialects="xn,oxn" modules="oxnb">are not</name>
	<name dialects="xn,oxn" modules="oxnb">aren't</name>
	<precedence>polymorphic</precedence>
	<description-short>Comparison for types</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>type</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the given
			value <i>cannot</i> be converted to the given type. If the
			given value <i>can</i> be converted to the given type, the
			<me/> operator evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			In HyperTalk, you can only use <me/> to test if some value is
			not an <a>dt:integer</a>, a <a>dt:number</a>, a <a>dt:date</a>,
			a <a>dt:point</a>, or a <a>dt:rectangle</a>. However, the test
			for a <a>dt:date</a> will reject just about any string to the
			point of being nearly useless, and the tests for <a>dt:point</a>
			and <a>dt:rectangle</a> are broken: if the value is not a
			comma-delimited list of integers, the expression will trigger
			an "Expected integer here" script error instead of evaluating
			to <a>cn:true</a>. XION will always consider something not a
			<a>dt:date</a> if it cannot actually be converted to one, and
			will never trigger a script error when evaluating the <me/>
			operator.
		</p>
	</notes>
	<see-also>
		op:is a, op:is precisely a, op:is not precisely a, op:as a
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">are precisely</name>
	<name dialects="xn,oxn" modules="oxnb">is precisely an</name>
	<name dialects="xn,oxn" modules="oxnb">is precisely a</name>
	<precedence>polymorphic</precedence>
	<description-short>Comparison for types</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>type</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the given
			value's data type is the given type. If the given value's
			data type is not the given type, the <me/> operator evaluates
			to <a>cn:false</a>. This is a stricter requirement than the
			one for the <a>op:is an</a> operator: the value must be
			compatible with the given type without requiring conversion
			(from a <a>dt:number</a> to a <a>dt:string</a>, for example).
		</p>
	</description>
	<see-also>
		op:is a, op:is not a, op:is not precisely a, op:as a
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">are not precisely</name>
	<name dialects="xn,oxn" modules="oxnb">aren't precisely</name>
	<name dialects="xn,oxn" modules="oxnb">is not precisely an</name>
	<name dialects="xn,oxn" modules="oxnb">is not precisely a</name>
	<name dialects="xn,oxn" modules="oxnb">isn't precisely an</name>
	<name dialects="xn,oxn" modules="oxnb">isn't precisely a</name>
	<precedence>polymorphic</precedence>
	<description-short>Comparison for types</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>type</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the given
			value's data type is <i>not</i> the given type. If the given
			value's data type <i>is</i> the given type, the <me/> operator
			evaluates to <a>cn:false</a>. This is a stricter requirement
			than the one for the <a>op:is not an</a> operator: the value
			must be compatible with the given type without requiring
			conversion (from a <a>dt:number</a> to a <a>dt:string</a>,
			for example).
		</p>
	</description>
	<see-also>
		op:is a, op:is not a, op:is precisely a, op:as a
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">as an</name>
	<name dialects="xn,oxn" modules="oxnb">as a</name>
	<name dialects="xn,oxn" modules="oxnb">as</name>
	<precedence>polymorphic</precedence>
	<description-short>Conversion for types</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>type</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator converts the given value to the given
			data type. If the given value cannot be converted to the
			given data type, a script error is triggered.
		</p>
	</description>
	<notes>
		<p>
			To avoid triggering a script error, use the <a>op:is a</a>
			operator before trying to convert values.
		</p>
	</notes>
	<see-also>
		op:is a, op:is not a
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">=</name>
	<name dialects="xn,oxn" modules="oxnb">==</name>
	<name dialects="xn,oxn" modules="oxnb">equals</name>
	<name dialects="xn,oxn" modules="oxnb">is equal to</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">is</name>
	<precedence>equivalence</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the given
			values are equal. Otherwise, it evaluates to <a>cn:false</a>.
		</p>
		<p>
			If both given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If both given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison with the <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function
			or the <a>op:===</a> operator.
		</p>
	</notes>
	<see-also>
		op:===, op:eq, op:strcmp, op:csstrcmp, fn:equal
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">&lt;&gt;</name>
	<name dialects="xn,oxn" modules="oxnb">≠≠</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">≠</name>
	<name dialects="xn,oxn" modules="oxnb">!=</name>
	<name dialects="xn,oxn" modules="oxnb">does not equal</name>
	<name dialects="xn,oxn" modules="oxnb">doesn't equal</name>
	<name dialects="xn,oxn" modules="oxnb">is not equal to</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">is not</name>
	<name dialects="xn,oxn" modules="oxnb">isn't equal to</name>
	<name dialects="xn,oxn" modules="oxnb">isn't</name>
	<precedence>equivalence</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:false</a> if the given
			values are equal. Otherwise, it evaluates to <a>cn:true</a>.
		</p>
		<p>
			If both given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If both given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison with the <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function
			or the <a>op:!==</a> operator.
		</p>
	</notes>
	<see-also>
		op:!==, op:ne, op:strcmp, op:csstrcmp, fn:equal
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">===</name>
	<name dialects="xn,oxn" modules="oxnb">is exactly</name>
	<precedence>equivalence</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the given
			values have the same type and are identical. Otherwise, it
			evaluates to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			String comparison with the <me/> operator is case-sensitive.
			For case-insensitive comparison, use the <a>op:=</a> or
			<a>op:eq</a> operator.
		</p>
	</notes>
	<see-also>
		op:=, op:eq, op:strcmp, op:csstrcmp, fn:equal
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">!==</name>
	<name dialects="xn,oxn" modules="oxnb">≠≠≠</name>
	<name dialects="xn,oxn" modules="oxnb">is not exactly</name>
	<name dialects="xn,oxn" modules="oxnb">isn't exactly</name>
	<precedence>equivalence</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:false</a> if the given
			values have the same type and are identical. Otherwise, it
			evaluates to <a>cn:true</a>.
		</p>
	</description>
	<notes>
		<p>
			String comparison with the <me/> operator is case-sensitive.
			For case-insensitive comparison, use the <a>op:!=</a> or
			<a>op:ne</a> operator.
		</p>
	</notes>
	<see-also>
		op:!=, op:ne, op:strcmp, op:csstrcmp, fn:equal
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">eq</name>
	<precedence>equivalence</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:true</a> if the given
			values are equal as strings. Otherwise, it evaluates to
			<a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			String comparison with the <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a>
			function or the <a>op:===</a> operator.
		</p>
	</notes>
	<see-also>
		op:=, op:===, op:strcmp, op:csstrcmp, fn:equal
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">ne</name>
	<precedence>equivalence</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to <a>cn:false</a> if the given
			values are equal as strings. Otherwise, it evaluates to
			<a>cn:true</a>.
		</p>
	</description>
	<notes>
		<p>
			String comparison with the <me/> operator is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a>
			function or the <a>op:!==</a> operator.
		</p>
	</notes>
	<see-also>
		op:!=, op:!==, op:strcmp, op:csstrcmp, fn:equal
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">&lt;=&gt;</name>
	<precedence>equivalence</precedence>
	<description-short>Comparison for numbers or strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the comparison of the two
			given values. The evaluated value will be negative if the
			first given value is less than the second given value,
			positive if the first is greater than the second, and zero
			if the first is equal to the second.
		</p>
		<p>
			If both given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically.
			If both given values are <a>dt:date</a>s,
			the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:cmp, fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">cmp</name>
	<name dialects="xn,oxn" modules="oxnb">compared to</name>
	<precedence>equivalence</precedence>
	<description-short>Comparison for strings</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the comparison of the two
			given values as strings. The evaluated value will be negative
			if the first given value is less than the second given value,
			positive if the first is greater than the second, and zero
			if the first is equal to the second.
		</p>
	</description>
	<notes>
		<p>
			String comparison is case-insensitive.
			For case-sensitive comparison, use the <a>fn:csstrcmp</a> function.
		</p>
	</notes>
	<see-also>
		op:&lt;=&gt;, fn:strcmp, fn:csstrcmp
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">and</name>
	<precedence>boolean and</precedence>
	<description-short>Logical AND for boolean values</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Both <mv>expression</mv>s yield <a>dt:boolean</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the logical AND of the given
			boolean values. Both values must be <a>cn:true</a> for the
			expression to evaluate to <a>cn:true</a>. If either value is
			<a>cn:false</a>, the expression will evaluate to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is <i>not</i> short-circuited. Both
			expressions will be evaluated to determine the truth value
			of the whole expression. (This has considerable implications
			if either expression calls a function that has side-effects.
			For a short-circuited version of the <me/> operator, use the
			<a>op:&amp;&amp;&amp;</a> operator.)
		</p>
	</notes>
	<see-also>
		op:&amp;&amp;&amp;, op:xor, op:or, op:|||
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">&amp;&amp;&amp;</name>
	<precedence>boolean and</precedence>
	<description-short>Logical AND for boolean values</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Both <mv>expression</mv>s yield <a>dt:boolean</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the logical AND of the given
			boolean values. Both values must be <a>cn:true</a> for the
			expression to evaluate to <a>cn:true</a>. If either value is
			<a>cn:false</a>, the expression will evaluate to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is short-circuited. If the first expression
			is <a>cn:false</a>, the second expression will not be evaluated.
			Only when the first expression is <a>cn:true</a> will the second
			expression be evaluated to determine the truth value of the
			whole expression. (This has considerable implications if either
			expression calls a function that has side-effects. For a
			non-short-circuited version of the <me/> operator, use the
			<a>op:and</a> operator.)
		</p>
	</notes>
	<see-also>
		op:and, op:xor, op:or, op:|||
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">^^^</name>
	<name dialects="xn,oxn" modules="oxnb">xor</name>
	<precedence>boolean xor</precedence>
	<description-short>Logical XOR for boolean values</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Both <mv>expression</mv>s yield <a>dt:boolean</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the logical exclusive OR of the
			given boolean values. Exactly one of the given values must be
			<a>cn:true</a> for the expression to evaluate to <a>cn:true</a>.
			If both values are <a>cn:true</a> or both values are
			<a>cn:false</a>, the expression will evaluate to <a>cn:false</a>.
		</p>
	</description>
	<see-also>
		op:and, op:&amp;&amp;&amp;, op:or, op:|||
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn,hyp" modules="oxnb">or</name>
	<precedence>boolean or</precedence>
	<description-short>Logical OR for boolean values</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Both <mv>expression</mv>s yield <a>dt:boolean</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the logical OR of the given
			boolean values. Either one value or both values must be
			<a>cn:true</a> for the expression to evaluate to <a>cn:true</a>.
			If both values are <a>cn:false</a>, the expression will
			evaluate to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is <i>not</i> short-circuited. Both
			expressions will be evaluated to determine the truth value of
			the whole expression. (This has considerable implications if
			either expression calls a function that has side-effects.
			For a short-circuited version of the <me/> operator, use the
			<a>op:|||</a> operator.)
		</p>
	</notes>
	<see-also>
		op:and, op:&amp;&amp;&amp;, op:xor, op:|||
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">|||</name>
	<precedence>boolean or</precedence>
	<description-short>Logical OR for boolean values</description-short>
	<syntax>
		<syn>
			<mv>expression</mv> <me/> <mv>expression</mv>
		</syn>
		<p>
			Both <mv>expression</mv>s yield <a>dt:boolean</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> operator evaluates to the logical OR of the given
			boolean values. Either one value or both values must be
			<a>cn:true</a> for the expression to evaluate to <a>cn:true</a>.
			If both values are <a>cn:false</a>, the expression will
			evaluate to <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> operator is short-circuited. If the first expression
			is <a>cn:true</a>, the second expression will not be evaluated.
			Only when the first expression is <a>cn:false</a> will the second
			expression be evaluated to determine the truth value of the whole
			expression. (This has considerable implications if either
			expression calls a function that has side-effects.
			For a non-short-circuited version of the <me/> operator, use
			the <a>op:or</a> operator.)
		</p>
	</notes>
	<see-also>
		op:and, op:&amp;&amp;&amp;, op:xor, op:or
	</see-also>
</operator>

<operator>
	<name dialects="xn,oxn" modules="oxnb">,</name>
	<precedence>list construction</precedence>
	<description-short>Construction of lists</description-short>
	<syntax>
		<syn>
			<mv>expression</mv>
			<opt>
				<me/> <mv>expression</mv>
				<opt>...</opt>
			</opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> operator is used to delimit <a>dt:element</a>s
			of the <a>dt:list</a> the <me/> operator evaluates to.
		</p>
	</description>
	<see-also>
		op::, op:@
	</see-also>
</operator>

<structure>
	<name dialects="xn,oxn" modules="oxnb">to create</name>
	<syntax>
		<syn>
			<me/>
			<br indent="1"/><mv>statementList</mv><br/>
			end create
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> handler defines the behavior of a user-defined object
			when it is created. When a script requests the creation of a
			user-defined object, the object is created, then the object is
			assigned a number, an id, and a name, then the statements in
			the <me/> handler are executed.
		</p>
	</description>
	<notes>
		<p>
			This structure is only valid inside an <a>cs:object type</a>
			structure.
		</p>
	</notes>
	<see-also>
		cs:object type, cm:create, op:new
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">to delete</name>
	<syntax>
		<syn>
			<me/>
			<br indent="1"/><mv>statementList</mv><br/>
			end delete
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> handler defines the behavior of a user-defined object
			when it is deleted. When a script requests the deletion of a
			user-defined object, the statements in the <me/> handler are
			executed, then the object is destroyed, then other objects are
			assigned new numbers.
		</p>
	</description>
	<notes>
		<p>
			This structure is only valid inside an <a>cs:object type</a>
			structure.
		</p>
	</notes>
	<see-also>
		cs:object type, cm:delete
	</see-also>
</structure>

<structure>
	<name dialects="oxn&lt;1.3" modules="oxnb&lt;1.3">to get contents</name>
	<syntax>
		<syn>
			<me/>
			<br indent="1"/><mv>statementList</mv><br/>
			end get
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> handler defines the behavior of a user-defined object
			when its contents are accessed or it is converted to a string.
			When a script requests the contents of a user-defined object, or
			converts the object to a string, the statements in the <me/>
			handler are executed, and the return value of the handler becomes
			the resulting string.
		</p>
		<p>
			If no <me/> handler is defined for a user-defined object type,
			objects of that type cannot be accessed as containers, and
			converting an object of that type to a string results
			in a descriptor for that object.
		</p>
	</description>
	<notes>
		<p>
			This structure is only valid inside an <a>cs:object type</a>
			structure.
		</p>
	</notes>
	<compatibility>
		<p>
			In OpenXION 1.3 or later, due to a more correct understanding
			of how containers work, user-defined objects can no longer be
			containers, and this structure is no longer supported.
		</p>
	</compatibility>
	<see-also>
		cs:object type, cm:get
	</see-also>
</structure>

<structure>
	<name dialects="oxn&lt;1.3" modules="oxnb&lt;1.3">to put contents</name>
	<syntax>
		<syn>
			to put <mv>variableName</mv>
			<ch>
				<ci>into</ci>
				<ci>before</ci>
				<ci>after</ci>
			</ch>
			contents
			<br indent="1"/><mv>statementList</mv><br/>
			end put
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> handler defines the behavior of a user-defined object
			when its contents are modified by the <a>cm:put</a> command.
			When a script modifies the contents of a user-defined object,
			the statements in the <me/> handler are executed. The value
			being put into, before, or after the object's contents is passed
			through the local variable <mv>variableName</mv>.
		</p>
		<p>
			If no <me/> handler is defined for a user-defined object type,
			objects of that type cannot be modified as containers.
		</p>
	</description>
	<notes>
		<p>
			Unlike parameters to an <a>cs:on</a> or a <a>cs:function</a>
			handler, which are converted to <a>dt:string</a>s unless
			declared otherwise, the parameter to a <me/> handler is
			kept as-is, as if declared as a <a>dt:variant</a>.
		</p>
		<p>
			This structure is only valid inside an <a>cs:object type</a>
			structure.
		</p>
	</notes>
	<compatibility>
		<p>
			In OpenXION 1.3 or later, due to a more correct understanding
			of how containers work, user-defined objects can no longer be
			containers, and this structure is no longer supported.
		</p>
	</compatibility>
	<see-also>
		cs:object type, cm:put
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">to get</name>
	<syntax>
		<syn>
			<me/> <mv>propertyName</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			end get
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> handler defines the behavior of a user-defined object
			when property <mv>propertyName</mv> is accessed. When a script
			requests <a>kw:the</a> <mv>propertyName</mv> <a>kw:of</a> a
			user-defined object, the statements in the corresponding <me/>
			handler are executed, and the return value of the handler
			becomes the value of the property.
		</p>
	</description>
	<notes>
		<p>
			This structure is only valid inside an <a>cs:object type</a>
			structure.
		</p>
	</notes>
	<see-also>
		cs:object type, cm:get
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">to set</name>
	<syntax>
		<syn>
			<me/> <mv>propertyName</mv> to <mv>variableName</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			end set
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> handler defines the behavior of a user-defined object
			when property <a>propertyName</a> is set. When a script sets
			<a>kw:the</a> <mv>propertyName</mv> <a>kw:of</a> a user-defined
			object, the statements in the corresponding <me/> handler are
			executed. The new value of the property is passed through the
			local variable <mv>variableName</mv>.
		</p>
	</description>
	<notes>
		<p>
			Unlike parameters to an <a>cs:on</a> or a <a>cs:function</a>
			handler, which are converted to <a>dt:string</a>s unless
			declared otherwise, the parameter to a <me/> handler is
			kept as-is, as if declared as a <a>dt:variant</a>.
		</p>
		<p>
			This structure is only valid inside an <a>cs:object type</a>
			structure.
		</p>
	</notes>
	<see-also>
		cs:object type, cm:set
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">object type</name>
	<syntax>
		<syn>
			<me/> <mv>typeNames</mv>
			<opt>extends <mv>parentTypeName</mv></opt>
			<br indent="1"/><mv>handlerList</mv><br/>
			end <mv>firstTypeName</mv>
		</syn>
		<p>
			<mv>TypeNames</mv> is a series of data type names, in which
			every name except the first is prefixed with the keyword
			<a>cs:aka</a> for a singular synonym or the keyword <a>cs:pl</a>
			for a plural name or synonym. Names can be more than one word long:
		</p>
		<scr>
			object type fraction aka rational number pl fractions pl rational numbers
		</scr>
		<p>
			<mv>ParentTypeName</mv> is the name of a data type to inherit
			handlers and properties from. <mv>HandlerList</mv> is a series of
			<a>cs:on</a>, <a>cs:function</a>, <a>cs:to create</a>,
			<a>cs:to delete</a>, <a>cs:to get</a>, and/or <a>cs:to set</a>
			structures. <mv>FirstTypeName</mv> must be the first name that
			appears in <mv>typeNames</mv>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> structure creates a new user-defined object type.
			The behavior of the created object type is defined by the
			handlers in <mv>handlerList</mv>.
		</p>
	</description>
	<notes>
		<p>
			Attempting to create a new user-defined object type with the
			name of an existing data type (including object types previously
			defined with <me/>) has no effect. No script error is triggered,
			and the data type maintains its previously defined behavior.
			This may change in a future version of OpenXION.
		</p>
	</notes>
	<see-also>
		cs:on, cs:function, cs:to create, cs:to delete, cs:to get, cs:to set
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">aka</name>
	<syntax>
		<syn>
			object type <mv>typeName</mv> <me/> <mv>typeName</mv>
		</syn>
		<p>
			<mv>TypeName</mv> is the name of a data type.
		</p>
	</syntax>
	<examples>
		<scr>
			object type fraction aka rational number
		</scr>
	</examples>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:object type</a> structure.
			It identifies a singular synonym for a user-defined object type.
			See the description for <a>cs:object type</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">pl</name>
	<syntax>
		<syn>
			object type <mv>typeName</mv> <me/> <mv>typeName</mv>
		</syn>
		<p>
			<mv>TypeName</mv> is the name of a data type.
		</p>
	</syntax>
	<examples>
		<scr>
			object type fraction pl fractions
		</scr>
	</examples>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:object type</a> structure.
			It identifies a plural name or synonym for a user-defined object type.
			See the description for <a>cs:object type</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">extends</name>
	<syntax>
		<syn>
			object type <mv>typeName</mv> <me/> <mv>typeName</mv>
		</syn>
		<p>
			<mv>TypeName</mv> is the name of a data type.
		</p>
	</syntax>
	<examples>
		<scr>
			object type resistor extends impedor
		</scr>
	</examples>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:object type</a> structure.
			It identifies a parent data type for a user-defined object type.
			See the description for <a>cs:object type</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">on</name>
	<syntax>
		<syn>
			<me/> <mv>messageName</mv> <mv>parameterList</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			end <mv>messageName</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword identifies a message handler. Message handlers
			are written to define your own commands or modify or redefine
			what happens in response to a built-in command.
		</p>
		<p>
			When a message called <mv>messageName</mv> is sent to an object,
			the XION interpreter checks that object's script to see if it has
			a corresponding message handler also called <mv>messageName</mv>.
			If it does, the object responds according to that handler, and
			the message is sent no further (unless the script has a
			<a>cs:pass</a> statement). If the object has no handler named
			<mv>messageName</mv>, the interpreter passes the message to the
			next object in the hierarchy.
		</p>
		<p>
			The statements in a handler execute until an <a>cs:end</a>,
			<a>cs:exit</a>, <a>cs:pass</a>, <a>cs:return</a>, or
			<a>cs:throw</a> keyword is reached. The return value of a message
			handler, if any, is accessible through the built-in function
			<a>fn:result</a>.
		</p>
		<p>
			The optional <mv>parameterList</mv> allows the message handler
			to receive some values sent along with the message. This list
			is a series of local variable names separated by commas, each
			optionally followed by a data type and/or default value:
		</p>
		<syn>
			<mv>variableName</mv>
			<opt>as <mv>dataType</mv></opt>
			<opt>is <mv>defaultValue</mv></opt>
		</syn>
		<p>
			When the handler executes, each value is put into the parameter
			variable that appears in the corresponding position. If no value
			is specified for a parameter variable, the default value for that
			parameter variable (or <a>cn:empty</a> if no default value is
			specified) is put into that parameter variable.
		</p>
		<p>
			The default data type of a parameter if none is specified is
			<a>dt:string</a>. Other data types, particularly <a>dt:variant</a>,
			may behave in a manner incompatible with HyperTalk, but that may
			be desirable.
		</p>
	</description>
	<compatibility>
		<p>
			HyperTalk does not support <kwd>as</kwd> or <kwd>is</kwd> in the
			parameter list. All parameter variables in HyperTalk are implicitly
			declared as <a>dt:string</a> with a default value of <a>cn:empty</a>.
		</p>
		<p>
			In HyperTalk, handlers may not be nested; that is, a handler
			may not appear in the middle of another handler. In OpenXION,
			handlers can be nested. The nested handlers will only be
			accessible from within the handler in which they appear.
		</p>
	</compatibility>
	<see-also>
		cs:function
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">function</name>
	<syntax>
		<syn>
			<me/> <mv>functionName</mv> <mv>parameterList</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			end <mv>functionName</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword identifies a function handler. Function handlers
			are written to define your own functions. Functions defined with
			function handlers must be called using parentheses rather than the
			<a>kw:the</a>, <a>kw:of</a>, or <a>kw:in</a> keywords.
		</p>
		<p>
			When a function called <mv>functionName</mv> is evaluated, the
			XION interpreter checks the script of the topmost object in the
			hierarchy to see if it has a corresponding function handler also
			called <mv>functionName</mv>. If it does, the function handler
			executes, and the function call is sent no further (unless the
			script has a <a>cs:pass</a> statement). If the object has no
			handler named <mv>functionName</mv>, the interpreter passes the
			function call to the next object in the hierarchy.
		</p>
		<p>
			The statements in a handler execute until an <a>cs:end</a>,
			<a>cs:exit</a>, <a>cs:pass</a>, <a>cs:return</a>, or <a>cs:throw</a>
			keyword is reached. The return value of a function handler
			becomes the value of the function where the function was
			originally called.
		</p>
		<p>
			The optional <mv>parameterList</mv> allows the function handler
			to receive some values sent along with the function call. This
			list is a series of local variable names separated by commas,
			each optionally followed by a data type and/or default value:
		</p>
		<syn>
			<mv>variableName</mv>
			<opt>as <mv>dataType</mv></opt>
			<opt>is <mv>defaultValue</mv></opt>
		</syn>
		<p>
			When the handler executes, each value is put into the parameter
			variable that appears in the corresponding position. If no value
			is specified for a parameter variable, the default value for that
			parameter variable (or <a>cn:empty</a> if no default value is
			specified) is put into that parameter variable.
		</p>
		<p>
			The default data type of a parameter if none is specified is
			<a>dt:string</a>. Other data types, particularly <a>dt:variant</a>,
			may behave in a manner incompatible with HyperTalk, but that may
			be desirable.
		</p>
	</description>
	<notes>
		<p>
			User-defined functions are always followed by parentheses.
			Unlike built-in functions, user-defined functions cannot be called
			with <a>kw:the</a>, <a>kw:of</a>, or <a>kw:in</a>.
		</p>
	</notes>
	<compatibility>
		<p>
			HyperTalk does not support <kwd>as</kwd> or <kwd>is</kwd> in the
			parameter list. All parameter variables in HyperTalk are implicitly
			declared as <a>dt:string</a> with a default value of <a>cn:empty</a>.
		</p>
		<p>
			In HyperTalk, handlers may not be nested; that is, a handler
			may not appear in the middle of another handler. In OpenXION,
			handlers can be nested. The nested handlers will only be
			accessible from within the handler in which they appear.
		</p>
	</compatibility>
	<see-also>
		cs:on
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">repeat</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">repeat for</name>
	<syntax>
		<syn>
			repeat <opt>forever</opt>
			<br indent="1"/><mv>statementList</mv><br/>
			end repeat
		</syn>
		<syn>
			repeat <opt>for</opt> <mv>number</mv> <opt>times</opt>
			<br indent="1"/><mv>statementList</mv><br/>
			<opt><ch><ci>lastly</ci><ci>then</ci><ci>else</ci></ch>
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end repeat
		</syn>
		<p>
			<mv>Number</mv> yields a non-negative <a>dt:integer</a>
			specifying how many times the loop is executed.
		</p>
	</syntax>
	<examples>
		<scr>
			put zero into x
			repeat forever
			  add 1 to x
			  put x
			  if x is ten then exit repeat
			end repeat
		</scr>
		<scr>
			put one into x
			repeat 10
			  put x
			  add 1 to x
			end repeat
		</scr>
		<scr>
			put one into x
			repeat 10 times
			  put x
			  add 1 to x
			end repeat
		</scr>
	</examples>
	<description>
		<p>
			The <me/> structure without a number causes all the statements
			inside to execute in a loop until an <a>cs:exit</a>, <a>cs:pass</a>,
			<a>cs:return</a>, or <a>cs:throw</a> keyword is reached.
			The <me/> structure with a number causes all the statements
			inside to execute in a loop with the specified number of iterations.
		</p>
		<p>
			In OpenXION 1.3 and later, the statements under a
			<a>cs:lastly</a>, <a>cs:then</a>, or <a>cs:else</a>
			keyword inside a <a>cs:repeat</a> structure
			will be executed when the loop ends, <b>unless</b>
			the loop has ended because of an <a>cs:exit</a>,
			<a>cs:pass</a>, <a>cs:return</a>, or <a>cs:throw</a>.
		</p>
	</description>
	<see-also>
		cs:repeat for each, cs:repeat foreach,
		cs:repeat until, cs:repeat while, cs:repeat with
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">repeat for each</name>
	<name dialects="xn,oxn" modules="oxnb">repeat foreach</name>
	<syntax>
		<syn>
			<me/> <mv>variableName</mv> in <mv>expression</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			<opt><ch><ci>lastly</ci><ci>then</ci><ci>else</ci></ch>
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end repeat
		</syn>
		<p>
			<mv>Expression</mv> yields a <a>dt:list</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			repeat foreach x in (1,2,3,4,5,6,7,8,9,10)
			  put x
			end repeat
		</scr>
		<scr>
			repeat for each x in words of "1 2 3 4 5 6 7 8 9 10"
			  put x
			end repeat
		</scr>
	</examples>
	<description>
		<p>
			The <me/> structure causes all the statements inside to execute
			in a loop with as many iterations as there are elements in the
			list, with the specified variable containing the first element
			of the list during the first iteration, the second element of
			the list during the second iteration, and so on.
		</p>
		<p>
			In OpenXION 1.3 and later, the statements under a
			<a>cs:lastly</a>, <a>cs:then</a>, or <a>cs:else</a>
			keyword inside a <a>cs:repeat</a> structure
			will be executed when the loop ends, <b>unless</b>
			the loop has ended because of an <a>cs:exit</a>,
			<a>cs:pass</a>, <a>cs:return</a>, or <a>cs:throw</a>.
		</p>
	</description>
	<see-also>
		cs:repeat, cs:repeat for,
		cs:repeat until, cs:repeat while,
		cs:repeat with
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">repeat until</name>
	<syntax>
		<syn>
			<me/> <mv>condition</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			<opt><ch><ci>lastly</ci><ci>then</ci><ci>else</ci></ch>
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end repeat
		</syn>
		<p>
			<mv>Condition</mv> is an expression that always yields
			<a>cn:true</a> or <a>cn:false</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put one into x
			repeat until x &gt; 10
			  put x
			  add 1 to x
			end repeat
		</scr>
	</examples>
	<description>
		<p>
			The <me/> structure causes all the statements inside to execute
			in a loop repeated as long as the condition is <a>cn:false</a>.
			The condition is checked <i>following</i> each iteration of the
			loop. The statements inside are executed at least once.
		</p>
		<p>
			In OpenXION 1.3 and later, the statements under a
			<a>cs:lastly</a>, <a>cs:then</a>, or <a>cs:else</a>
			keyword inside a <a>cs:repeat</a> structure
			will be executed when the loop ends, <b>unless</b>
			the loop has ended because of an <a>cs:exit</a>,
			<a>cs:pass</a>, <a>cs:return</a>, or <a>cs:throw</a>.
		</p>
	</description>
	<see-also>
		cs:repeat, cs:repeat for,
		cs:repeat for each, cs:repeat foreach,
		cs:repeat while, cs:repeat with
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">repeat while</name>
	<syntax>
		<syn>
			<me/> <mv>condition</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			<opt><ch><ci>lastly</ci><ci>then</ci><ci>else</ci></ch>
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end repeat
		</syn>
		<p>
			<mv>Condition</mv> is an expression that always yields
			<a>cn:true</a> or <a>cn:false</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put one into x
			repeat while x &lt;= 10
			  put x
			  add 1 to x
			end repeat
		</scr>
	</examples>
	<description>
		<p>
			The <me/> structure causes all the statements inside to execute
			in a loop repeated as long as the condition is <a>cn:true</a>.
			The condition is checked <i>preceding</i> each iteration of the
			loop. The statements inside are not executed if the condition is
			<a>cn:false</a> at the beginning of the loop.
		</p>
		<p>
			In OpenXION 1.3 and later, the statements under a
			<a>cs:lastly</a>, <a>cs:then</a>, or <a>cs:else</a>
			keyword inside a <a>cs:repeat</a> structure
			will be executed when the loop ends, <b>unless</b>
			the loop has ended because of an <a>cs:exit</a>,
			<a>cs:pass</a>, <a>cs:return</a>, or <a>cs:throw</a>.
		</p>
	</description>
	<see-also>
		cs:repeat, cs:repeat for,
		cs:repeat for each, cs:repeat foreach,
		cs:repeat until, cs:repeat with
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">repeat with</name>
	<syntax>
		<syn>
			<me/> <mv>variable</mv> = <mv>start</mv> to <mv>finish</mv>
			<opt>step <mv>increment</mv></opt>
			<br indent="1"/><mv>statementList</mv><br/>
			<opt><ch><ci>lastly</ci><ci>then</ci><ci>else</ci></ch>
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end repeat
		</syn>
		<syn>
			<me/> <mv>variable</mv> = <mv>start</mv>
				<ch><ci>down to</ci><ci>downto</ci></ch> <mv>finish</mv>
				<opt>step <mv>decrement</mv></opt>
			<br indent="1"/><mv>statementList</mv><br/>
			<opt><ch><ci>lastly</ci><ci>then</ci><ci>else</ci></ch>
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end repeat
		</syn>
		<p>
			<mv>Variable</mv> is a variable name or an expression yielding a
			variable name. <mv>Start</mv>, <mv>finish</mv>, <mv>increment</mv>,
			and <mv>decrement</mv> yield <a>dt:number</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			repeat with x = 1 to 10
			  put x
			end repeat
		</scr>
	</examples>
	<description>
		<p>
			The <me/> structure causes all the statements inside to execute
			in a loop in which <mv>variable</mv> contains the value
			<mv>start</mv> at the beginning of the loop and is incremented
			by <mv>increment</mv> (or decremented by <mv>decrement</mv>)
			with each iteration of the loop. Execution ends when
			<mv>variable</mv> contains the value <mv>finish</mv>.
			If no <mv>increment</mv> (or <mv>decrement</mv>) is given,
			it is assumed to be 1.
		</p>
		<p>
			In OpenXION 1.3 and later, the statements under a
			<a>cs:lastly</a>, <a>cs:then</a>, or <a>cs:else</a>
			keyword inside a <a>cs:repeat</a> structure
			will be executed when the loop ends, <b>unless</b>
			the loop has ended because of an <a>cs:exit</a>,
			<a>cs:pass</a>, <a>cs:return</a>, or <a>cs:throw</a>.
		</p>
	</description>
	<notes>
		<p>
			<mv>Variable</mv> can be any expression as long as it yields
			a valid variable name. In the following example, the variable
			actually used is called <code>a</code>:
		</p>
		<scr>
			put "a b c" into x
			repeat with word 1 of x = 1 to 10
			  put a
			end repeat
		</scr>
	</notes>
	<compatibility>
		<p>
			HyperTalk does not support the <kwd>downto</kwd> keyword.
			Use <kwd>down to</kwd> instead.
		</p>
		<p>
			HyperTalk does not support the <kwd>step</kwd> keyword, and
			only allows integer values. XION allows any real numeric value.
		</p>
	</compatibility>
	<see-also>
		cs:repeat, cs:repeat for,
		cs:repeat for each, cs:repeat foreach,
		cs:repeat until, cs:repeat while
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn&ge;1.3" modules="oxnb&ge;1.3">lastly</name>
	<syntax>
		<syn>
			repeat
			<br indent="1"/><mv>statementList</mv><br/>
			<opt><ch><ci>lastly</ci><ci>then</ci><ci>else</ci></ch>
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end repeat
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:repeat</a> control structure.
			See the description for <a>cs:repeat</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">if</name>
	<syntax>
		<syn>
			if <mv>condition</mv>
			then <mv>statement</mv>
			<opt>else <mv>statement</mv></opt>
		</syn>
		<syn>
			if <mv>condition</mv><br/>
			then <mv>statement</mv>
			<opt>else <mv>statement</mv></opt>
		</syn>
		<syn>
			if <mv>condition</mv><br/>
			then <mv>statement</mv><br/>
			<opt>else <mv>statement</mv></opt>
		</syn>
		<syn>
			if <mv>condition</mv> then
			<br indent="1"/><mv>statementList</mv><br/>
			else <mv>statement</mv>
		</syn>
		<syn>
			if <mv>condition</mv> then
			<br indent="1"/><mv>statementList</mv><br/>
			<opt>else
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end if
		</syn>
		<p>
			<mv>Condition</mv> yields <a>cn:true</a> or <a>cn:false</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> structure tests for the specified condition and,
			if the condition is <a>cn:true</a>, executes the statement
			or series of statements that follow. If the condition is
			<a>cn:false</a> and an <kwd>else</kwd> keyword is specified,
			the <me/> structure executes the statement or series of
			statements that follow the <kwd>else</kwd> keyword instead.
		</p>
	</description>
	<see-also>
		op:if, cs:switch
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">then</name>
	<syntax>
		<syn>
			if <mv>condition</mv> then
			<br indent="1"/><mv>statementList</mv><br/>
			end if
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:if</a> control structure.
			See the description for <a>cs:if</a> for details.
		</p>
		<p>
			In OpenXION 1.3 and later, the <me/> keyword can also
			be part of the <a>cs:repeat</a> control structure.
			See the description for <a>cs:repeat</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">else</name>
	<syntax>
		<syn>
			if <mv>condition</mv> then
			<br indent="1"/><mv>statementList</mv><br/>
			else
			<br indent="1"/><mv>statementList</mv><br/>
			end if
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:if</a> control structure.
			See the description for <a>cs:if</a> for details.
		</p>
		<p>
			In OpenXION 1.3 and later, the <me/> keyword can also
			be part of the <a>cs:repeat</a> control structure.
			See the description for <a>cs:repeat</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">switch</name>
	<syntax>
		<syn>
			switch <mv>expression</mv>
			<br/>case <mv>expression</mv>
			<br indent="1"/><mv>statementList</mv>
			<br/>case <mv>expression</mv>
			<br indent="1"/><mv>statementList</mv>
			<br/><mv>...</mv><br/>
			<opt>default
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end switch
		</syn>
	</syntax>
	<examples>
		<scr>
			switch x
			case 1
			  put "x is 1"
			case 2
			  put "x is 2"
			case 3
			  put "x is 3"
			default
			  put "x is something else"
			end switch
		</scr>
	</examples>
	<description>
		<p>
			The <me/> structure evaluates the specified expression and
			executes the series of statements underneath the corresponding
			<a>cs:case</a> clause with the same value. If no corresponding
			<a>cs:case</a> clause is found, the <me/> structure executes
			the series of statements underneath the <a>cs:default</a> clause,
			if it exists.
		</p>
	</description>
	<see-also>
		cs:if, op:if
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">case</name>
	<syntax>
		<syn>
			switch <mv>expression</mv>
			<br/>case <mv>expression</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			end switch
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:switch</a> control structure.
			See the description for <a>cs:switch</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">default</name>
	<syntax>
		<syn>
			switch <mv>expression</mv>
			<br/>case <mv>expression</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			default
			<br indent="1"/><mv>statementList</mv><br/>
			end switch
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:switch</a> control structure.
			See the description for <a>cs:switch</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">tell</name>
	<syntax>
		<syn>
			tell <mv>object</mv> to <mv>statement</mv>
		</syn>
		<syn>
			tell <mv>object</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			end tell
		</syn>
		<p>
			<mv>Object</mv> yields a variant that can respond to messages.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> structure executes the statement or statements
			that follow as messages sent to the specified object.
			Unlike the <a>cs:pass</a> statement, <a>cs:tell</a> returns
			to the handler or script containing the <me/> structure
			after the messages have been intercepted.
		</p>
	</description>
	<see-also>
		cs:send, cs:pass
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">try</name>
	<syntax>
		<syn>
			try
			<br indent="1"/><mv>statementList</mv><br/>
			<opt>catch <mv>variable</mv>
			<br indent="1"/><mv>statementList</mv></opt><br/>
			<opt>finally
			<br indent="1"/><mv>statementList</mv></opt><br/>
			end try
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> structure attempts to execute the following statements.
			If a script error is triggered, instead of interrupting the script,
			the statements under the <a>cs:catch</a> clause, if specified,
			are executed. The text of the error message is stored in the
			specified <mv>variable</mv>. The statements under the
			<a>cs:finally</a> clause, if specified, are always executed
			regardless of whether or not a script error is triggered.
		</p>
	</description>
	<see-also>
		cs:throw
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">catch</name>
	<syntax>
		<syn>
			try
			<br indent="1"/><mv>statementList</mv><br/>
			catch <mv>variable</mv>
			<br indent="1"/><mv>statementList</mv><br/>
			end try
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:try</a> control structure.
			See the description for <a>cs:try</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">finally</name>
	<syntax>
		<syn>
			try
			<br indent="1"/><mv>statementList</mv><br/>
			finally
			<br indent="1"/><mv>statementList</mv><br/>
			end try
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is part of the <a>cs:try</a> control structure.
			See the description for <a>cs:try</a> for details.
		</p>
	</description>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">end</name>
	<syntax>
		<syn>
			end <mv>structure</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword marks the end of an <a>cs:object type</a>,
			<a>cs:on</a>, <a>cs:function</a>, <a>cs:repeat</a>, <a>cs:if</a>,
			<a>cs:switch</a>, <a>cs:tell</a>, or <a>cs:try</a> structure.
		</p>
	</description>
	<notes>
		<p>
			If an <me/> statement is used outside its corresponding structure,
			a script error is triggered.
		</p>
	</notes>
	<see-also>
		cs:object type, cs:on, cs:function, cs:repeat, cs:if,
		cs:switch, cs:tell, cs:try, cs:exit, cs:pass
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">const</name>
	<syntax>
		<syn>
			const <mv>constantName</mv> = <mv>constantValue</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> statement creates a new user-defined constant
			with the specified name and value.
		</p>
	</description>
	<notes>
		<p>
			Attempting to create a new user-defined constant with the name
			of an existing constant (including constants previously defined
			with <me/>) has no effect. No script error is triggered,
			and the constant maintains its previously defined value.
			This may change in a future version of OpenXION.
		</p>
	</notes>
	<see-also>
		cs:ordinal
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">do</name>
	<syntax>
		<syn>
			do <mv>script</mv> <opt>as <mv>scriptingLanguage</mv></opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> statement causes the XION interpreter to execute
			the specified string as an XION script. The string is executed
			as though it were inserted in place of the <me/> statement.
		</p>
		<p>
			The <kwd>as</kwd> <mv>scriptingLanguage</mv> form causes the
			XION interpreter to execute the specified string as a script
			in some other scripting language.
			HyperTalk supports AppleScript as well as any OSA-compliant
			scripting component.
			OpenXION supports AppleScript on Mac OS X, VBScript on Windows,
			and <code>bash</code>, Perl, PHP, Python, and Ruby on Mac OS X
			and other systems other than Windows.
			The XION Scripting Language Standard does not require support for
			any particular external language; only support for the syntax.
		</p>
	</description>
	<security>
		<p>
			To execute arbitrary XION code, OpenXION's security settings
			must allow the <code>DO_AND_VALUE</code> security key.
			To execute code in other scripting languages, OpenXION's
			security settings must allow the <code>EXTERNAL_SCRIPTS</code>
			security key.
			If the required security key is denied,
			a script error will be triggered.
		</p>
	</security>
	<see-also>
		fn:value
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">exit</name>
	<syntax>
		<syn>
			exit
			<ch>
				<ci>repeat</ci>
				<ci>if</ci>
				<ci>switch</ci>
				<ci>tell</ci>
				<ci>try</ci>
			</ch>
		</syn>
		<syn>
			exit <mv>handlerName</mv>
		</syn>
		<syn>
			exit to <mv>object</mv>
			<opt>with error <mv>errorMessage</mv></opt>
		</syn>
		<p>
			<mv>HandlerName</mv> is the name of the handler containing the
			<me/> statement. <mv>Object</mv> yields the <a>dt:interpreter</a>.
			<mv>ErrorMessage</mv> yields any <a>dt:string</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> statement sends control to the end of the specified
			structure, ending execution of the control structure. Any
			statements not yet executed in the specified control structure
			are ignored, and execution continues after the <a>cs:end</a>
			of the control structure. The <me/> <mv>handlerName</mv> form
			ends execution of an <a>cs:on</a> or <a>cs:function</a> structure.
		</p>
		<p>
			The <me/> <kwd>to</kwd> <mv>object</mv> form causes the currently
			executing script to stop executing. No more statements are executed
			after an <me/> <kwd>to</kwd> <mv>object</mv>, ever.
			The <kwd>with error</kwd> parameter allows extra information to
			be passed back to whatever initiated the execution of the script.
			OpenXION currently ignores this parameter.
		</p>
	</description>
	<notes>
		<p>
			If an <me/> statement is used outside its corresponding structure,
			a script error is triggered.
		</p>
	</notes>
	<see-also>
		cs:on, cs:function, cs:repeat, cs:if, cs:switch, cs:tell, cs:try,
		cs:end, cs:pass
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">global</name>
	<syntax>
		<syn>
			global <mv>variableList</mv>
		</syn>
		<p>
			<mv>VariableList</mv> is a series of one or more variable names
			separated by commas, each optionally followed by a data type
			and/or initial value:
		</p>
		<syn>
			<mv>variableName</mv>
			<opt>as <mv>dataType</mv></opt>
			<opt>is <mv>initialValue</mv></opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword declares a given variable name as a global
			variable whose contents are available to any invocation of any
			handler in any object. If the variable has not already been
			declared or used, it is created to hold a value of the specified
			data type and initialized to the specified initial value. If the
			variable has been declared or used before, its contents remain
			unchanged.
		</p>
		<p>
			Changing the value of a global variable anywhere changes its
			value everywhere. The <me/> keyword must be used in each handler
			or script in which the global variable is used.
		</p>
	</description>
	<notes>
		<p>
			The following table illustrates the four different <i>variable
			scopes</i>, <a>cs:global</a>, <a>cs:local</a>, <a>cs:shared</a>,
			and <a>cs:static</a>:
		</p>
		<table>
			<tr>
				<td><a>cs:global</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>any</i></td>
				<td>handler in</td>
				<td><i>any</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:shared</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>any</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:static</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>this</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:local</a></td>
				<td>is accessible to</td>
				<td><i>this</i></td>
				<td>invocation of</td>
				<td><i>this</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
		</table>
		<p>
			The default data type if none is specified is <a>dt:string</a>.
			Other data types, particularly <a>dt:variant</a>, may behave in
			a manner incompatible with HyperTalk, but that may be desirable.
		</p>
		<p>
			The initial value of a variable, if not specified,
			is <a>cn:empty</a>.
		</p>
	</notes>
	<compatibility>
		<p>
			HyperTalk does not support <kwd>as</kwd> or <kwd>is</kwd>
			in the variable list. All variables in HyperTalk are
			implicitly declared as <a>dt:string</a> with a default
			value of <a>cn:empty</a>.
		</p>
	</compatibility>
	<see-also>
		cs:local, cs:shared, cs:static
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">local</name>
	<syntax>
		<syn>
			local <mv>variableList</mv>
		</syn>
		<p>
			<mv>VariableList</mv> is a series of one or more variable names
			separated by commas, each optionally followed by a data type
			and/or initial value:
		</p>
		<syn>
			<mv>variableName</mv>
			<opt>as <mv>dataType</mv></opt>
			<opt>is <mv>initialValue</mv></opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword declares a given variable name as a local
			variable whose contents are available only to the current
			invocation of this particular handler in this particular object.
			If the variable has not already been declared or used, it is
			created to hold a value of the specified data type and initialized
			to the specified initial value. If the variable has been declared
			or used before, its contents remain unchanged.
		</p>
	</description>
	<notes>
		<p>
			The following table illustrates the four different <i>variable
			scopes</i>, <a>cs:global</a>, <a>cs:local</a>, <a>cs:shared</a>,
			and <a>cs:static</a>:
		</p>
		<table>
			<tr>
				<td><a>cs:global</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>any</i></td>
				<td>handler in</td>
				<td><i>any</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:shared</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>any</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:static</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>this</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:local</a></td>
				<td>is accessible to</td>
				<td><i>this</i></td>
				<td>invocation of</td>
				<td><i>this</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
		</table>
		<p>
			The default data type if none is specified is <a>dt:string</a>.
			Other data types, particularly <a>dt:variant</a>, may behave in
			a manner incompatible with HyperTalk, but that may be desirable.
		</p>
		<p>
			The initial value of a variable, if not specified,
			is <a>cn:empty</a>.
		</p>
	</notes>
	<see-also>
		cs:global, cs:shared, cs:static
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">shared</name>
	<syntax>
		<syn>
			shared <mv>variableList</mv>
		</syn>
		<p>
			<mv>VariableList</mv> is a series of one or more variable names
			separated by commas, each optionally followed by a data type
			and/or initial value:
		</p>
		<syn>
			<mv>variableName</mv>
			<opt>as <mv>dataType</mv></opt>
			<opt>is <mv>initialValue</mv></opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword declares a given variable name as a shared
			variable whose contents are available to any invocation of any
			handler in this particular object. If the variable has not
			already been declared or used, it is created to hold a value
			of the specified data type and initialized to the specified
			initial value. If the variable has been declared or used before,
			its contents remain unchanged.
		</p>
		<p>
			Changing the value of a shared variable anywhere changes its
			value for this particular object. The <me/> keyword must be used
			in each handler or script in which the shared variable is used.
		</p>
	</description>
	<notes>
		<p>
			The following table illustrates the four different <i>variable
			scopes</i>, <a>cs:global</a>, <a>cs:local</a>, <a>cs:shared</a>,
			and <a>cs:static</a>:
		</p>
		<table>
			<tr>
				<td><a>cs:global</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>any</i></td>
				<td>handler in</td>
				<td><i>any</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:shared</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>any</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:static</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>this</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:local</a></td>
				<td>is accessible to</td>
				<td><i>this</i></td>
				<td>invocation of</td>
				<td><i>this</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
		</table>
		<p>
			The default data type if none is specified is <a>dt:string</a>.
			Other data types, particularly <a>dt:variant</a>, may behave in
			a manner incompatible with HyperTalk, but that may be desirable.
		</p>
		<p>
			The initial value of a variable, if not specified,
			is <a>cn:empty</a>.
		</p>
	</notes>
	<see-also>
		cs:global, cs:local, cs:static
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">static</name>
	<syntax>
		<syn>
			static <mv>variableList</mv>
		</syn>
		<p>
			<mv>VariableList</mv> is a series of one or more variable names
			separated by commas, each optionally followed by a data type
			and/or initial value:
		</p>
		<syn>
			<mv>variableName</mv>
			<opt>as <mv>dataType</mv></opt>
			<opt>is <mv>initialValue</mv></opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword declares a given variable name as a static
			variable whose contents are available to any invocation of this
			particular handler in this particular object. If the variable
			has not already been declared or used, it is created to hold a
			value of the specified data type and initialized to the specified
			initial value. If the variable has been declared or used before,
			its contents remain unchanged.
		</p>
	</description>
	<notes>
		<p>
			The following table illustrates the four different <i>variable
			scopes</i>, <a>cs:global</a>, <a>cs:local</a>, <a>cs:shared</a>,
			and <a>cs:static</a>:
		</p>
		<table>
			<tr>
				<td><a>cs:global</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>any</i></td>
				<td>handler in</td>
				<td><i>any</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:shared</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>any</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:static</a></td>
				<td>is accessible to</td>
				<td><i>any</i></td>
				<td>invocation of</td>
				<td><i>this</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
			<tr>
				<td><a>cs:local</a></td>
				<td>is accessible to</td>
				<td><i>this</i></td>
				<td>invocation of</td>
				<td><i>this</i></td>
				<td>handler in</td>
				<td><i>this</i></td>
				<td>object</td>
			</tr>
		</table>
		<p>
			The default data type if none is specified is <a>dt:string</a>.
			Other data types, particularly <a>dt:variant</a>, may behave in
			a manner incompatible with HyperTalk, but that may be desirable.
		</p>
		<p>
			The initial value of a variable, if not specified,
			is <a>cn:empty</a>.
		</p>
	</notes>
	<see-also>
		cs:global, cs:local, cs:shared
	</see-also>
</structure>

<structure>
	<name dialects="oxn&ge;1.1" modules="oxnb&ge;1.1">include</name>
	<syntax>
		<syn>
			include <mv>scriptName</mv> <opt>once</opt>
			<opt><ch><ci>with</ci><ci>without</ci></ch> dialog</opt>
		</syn>
		<p>
			<mv>ScriptName</mv> yields the name or path of an XION script file.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> statement executes the statements contained in an XION
			script file. If the script file cannot be found, the user will be
			asked to locate it, unless the <kwd>without dialog</kwd> keyword
			is used. If the script file cannot be found and the user cancels
			or the <kwd>without dialog</kwd> keyword is used, nothing happens.
			(For a version that triggers a script error, see <a>cs:require</a>.)
			If the <kwd>once</kwd> keyword is used and the script has been
			executed before, it will not be executed again.
		</p>
		<p>
			In OpenXION, the locations searched for included scripts are
			determined by the <a>pr:includePaths</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> statement as described here is specific to OpenXION.
		</p>
	</notes>
	<see-also>
		cs:require, pr:includePaths, fn:includePath, fn:includeFile
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">next</name>
	<syntax>
		<syn>
			next repeat
		</syn>
		<syn>
			next case
		</syn>
	</syntax>
	<examples>
		<scr>
			repeat 20
			  put random(9) into tempVar
			  if tempVar mod 2 = 0 then next repeat
			  put tempVar
			end repeat
		</scr>
		<scr>
			switch x
			case 1
			  next case
			case 2
			  next case
			case 3
			  put "x is 1, 2, or 3"
			case 4
			  put "x is 4"
			  next case
			  put "this is never printed"
			case 5
			  put "x is 4 or 5"
			default
			  put "x is something else"
			end switch
		</scr>
	</examples>
	<description>
		<p>
			The <code>next repeat</code> statement sends control to the top
			of the next iteration of the loop. Any statements not yet executed
			in the current iteration are ignored.
		</p>
		<p>
			The <code>next case</code> statement sends control to the next
			<a>cs:case</a> clause of a <a>cs:switch</a> structure, regardless
			of the value associated with the <a>cs:case</a> clause. Any
			statements not yet executed in the current <a>cs:case</a> are
			ignored.
		</p>
		<p>
			If a <me/> statement is used outside its corresponding structure,
			a script error is triggered.
		</p>
	</description>
	<compatibility>
		<p>
			HyperTalk does not support <a>cs:switch</a>, therefore it does
			not support <code>next case</code>.
		</p>
	</compatibility>
	<see-also>
		cs:repeat, cs:switch
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">ordinal</name>
	<syntax>
		<syn>
			ordinal <mv>ordinalName</mv> = <mv>index</mv>
		</syn>
		<p>
			<mv>Index</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> statement creates a new user-defined ordinal
			with the specified name and index.
		</p>
	</description>
	<notes>
		<p>
			Attempting to create a new user-defined ordinal with the name
			of an existing ordinal (including ordinals previously defined
			with <me/>) has no effect. No script error is triggered, and
			the ordinal maintains its previously defined index.
			This may change in a future version of OpenXION.
		</p>
	</notes>
	<see-also>
		cs:const
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">pass</name>
	<syntax>
		<syn>
			pass <mv>handlerName</mv>
		</syn>
		<syn>
			pass to <mv>object</mv>
		</syn>
		<p>
			<mv>HandlerName</mv> is the name of the handler containing
			the <me/> statement. <mv>Object</mv> yields a <a>dt:variant</a>
			able to respond to messages.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> statement ends execution of the handler and sends
			the entire message or function call that initiated execution
			of the handler to the next object in the hierarchy.
		</p>
		<p>
			The <code>pass to</code> form ends execution of the handler
			and sends the entire message or function call that initiated
			execution of the handler to the specified object instead. The
			statement <code>pass to interpreter</code> will send the
			message or function call to the interpreter, bypassing the
			hierarchy completely, resulting in the execution of a built-in
			command or the evaluation of a built-in function.
		</p>
	</description>
	<notes>
		<p>
			Unlike the <a>cs:send</a> and <a>cs:tell</a> structures,
			<a>cs:pass</a> never returns to the handler or script
			containing the <me/> statement.
		</p>
		<p>
			HyperTalk does not support the <code>pass to</code> form.
		</p>
	</notes>
	<see-also>
		cs:on, cs:function, cs:end, cs:exit, cs:send, cs:tell
	</see-also>
</structure>

<structure>
	<name dialects="oxn&ge;1.1" modules="oxnb&ge;1.1">require</name>
	<syntax>
		<syn>
			require <mv>scriptName</mv> <opt>once</opt>
			<opt><ch><ci>with</ci><ci>without</ci></ch> dialog</opt>
		</syn>
		<p>
			<mv>ScriptName</mv> yields the name or path of an XION script file.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> statement executes the statements contained in an XION
			script file. If the script file cannot be found, the user will be
			asked to locate it, unless the <kwd>without dialog</kwd> keyword
			is used. If the script file cannot be found and the user cancels
			or the <kwd>without dialog</kwd> keyword is used, the <me/>
			statement triggers a script error. (For a version that does not
			trigger a script error, see <a>cs:include</a>.) If the
			<kwd>once</kwd> keyword is used and the script has been executed
			before, it will not be executed again.
		</p>
		<p>
			In OpenXION, the locations searched for included scripts are
			determined by the <a>pr:includePaths</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> statement as described here is specific to OpenXION.
		</p>
	</notes>
	<see-also>
		cs:include, pr:includePaths, fn:includePath, fn:includeFile
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">return</name>
	<syntax>
		<syn>
			return <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> statement ends execution of the handler and sets
			the return value of the message or function call.
		</p>
		<p>
			When it appears within a message handler (<a>cs:on</a> structure),
			the <me/> statement places the value of <mv>expression</mv> into the
			built-in function <a>fn:result</a>. The value of the <a>fn:result</a>
			function is valid only immediately after a command executes;
			each new statement resets the <a>fn:result</a>.
		</p>
		<p>
			When it appears within a function handler (<a>cs:function</a> structure),
			the <me/> statement dictates the returned value of the function.
			The returned value replaces the function in the calling statement.
		</p>
	</description>
	<notes>
		<p>
			User-defined functions are always followed by parentheses.
			Unlike built-in functions, user-defined functions cannot be called
			with <a>kw:the</a>, <a>kw:of</a>, or <a>kw:in</a>.
		</p>
	</notes>
	<see-also>
		cs:on, cs:function, fn:result
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn,hyp" modules="oxnb">send</name>
	<syntax>
		<syn>
			send <mv>message</mv> to <mv>object</mv>
			<opt><ch><ci>with</ci><ci>without</ci></ch> reply</opt>
		</syn>
		<p>
			<mv>Object</mv> yields a <a>dt:variant</a> able
			to respond to messages.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> statement sends a message directly to a particular
			object. Unlike the <a>cs:pass</a> statement, <a>cs:send</a>
			returns to the handler or script containing the <me/> statement
			after the message has been intercepted.
		</p>
	</description>
	<security>
		<p>
			To send a message to <a>kw:the</a> <a>dt:interpreter</a>,
			OpenXION's security settings must allow the
			<code>DO_AND_VALUE</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cs:tell, cs:pass
	</see-also>
</structure>

<structure>
	<name dialects="xn,oxn" modules="oxnb">throw</name>
	<syntax>
		<syn>
			throw <mv>errorMessage</mv>
		</syn>
		<p>
			<mv>ErrorMessage</mv> yields any <a>dt:string</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> statement triggers a script error
			with the specified error message.
		</p>
	</description>
	<see-also>
		cs:try
	</see-also>
</structure>

<structure>
	<name dialects="oxn" modules="oxnb">use</name>
	<syntax>
		<syn>
			use <mv>moduleName</mv>
		</syn>
		<p>
			<mv>ModuleName</mv> yields the fully-qualified class name of a Java
			class that extends <code>com.kreative.openxion.XNModule</code>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> statement tells the OpenXION interpreter to load
			the specified module. <mv>ModuleName</mv> must yield the
			fully-qualified Java class name of the module to load.
		</p>
	</description>
	<notes>
		<p>
			Since the mechanism for loading modules is dependent on
			the XION implementation, the <me/> statement as described
			here is specific to OpenXION.
		</p>
	</notes>
	<security>
		<p>
			To load modules, OpenXION's security settings must allow the
			<code>MODULE_LOAD</code> security key. If the required security
			key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cs:include, cs:require
	</see-also>
</structure>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">me</name>
	<syntax>
		<syn>
			<me/>
		</syn>
	</syntax>
	<examples>
		<scr>
			get the short name of me
		</scr>
	</examples>
	<description>
		<p>
			<a>kw:Me</a> is a special keyword that always evaluates to the
			object containing the currently running handler. If there is no
			such object, <me/> evaluates to <a>kw:the</a> <a>dt:interpreter</a>
			instead.
		</p>
	</description>
</keyword>

<keyword>
	<name dialects="xn,oxn" modules="oxnb">super</name>
	<syntax>
		<syn>
			<me/>
		</syn>
	</syntax>
	<examples>
		<scr>
			tell super to doSomething
		</scr>
	</examples>
	<description>
		<p>
			<a>kw:Super</a> is a special keyword that always evaluates to the
			object containing the currently running handler, but as the data
			type it extends. If there is no such object, <me/> evaluates to
			<a>kw:the</a> <a>dt:interpreter</a> instead.
		</p>
	</description>
	<notes>
		<p>
			This keyword only makes sense inside the definition of a
			user-defined object type. Its behavior outside that context
			is undefined.
		</p>
	</notes>
</keyword>

<keyword>
	<name dialects="oxn&ge;1.2" modules="oxnb&ge;1.2">__LINE__</name>
	<syntax>
		<syn>
			<me/>
		</syn>
	</syntax>
	<examples>
		<scr>
			put "I am on line" &amp;&amp; __LINE__
		</scr>
	</examples>
	<description>
		<p>
			<me/> is a special keyword that is replaced with the line number
			of the line it's on when a script is parsed.
		</p>
	</description>
	<notes>
		<p>
			If <me/> is used inside a string passed to <a>cs:do</a> or
			<a>fn:value</a>, it will be replaced with the line number of
			the line it's on inside the string, not inside the current
			script file. If you want the latter, put <me/> outside the string.
		</p>
	</notes>
	<compatibility>
		<p>
			<me/> is not part of the XION Scripting Language Standard and
			is not portable. It is not available in OpenXION 1.0 or 1.1.
		</p>
	</compatibility>
</keyword>

<keyword>
	<name dialects="oxn&ge;1.2" modules="oxnb&ge;1.2">__FILE__</name>
	<syntax>
		<syn>
			<me/>
		</syn>
	</syntax>
	<examples>
		<scr>
			put "I am in" &amp;&amp; __FILE__
		</scr>
	</examples>
	<description>
		<p>
			<me/> is a special keyword that is replaced with the full path
			of the file it is in when a script is parsed. If the script did
			not come from a file, the <me/> keyword is replaced with
			<a>cn:empty</a>.
		</p>
	</description>
	<notes>
		<p>
			If <me/> is used inside a string passed to <a>cs:do</a> or
			<a>fn:value</a>, it will be replaced with <a>cn:empty</a>,
			not the path of the current script file. If you want the
			latter, put <me/> outside the string.
		</p>
	</notes>
	<compatibility>
		<p>
			<me/> is not part of the XION Scripting Language Standard and
			is not portable. It is not available in OpenXION 1.0 or 1.1.
		</p>
	</compatibility>
</keyword>

<keyword>
	<name dialects="oxn&ge;1.4" modules="oxnb&ge;1.4">__END__</name>
	<syntax>
		<syn>
			<me/>
		</syn>
	</syntax>
	<description>
		<p>
			<me/> is a special keyword that tells the XION interpreter
			to stop parsing the XION script. Everything following a <me/>
			token will be ignored completely.
		</p>
	</description>
	<compatibility>
		<p>
			<me/> is not part of the XION Scripting Language Standard and
			is not portable. It is not available in versions of OpenXION
			before 1.4.
		</p>
	</compatibility>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">short</name>
	<applies-to>
		<p>Functions and properties</p>
	</applies-to>
	<syntax>
		<syn>
			<opt>the</opt> <me/> <mv>function-or-property-name</mv>
			<opt>of <mv>variant</mv></opt>
		</syn>
	</syntax>
	<examples>
		<scr>
			get the short date
		</scr>
	</examples>
	<description>
		<p>
			The <me/> keyword is a modifier that appears before a function call
			or property descriptor. It tells the function or property getter
			that the resulting value should be in a shortened form.
			The best example of this is the <a>fn:date</a> function.
		</p>
	</description>
	<see-also>
		kw:abbreviated, kw:long, kw:English
	</see-also>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">abbr</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">abbrev</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">abbreviated</name>
	<name dialects="xn,oxn" modules="oxnb">med</name>
	<name dialects="xn,oxn" modules="oxnb">medium</name>
	<applies-to>
		<p>Functions and properties</p>
	</applies-to>
	<syntax>
		<syn>
			<opt>the</opt> <me/> <mv>function-or-property-name</mv>
			<opt>of <mv>variant</mv></opt>
		</syn>
	</syntax>
	<examples>
		<p>
			<code>get the <me/> date</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> keyword is a modifier that appears before a function call
			or property descriptor. It tells the function or property getter
			that the resulting value should be in an abbreviated form.
			The best example of this is the <a>fn:date</a> function.
		</p>
	</description>
	<see-also>
		kw:short, kw:long, kw:English
	</see-also>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">long</name>
	<applies-to>
		<p>Functions and properties</p>
	</applies-to>
	<syntax>
		<syn>
			<opt>the</opt> <me/> <mv>function-or-property-name</mv>
			<opt>of <mv>variant</mv></opt>
		</syn>
	</syntax>
	<examples>
		<scr>
			get the long date
		</scr>
	</examples>
	<description>
		<p>
			The <me/> keyword is a modifier that appears before a function call
			or property descriptor. It tells the function or property getter
			that the resulting value should be in a long form.
			The best example of this is the <a>fn:date</a> function.
		</p>
	</description>
	<see-also>
		kw:short, kw:abbreviated, kw:English
	</see-also>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">English</name>
	<applies-to>
		<p>Functions and properties</p>
	</applies-to>
	<syntax>
		<syn>
			<opt>the</opt> <me/> <mv>function-or-property-name</mv>
			<opt>of <mv>variant</mv></opt>
		</syn>
	</syntax>
	<examples>
		<scr>
			get the English date
		</scr>
	</examples>
	<description>
		<p>
			The <me/> keyword is a modifier that appears before a function call
			or property descriptor. It tells the function or property getter
			that the resulting value should be in a long form in U.S. English
			format. The best example of this is the <a>fn:date</a> function.
		</p>
	</description>
	<see-also>
		kw:short, kw:abbreviated, kw:long
	</see-also>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">into</name>
	<syntax>
		<syn>
			put <mv>value</mv> <me/> <mv>container</mv>
		</syn>
	</syntax>
	<examples>
		<scr>
			put " not " into char 69 of steve
		</scr>
	</examples>
	<description>
		<p>
			The <a>kw:into</a> keyword is a preposition used with the
			<a>cm:put</a> command to determine where the given value goes
			inside the given container. <a>kw:Into</a> specifies that the
			given value should replace the existing contents.
		</p>
	</description>
	<see-also>
		kw:before, kw:after, cm:put
	</see-also>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">before</name>
	<syntax>
		<syn>
			put <mv>value</mv> <me/> <mv>container</mv>
		</syn>
	</syntax>
	<examples>
		<scr>
			put "not " before word 12 of steve
		</scr>
	</examples>
	<description>
		<p>
			The <a>kw:before</a> keyword is a preposition used with the
			<a>cm:put</a> command to determine where the given value goes
			inside the given container. <a>kw:Before</a> specifies that the
			given value should be placed immediately preceding the existing
			contents.
		</p>
	</description>
	<see-also>
		kw:into, kw:after, cm:put
	</see-also>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">after</name>
	<syntax>
		<syn>
			put <mv>value</mv> <me/> <mv>container</mv>
		</syn>
	</syntax>
	<examples>
		<scr>
			put " not" after word 11 of steve
		</scr>
	</examples>
	<description>
		<p>
			The <a>kw:after</a> keyword is a preposition used with the
			<a>cm:put</a> command to determine where the given value goes
			inside the given container. <a>kw:After</a> specifies that the
			given value should be placed immediately following the existing
			contents.
		</p>
	</description>
	<see-also>
		kw:into, kw:before, cm:put
	</see-also>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">to</name>
	<name dialects="xn,oxn" modules="oxnb">thru</name>
	<name dialects="xn,oxn" modules="oxnb">through</name>
	<syntax>
		<syn>
			<mv>datatype</mv> <mv>index</mv> <me/> <mv>index</mv>
		</syn>
		<syn>
			<mv>ordinal</mv> <me/> <mv>ordinal</mv> <mv>datatype</mv>
		</syn>
	</syntax>
	<examples>
		<p>
			<code>get words 12 <me/> 13 of steve</code>
		</p>
		<p>
			<code>get fifth <me/> ninth files of folder myPath</code>
		</p>
		<p>
			<code>get disks 1 <me/> 4</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> keyword is used in descriptors to specify
			a range of indexes or ordinals.
		</p>
	</description>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">in</name>
	<name dialects="xn,oxn,hyp" modules="oxnb">of</name>
	<syntax>
		<syn>
			<opt>the</opt> <mv>chunk</mv> <me/> <mv>parent</mv>
		</syn>
		<syn>
			<opt>the</opt> <mv>descriptor</mv> <me/> <mv>parent</mv>
		</syn>
		<syn>
			<opt>the</opt> <mv>function-name</mv> <me/> <mv>argument</mv>
		</syn>
		<syn>
			<opt>the</opt> <mv>property-name</mv> <me/> <mv>object</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is used in several places to describe
			child-parent relationships between objects and arguments
			to function calls.
		</p>
		<p>
			It is used in chunk expressions:
			<code>char 32 <me/> steve</code>
		</p>
		<p>
			It is used in descriptors for child objects:
			<code>file "doc.xnd" <me/> folder "Documentation"</code>
		</p>
		<p>
			It is used in function calls:
			<code>the sqrt <me/> sixteen</code>
		</p>
		<p>
			It is used in property descriptors:
			<code>the location <me/> myRectangle</code>
		</p>
		<p>
			It is used in operators:
			<code>steve is an element <me/> bill</code>
		</p>
		<p>
			It is used in certain control structures:
			<code>repeat for each myElement <me/> myList</code>
		</p>
	</description>
	<notes>
		<p>
			The <a>kw:in</a> and <a>kw:of</a> keywords are synonyms
			practically everywhere in both XION and HyperTalk, even
			when it would otherwise make no sense (e.g.,
			<code>the sqrt in 4</code> or <code>"e" is of "hello"</code>).
		</p>
	</notes>
</keyword>

<keyword>
	<name dialects="xn,oxn,hyp" modules="oxnb">the</name>
	<syntax>
		<syn>
			<me/> <mv>descriptor</mv>
			<opt>of <mv>parent</mv></opt>
		</syn>
		<syn>
			<me/> <mv>function-name</mv>
			<opt>of <mv>argument</mv></opt>
		</syn>
		<syn>
			<me/> <mv>property-name</mv>
			<opt>of <mv>object</mv></opt>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> keyword is used in several places.
		</p>
		<p>
			It can be used in descriptors:
			<code>the third word of steve</code>
		</p>
		<p>
			It can be used in function calls:
			<code>the sqrt of sixteen</code>
		</p>
		<p>
			It can be used in property descriptors:
			<code>the itemDelimiter</code>
		</p>
	</description>
	<notes>
		<p>
			In both XION and HyperTalk, the presence or absence of the
			<me/> keyword is significant when the expression does not
			include the keyword <a>kw:of</a> or <a>kw:in</a>.
			For example, both <code>the sqrt of 16</code> and
			<code>the date</code> are function calls, but
			<code>sqrt of 16</code> is a function call while
			<code>date</code> by itself is a variable.
		</p>
	</notes>
</keyword>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">zero</name>
	<name dialects="xn,oxn" modules="oxns">never</name>
	<type>integer</type>
	<value>0</value>
	<examples>
		<scr>
			put zero into theCounter
		</scr>
		<scr>
			beep never
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of zero.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">one</name>
	<name dialects="xn,oxn" modules="oxns">once</name>
	<type>integer</type>
	<value>1</value>
	<examples>
		<scr>
			put one into numberOfUniverses
		</scr>
		<scr>
			beep once
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 1.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">two</name>
	<name dialects="xn,oxn" modules="oxns">twice</name>
	<type>integer</type>
	<value>2</value>
	<examples>
		<scr>
			put two into numberOfShoes
		</scr>
		<scr>
			beep twice
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 2.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">three</name>
	<name dialects="xn,oxn" modules="oxns">thrice</name>
	<type>integer</type>
	<value>3</value>
	<examples>
		<scr>
			put three into numberOfDimensions
		</scr>
		<scr>
			beep thrice
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 3.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">four</name>
	<type>integer</type>
	<value>4</value>
	<examples>
		<scr>
			put four into numberOfSeasons
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 4.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">five</name>
	<type>integer</type>
	<value>5</value>
	<examples>
		<scr>
			put five into numberOfSenses
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 5.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">six</name>
	<type>integer</type>
	<value>6</value>
	<examples>
		<scr>
			put six into numberOfQuarks
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 6.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">seven</name>
	<type>integer</type>
	<value>7</value>
	<examples>
		<scr>
			put seven into numberOfWeekdays
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 7.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">eight</name>
	<type>integer</type>
	<value>8</value>
	<examples>
		<scr>
			put eight into numberOfGluons
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 8.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">nine</name>
	<type>integer</type>
	<value>9</value>
	<examples>
		<scr>
			put nine into numberOfInnings
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 9.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">ten</name>
	<type>integer</type>
	<value>10</value>
	<examples>
		<scr>
			put ten into numberOfCommandments
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 10.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">eleven</name>
	<type>integer</type>
	<value>11</value>
	<examples>
		<scr>
			put eleven into numberOfCloningAttemptsBeforeThisOne
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 11.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">twelve</name>
	<type>integer</type>
	<value>12</value>
	<examples>
		<scr>
			put twelve into numberOfMonths
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 12.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">thirteen</name>
	<type>integer</type>
	<value>13</value>
	<examples>
		<scr>
			put thirteen into numberOfColonies
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 13.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">fourteen</name>
	<type>integer</type>
	<value>14</value>
	<examples>
		<scr>
			put fourteen into numberOfPoints
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 14.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">fifteen</name>
	<type>integer</type>
	<value>15</value>
	<examples>
		<scr>
			put fifteen into numberOfMinutes
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 15.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">sixteen</name>
	<type>integer</type>
	<value>16</value>
	<examples>
		<scr>
			put sixteen into numberOfCandles
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 16.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">seventeen</name>
	<type>integer</type>
	<value>17</value>
	<examples>
		<scr>
			put seventeen into numberOfSyllables
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 17.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">eighteen</name>
	<type>integer</type>
	<value>18</value>
	<examples>
		<scr>
			put eighteen into numberOfTammies
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 18.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">nineteen</name>
	<type>integer</type>
	<value>19</value>
	<examples>
		<scr>
			put nineteen into numberOfBiquadrates
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 19.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">twenty</name>
	<type>integer</type>
	<value>20</value>
	<examples>
		<scr>
			put twenty into numberOfQuestions
		</scr>
	</examples>
	<description>
		<p>
			An <a>dt:integer</a> with the numeric value of 20.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">phi</name>
	<name dialects="xn,oxn" modules="oxns">φ</name>
	<type>number</type>
	<value>1.6180339887</value>
	<examples>
		<scr>
			put height * phi into width
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:number</a> with the numeric value of 1.6180339887....
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">euler</name>
	<type>number</type>
	<value>2.7182818284</value>
	<examples>
		<scr>
			put euler ^ myLogarithm into myNumber
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:number</a> with the numeric value of 2.7182818284....
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">pi</name>
	<name dialects="xn,oxn" modules="oxns">π</name>
	<type>number</type>
	<value>3.1415926535</value>
	<examples>
		<scr>
			put pi * radius * radius into area
		</scr>
		<scr>
			put 2*π*r into circumference
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:number</a> with the numeric value of 3.1415926535....
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">inf</name>
	<name dialects="xn,oxn" modules="oxns">infinity</name>
	<name dialects="xn,oxn" modules="oxns">∞</name>
	<name dialects="xn,oxn" modules="oxns">forever</name>
	<type>number</type>
	<value>INF</value>
	<examples>
		<scr>
			if 1 / 0 is infinity then beep
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:number</a> representing positive infinity.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">NaN</name>
	<type>number</type>
	<value>NAN</value>
	<examples>
		<scr>
			if 0/0 is NaN then beep
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:number</a> representing the value obtained when
			evaluating an indeterminate form such as 0/0.
		</p>
	</description>
	<notes>
		<p>
			Following the IEEE standard for floating-point numbers,
			<me/> is not equal to itself. The expression
			<code>NaN is NaN</code> will return <a>cn:false</a>.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">empty</name>
	<type>variant</type>
	<value></value>
	<examples>
		<scr>
			put empty into steve
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:variant</a> representing nothing.
		</p>
		<p>
			When used as a <a>dt:string</a>, <me/> evaluates to a
			zero-length string.
		</p>
		<p>
			When used as an <a>dt:integer</a>, a <a>dt:number</a>,
			or a <a>dt:complex</a>, <me/> evaluates to the numeric
			value of zero. However, <me/> is not equal to zero.
		</p>
		<p>
			When used as a <a>dt:binary</a>, <me/> evaluates to a
			zero-byte stream.
		</p>
		<p>
			When used as a <a>dt:list</a>, <me/> evaluates to a
			list of zero elements.
		</p>
		<p>
			When used as an <a>dt:object</a>, <me/> can be used
			as a placeholder for an actual <a>dt:object</a>. It
			can be passed around like an object, but any attempt
			to <a>cm:get</a> or <a>cm:set</a> its properties,
			<a>cm:delete</a> it, etc. will trigger a script error.
		</p>
		<p>
			The <me/> constant cannot be used as any other data type
			besides the types listed above.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">null</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			put null into tooHotForHyperCard
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			ASCII character zero, the null character.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\0</code>
			to indicate a null in a quoted literal. In HyperTalk, all
			backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
	<see-also>
		cn:empty
	</see-also>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">backspace</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			set the itemDelimiter to backspace
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			ASCII character 8, the backspace character.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\b</code>
			to indicate a backspace in a quoted literal. In HyperTalk, all
			backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">tab</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			put tab before line 2 of theText
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			ASCII character 9, the tab character.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\t</code>
			to indicate a tab in a quoted literal. In HyperTalk, all
			backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">linefeed</name>
	<name dialects="xn,oxn" modules="oxns">newline</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			put newline after line 2 of theText
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			ASCII character 10, the line feed character or
			Unix newline character.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\n</code>
			to indicate a line feed or newline in a quoted literal.
			In HyperTalk, all backslashes are literal, as escape
			sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">formfeed</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			put formfeed after theText
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			ASCII character 12, the form feed character.
			Some programs may use this to indicate a page break.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\f</code>
			to indicate a form feed in a quoted literal. In HyperTalk, all
			backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">return</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			put return after line 2 of theText
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			ASCII character 13, the carriage return character or
			Macintosh line break character.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\r</code>
			to indicate a carriage return in a quoted literal. In HyperTalk,
			all backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">escape</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			put escape &amp; "[0m"
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			ASCII character 27, the escape character.
			This character can be used to control output to terminals.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\e</code>
			to indicate an escape character in a quoted literal. In HyperTalk,
			all backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">space</name>
	<type>string</type>
	<value> </value>
	<examples>
		<scr>
			put "Hello" &amp; space &amp; "World" into steve
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII space character.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">quote</name>
	<type>string</type>
	<value>&quot;</value>
	<examples>
		<scr>
			put quote &amp; "I think she broke the CD-R drive when she dropped it on the floor," &amp; quote &amp;&amp; "said Smart Claire."
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII quotation mark character (").
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\"</code>
			to indicate a quote in a quoted literal. In HyperTalk, all
			backslashes are literal, and quotes cannot be included inside
			a quoted literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">apostrophe</name>
	<type>string</type>
	<value>&#39;</value>
	<examples>
		<scr>
			put "would" &amp; apostrophe &amp; "ve" &amp;&amp; "could" &amp; apostrophe &amp; "ve" &amp;&amp; "should" &amp; apostrophe &amp; "ve"
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII apostrophe character (').
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">comma</name>
	<type>string</type>
	<value>,</value>
	<examples>
		<scr>
			set the itemDelimiter to comma
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII comma character (,).
			This is used as the default <a>pr:itemDelimiter</a>,
			as well as the delimiter when converting a <a>dt:list</a>
			to a <a>dt:string</a>.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">period</name>
	<name dialects="xn,oxn" modules="oxns">fullstop</name>
	<type>string</type>
	<value>.</value>
	<examples>
		<scr>
			put 3 &amp; period &amp; 14159
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII period or full stop character (.).
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">slash</name>
	<type>string</type>
	<value>/</value>
	<examples>
		<scr>
			put slash &amp; "usr" &amp; slash &amp; "bin" &amp; slash &amp; "perl" into thePath
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII slash character (/).
			This is used as the file path separator
			on Unix-based systems.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">colon</name>
	<type>string</type>
	<value>:</value>
	<examples>
		<scr>
			put "Macintosh HD" &amp; colon &amp; "Applications" &amp; colon &amp; "HyperCard" into thePath
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII colon character (:).
			This is used as the file path separator
			on Mac OS Classic systems.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">semicolon</name>
	<type>string</type>
	<value>;</value>
	<examples>
		<scr>
			set the columnDelimiter to semicolon
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII semicolon character (;).
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">backslash</name>
	<type>string</type>
	<value>\</value>
	<examples>
		<scr>
			put "C:" &amp; backslash &amp; "Windows" &amp; backslash &amp; "System32" into thePath
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single ASCII backslash character (\).
			This is used as the file path separator
			on Windows systems.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\\</code>
			to indicate a backslash in a quoted literal. In HyperTalk, all
			backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">del</name>
	<name dialects="xn,oxn" modules="oxns">delete</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			set the itemDelimiter to del
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			ASCII character 127, the delete character.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\d</code>
			to indicate a delete character in a quoted literal. In HyperTalk,
			all backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">linesep</name>
	<type>string</type>
	<value>&#x2028;</value>
	<examples>
		<scr>
			put linesep after line 12 of theText
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single Unicode line separator character,
			Unicode character <code>U+2028</code>.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\u2028</code>
			to indicate a line separator in a quoted literal. In HyperTalk,
			all backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">parasep</name>
	<type>string</type>
	<value>&#x2029;</value>
	<examples>
		<scr>
			put parasep after line 12 of theText
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting of
			a single Unicode paragraph separator character,
			Unicode character <code>U+2029</code>.
		</p>
	</description>
	<notes>
		<p>
			In XION, you can also use the escape sequence <code>\u2029</code>
			to indicate a paragraph separator in a quoted literal. In HyperTalk,
			all backslashes are literal, as escape sequences are not supported.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">eof</name>
	<name dialects="xn,oxn" modules="oxns">end</name>
	<type>string</type>
	<value></value>
	<examples>
		<scr>
			read from file thePath until eof
		</scr>
		<scr>
			read from file thePath until end
		</scr>
	</examples>
	<description>
		<p>
			A one-length <a>dt:string</a> consisting solely of
			Unicode character <code>U+FFFF</code>, used to indicate
			when the <a>cm:read</a> command has reached the end
			of a text file. Since <code>U+FFFF</code> is not a
			valid Unicode character, <me/> will never appear
			anywhere else in a correctly-encoded text file.
		</p>
	</description>
	<notes>
		<p>
			In HyperTalk, <a>cn:eof</a> is actually a keyword to the
			<a>cm:read</a> command, not a constant. We know this because
			we can <code>put it into eof</code> in HyperTalk, but we cannot
			<code>put it into pi</code> or any other real constant.
			However, the <i>HyperCard Script Language Guide</i>
			mistakenly lists <a>cn:eof</a> as a constant. In XION,
			<a>cn:eof</a> is a real constant.
		</p>
	</notes>
	<see-also>
		cm:read
	</see-also>
</constant>

<constant>
	<name dialects="hyp">up</name>
	<type>string</type>
	<value>up</value>
	<examples>
		<scr>
			wait until the optionKey is up
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:string</a> consisting of the text <code>"up"</code>
			(without quotes).
		</p>
	</description>
	<notes>
		<p>
			The <me/> constant is a rare example of HyperTalk defining
			something other than a command or function that XION does not.
			It was decided that since <code>left</code> and <code>right</code>
			cannot be defined as constants alongside <a>cn:up</a> and
			<a>cn:down</a> (as they conflict with the <a>fn:left</a>
			and <a>fn:right</a> functions), then <a>cn:up</a> and
			<a>cn:down</a> should not be defined as constants either.
			Furthermore, the <a>cn:up</a> and <a>cn:down</a> constants
			are used in an environment-specific context for describing
			the state of mouse buttons and keyboard keys, which does not
			apply to XION.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="hyp">down</name>
	<type>string</type>
	<value>down</value>
	<examples>
		<scr>
			wait until the mouse is down
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:string</a> consisting of the text <code>"down"</code>
			(without quotes).
		</p>
	</description>
	<notes>
		<p>
			The <me/> constant is a rare example of HyperTalk defining
			something other than a command or function that XION does not.
			It was decided that since <code>left</code> and <code>right</code>
			cannot be defined as constants alongside <a>cn:up</a> and
			<a>cn:down</a> (as they conflict with the <a>fn:left</a>
			and <a>fn:right</a> functions), then <a>cn:up</a> and
			<a>cn:down</a> should not be defined as constants either.
			Furthermore, the <a>cn:up</a> and <a>cn:down</a> constants
			are used in an environment-specific context for describing
			the state of mouse buttons and keyboard keys, which does not
			apply to XION.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">true</name>
	<type>boolean</type>
	<value>true</value>
	<examples>
		<scr>
			if 2+2=4 is true then beep
		</scr>
	</examples>
	<description>
		<p>
			The <a>dt:boolean</a> representing a truth value of true.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn,hyp" modules="oxns">false</name>
	<type>boolean</type>
	<value>false</value>
	<examples>
		<scr>
			if false then answer "This should never happen."
		</scr>
	</examples>
	<description>
		<p>
			The <a>dt:boolean</a> representing a truth value of false.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">white</name>
	<type>color</type>
	<value>65535,65535,65535</value>
	<examples>
		<scr>
			set the color of myObject to white
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 65535, 65535.
			The color white.
		</p>
	</description>
	<notes>
		<p>
			Although HyperCard had no native support for color,
			the <a>dt:color</a> constants originate from HyperTalk's
			<code>visual</code> command, which provided
			<code>black</code>, <code>gray</code>, <code>grey</code>,
			and <code>white</code> as possible images to transition to.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">lightGray</name>
	<name dialects="xn,oxn" modules="oxns">lightGrey</name>
	<name dialects="xn,oxn" modules="oxns">silver</name>
	<type>color</type>
	<value>49152,49152,49152</value>
	<examples>
		<p>
			<code>set the color of myObject to <me/></code>
		</p>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 49152, 49152, 49152.
			A light gray color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">gray</name>
	<name dialects="xn,oxn" modules="oxns">grey</name>
	<type>color</type>
	<value>32768,32768,32768</value>
	<examples>
		<p>
			<code>set the color of myObject to <me/></code>
		</p>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 32768, 32768.
			A medium gray color.
		</p>
	</description>
	<notes>
		<p>
			Although HyperCard had no native support for color,
			the <a>dt:color</a> constants originate from HyperTalk's
			<code>visual</code> command, which provided
			<code>black</code>, <code>gray</code>, <code>grey</code>,
			and <code>white</code> as possible images to transition to.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">darkGray</name>
	<name dialects="xn,oxn" modules="oxns">darkGrey</name>
	<type>color</type>
	<value>16384,16384,16384</value>
	<examples>
		<p>
			<code>set the color of myObject to <me/></code>
		</p>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 16384, 16384, 16384.
			A dark gray color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">black</name>
	<type>color</type>
	<value>0,0,0</value>
	<examples>
		<scr>
			set the color of myObject to black
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 0, 0.
			The color black.
		</p>
	</description>
	<notes>
		<p>
			Although HyperCard had no native support for color,
			the <a>dt:color</a> constants originate from HyperTalk's
			<code>visual</code> command, which provided
			<code>black</code>, <code>gray</code>, <code>grey</code>,
			and <code>white</code> as possible images to transition to.
		</p>
	</notes>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">coral</name>
	<type>color</type>
	<value>65535,32768,32768</value>
	<examples>
		<scr>
			set the color of myObject to coral
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 32768, 32768.
			A light red color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">corange</name>
	<type>color</type>
	<value>65535,49152,32768</value>
	<examples>
		<scr>
			set the color of myObject to corange
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 49152, 32768.
			A light orange color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">lemon</name>
	<type>color</type>
	<value>65535,65535,32768</value>
	<examples>
		<scr>
			set the color of myObject to lemon
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 65535, 32768.
			A light yellow color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">lime</name>
	<type>color</type>
	<value>32768,65535,32768</value>
	<examples>
		<scr>
			set the color of myObject to lime
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 65535, 32768.
			A light green color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">sky</name>
	<type>color</type>
	<value>32768,65535,65535</value>
	<examples>
		<scr>
			set the color of myObject to sky
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 65535, 65535.
			A light cyan color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">frost</name>
	<type>color</type>
	<value>32768,32768,65535</value>
	<examples>
		<scr>
			set the color of myObject to frost
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 32768, 65535.
			A light blue color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">lavender</name>
	<type>color</type>
	<value>49152,32768,65535</value>
	<examples>
		<scr>
			set the color of myObject to lavender
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 49152, 32768, 65535.
			A light violet color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">pink</name>
	<type>color</type>
	<value>65535,32768,65535</value>
	<examples>
		<scr>
			set the color of myObject to pink
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 32768, 65535.
			A light magenta color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">red</name>
	<type>color</type>
	<value>65535,0,0</value>
	<examples>
		<scr>
			set the color of myObject to red
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 0, 0.
			The color red.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">scarlet</name>
	<type>color</type>
	<value>65535,16384,0</value>
	<examples>
		<scr>
			set the color of myObject to scarlet
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 16384, 0.
			A red-orange color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">orange</name>
	<type>color</type>
	<value>65535,32768,0</value>
	<examples>
		<scr>
			set the color of myObject to orange
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 32768, 0.
			The color orange.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">blonde</name>
	<name dialects="xn,oxn" modules="oxns">gold</name>
	<type>color</type>
	<value>65535,49152,0</value>
	<examples>
		<p>
			<code>set the color of myObject to <me/></code>
		</p>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 49152, 0.
			An orange-yellow color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">yellow</name>
	<type>color</type>
	<value>65535,65535,0</value>
	<examples>
		<scr>
			set the color of myObject to yellow
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 65535, 0.
			The color yellow.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">chartreuse</name>
	<type>color</type>
	<value>32768,65535,0</value>
	<examples>
		<scr>
			set the color of myObject to chartreuse
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 65535, 0.
			A yellow-green color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">green</name>
	<type>color</type>
	<value>0,65535,0</value>
	<examples>
		<scr>
			set the color of myObject to green
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 65535, 0.
			A bright green color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">aquamarine</name>
	<type>color</type>
	<value>0,65535,32768</value>
	<examples>
		<scr>
			set the color of myObject to aquamarine
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 65535, 32768.
			A green-cyan color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">cyan</name>
	<name dialects="xn,oxn" modules="oxns">aqua</name>
	<type>color</type>
	<value>0,65535,65535</value>
	<examples>
		<p>
			<code>set the color of myObject to <me/></code>
		</p>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 65535, 65535.
			The color cyan.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">azure</name>
	<type>color</type>
	<value>0,32768,65535</value>
	<examples>
		<scr>
			set the color of myObject to azure
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 32768, 65535.
			A cyan-blue color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">blue</name>
	<type>color</type>
	<value>0,0,65535</value>
	<examples>
		<scr>
			set the color of myObject to blue
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 0, 65535.
			The color blue.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">indigo</name>
	<type>color</type>
	<value>16384,0,65535</value>
	<examples>
		<scr>
			set the color of myObject to indigo
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 16384, 0, 65535.
			A blue-violet color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">violet</name>
	<type>color</type>
	<value>32768,0,65535</value>
	<examples>
		<scr>
			set the color of myObject to violet
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 0, 65535.
			The color violet.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">purple</name>
	<type>color</type>
	<value>49152,0,65535</value>
	<examples>
		<scr>
			set the color of myObject to purple
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 49152, 0, 65535.
			A violet-magenta color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">magenta</name>
	<name dialects="xn,oxn" modules="oxns">fuchsia</name>
	<type>color</type>
	<value>65535,0,65535</value>
	<examples>
		<p>
			<code>set the color of myObject to <me/></code>
		</p>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 0, 65535.
			The color magenta.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">rose</name>
	<type>color</type>
	<value>65535,0,32768</value>
	<examples>
		<scr>
			set the color of myObject to rose
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 0, 32768.
			A magenta-red color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">maroon</name>
	<type>color</type>
	<value>32768,0,0</value>
	<examples>
		<scr>
			set the color of myObject to maroon
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 0, 0.
			A dark red color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">umber</name>
	<type>color</type>
	<value>32768,16384,0</value>
	<examples>
		<scr>
			set the color of myObject to umber
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 16384, 0.
			A dark orange color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">olive</name>
	<type>color</type>
	<value>32768,32768,0</value>
	<examples>
		<scr>
			set the color of myObject to olive
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 32768, 0.
			A dark yellow color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">pine</name>
	<type>color</type>
	<value>0,32768,0</value>
	<examples>
		<scr>
			set the color of myObject to pine
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 32768, 0.
			A dark green color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">teal</name>
	<type>color</type>
	<value>0,32768,32768</value>
	<examples>
		<scr>
			set the color of myObject to teal
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 32768, 32768.
			A dark cyan color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">navy</name>
	<type>color</type>
	<value>0,0,32768</value>
	<examples>
		<scr>
			set the color of myObject to navy
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 0, 0, 32768.
			A dark blue color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">eggplant</name>
	<type>color</type>
	<value>16384,0,32768</value>
	<examples>
		<scr>
			set the color of myObject to eggplant
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 16384, 0, 32768.
			A dark violet color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">plum</name>
	<type>color</type>
	<value>32768,0,32768</value>
	<examples>
		<scr>
			set the color of myObject to plum
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 32768, 0, 32768.
			A dark magenta color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">brown</name>
	<type>color</type>
	<value>39321,26214,13107</value>
	<examples>
		<scr>
			set the color of myObject to brown
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 39321, 26214, 13107.
			A rich brown color.
		</p>
	</description>
</constant>

<constant>
	<name dialects="xn,oxn" modules="oxns">creme</name>
	<type>color</type>
	<value>65535,61166,52428</value>
	<examples>
		<scr>
			set the color of myObject to creme
		</scr>
	</examples>
	<description>
		<p>
			A <a>dt:color</a> with RGB values 65535, 61166, 52428.
			A very light brownish-yellow color.
		</p>
	</description>
</constant>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">zeroth</name>
	<value>0</value>
	<examples>
		<scr>
			put the zeroth byte of ("09F91102" as binary) -- prints "09"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index zero. The <a>or:zeroth</a>
			ordinal is used mainly with the <a>dt:binary</a> data type, where
			offsets into the binary data are numbered starting at zero. It is
			rarely used elsewhere, as most other indexes in XION start at 1.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">first</name>
	<value>1</value>
	<examples>
		<scr>
			put first sentence of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "Hello, my name is Rebecca."
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 1.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">second</name>
	<value>2</value>
	<examples>
		<scr>
			put second word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "my"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 2.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">third</name>
	<value>3</value>
	<examples>
		<scr>
			put third word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "name"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 3.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">fourth</name>
	<value>4</value>
	<examples>
		<scr>
			put fourth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "is"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 4.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">fifth</name>
	<value>5</value>
	<examples>
		<scr>
			put fifth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "Rebecca."
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 5.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">sixth</name>
	<value>6</value>
	<examples>
		<scr>
			put sixth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "But"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 6.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">seventh</name>
	<value>7</value>
	<examples>
		<scr>
			put seventh word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "you"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 7.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">eighth</name>
	<value>8</value>
	<examples>
		<scr>
			put eighth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "can"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 8.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">ninth</name>
	<value>9</value>
	<examples>
		<scr>
			put ninth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "call"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 9.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">tenth</name>
	<value>10</value>
	<examples>
		<scr>
			put tenth word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "me"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 10.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">eleventh</name>
	<value>11</value>
	<examples>
		<scr>
			put eleventh word of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "Beckie."
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 11.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">twelfth</name>
	<value>12</value>
	<examples>
		<scr>
			put twelfth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "a" from "name"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 12.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">thirteenth</name>
	<value>13</value>
	<examples>
		<scr>
			put thirteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "m" from "name"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 13.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">fourteenth</name>
	<value>14</value>
	<examples>
		<scr>
			put fourteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "e" from "name"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 14.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">fifteenth</name>
	<value>15</value>
	<examples>
		<scr>
			put fifteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints " " after "name"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 15.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">sixteenth</name>
	<value>16</value>
	<examples>
		<scr>
			put sixteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "i" from "is"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 16.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">seventeenth</name>
	<value>17</value>
	<examples>
		<scr>
			put seventeenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "s" from "is"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 17.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">eighteenth</name>
	<value>18</value>
	<examples>
		<scr>
			put eighteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints " " after "is"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 18.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">nineteenth</name>
	<value>19</value>
	<examples>
		<scr>
			put nineteenth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints "R" from "Rebecca"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 19.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn" modules="oxns">twentieth</name>
	<value>20</value>
	<examples>
		<scr>
			put twentieth char of "Hello, my name is Rebecca. But you can call me Beckie." -- prints first "e" from "Rebecca"
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index 20.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">mid</name>
	<name dialects="xn,oxn,hyp" modules="oxns">middle</name>
	<value>-2147483647</value>
	<examples>
		<scr>
			put the middle word of "It was the turtle, not I, who spilled the beans." -- prints "I,"
		</scr>
		<scr>
			put the mid item of "It was the turtle, not I, who spilled the beans." -- prints " not I"
		</scr>
	</examples>
	<description>
		<p>
			A special ordinal corresponding to the middle, or median,
			value of a set of values. If the number of values is even,
			the <me/> ordinal favors the second, or latter, of the
			two middle values.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">last</name>
	<value>-1</value>
	<examples>
		<scr>
			put the last word of "Hello, my name is Rebecca." -- prints "Rebecca."
		</scr>
	</examples>
	<description>
		<p>
			An ordinal corresponding to index -1, or the last value
			of a set of values.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">any</name>
	<value>-2147483648</value>
	<examples>
		<scr>
			put any word of "apple orange banana" into randomFruit
		</scr>
	</examples>
	<description>
		<p>
			A special ordinal corresponding to a random index.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">this</name>
	<name dialects="xn,oxn" modules="oxns">current</name>
	<value>-2147483645</value>
	<description>
		<p>
			A special ordinal corresponding to the current instance
			of an object type. What this means is dependent on which
			object type it is being used with. None of the object types
			in the XION Scripting Language Standard or OpenXION currently
			support this ordinal. However, its value is reserved for
			that purpose.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">prev</name>
	<name dialects="xn,oxn,hyp" modules="oxns">previous</name>
	<value>-2147483646</value>
	<description>
		<p>
			A special ordinal corresponding to the previous instance
			of an object type. What this means is dependent on which
			object type it is being used with. None of the object types
			in the XION Scripting Language Standard or OpenXION currently
			support this ordinal. However, its value is reserved for
			that purpose.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">next</name>
	<value>-2147483644</value>
	<description>
		<p>
			A special ordinal corresponding to the next instance of an
			object type. What this means is dependent on which object type
			it is being used with. None of the object types in the XION
			Scripting Language Standard or OpenXION currently support this
			ordinal. However, its value is reserved for that purpose.
		</p>
	</description>
</ordinal>

<ordinal>
	<name dialects="xn,oxn,hyp" modules="oxns">recent</name>
	<value>-2147483643</value>
	<description>
		<p>
			A special ordinal corresponding to the previous recent
			instance of an object type. What this means is dependent
			on which object type it is being used with. None of the
			object types in the XION Scripting Language Standard or
			OpenXION currently support this ordinal. However, its value
			is reserved for that purpose.
		</p>
	</description>
</ordinal>

<datatype>
	<name dialects="xn,oxn" modules="oxns">variant</name>
	<description>
		<p>
			The <a>dt:variant</a> data type is the most generic type.
			Every single value, piece of data, list, or object is
			considered a <a>dt:variant</a>.
		</p>
	</description>
	<notes>
		<p>
			The only value that is intrinsically a <a>dt:variant</a>,
			as opposed to some other data type, is <a>cn:empty</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">variants</name>
	<name dialects="xn,oxn" modules="oxns">list</name>
	<description>
		<p>
			The <a>dt:list</a> or <a>dt:variants</a> data type is the most
			generic type of all lists. Every list is considered a
			<a>dt:list</a>, and every other single value, piece of data, or
			object is considered a <a>dt:list</a> of one <a>dt:element</a>.
		</p>
		<p>
			When a list is converted to a string, the result is the
			concatenation of each element as a string, with a comma
			between each element. If any element is itself a list,
			its string representation will be enclosed in parentheses.
			(This prevents the list from being flattened in certain
			circumstances.)
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">lists</name>
	<description>
		<p>
			The <a>dt:lists</a> data type is a list that consists entirely
			of <a>dt:list</a>s. Every list of lists is considered a
			<a>dt:lists</a>. Every list of single values is considered a
			<a>dt:lists</a> of one <a>dt:list</a>. Every other single value,
			piece of data, or object is considered a <a>dt:lists</a> of one
			<a>dt:list</a> of one <a>dt:element</a>.
		</p>
		<p>
			When a list is converted to a string, the result is the
			concatenation of each element as a string, with a comma
			between each element. If any element is itself a list,
			its string representation will be enclosed in parentheses.
			(This prevents the list from being flattened in certain
			circumstances.)
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">element</name>
	<descriptors>
			child-index, child-index-range, child-ordinal,
			child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <a>dt:element</a> data type is a chunk type of <a>dt:list</a>
			that represents individual items in a list. Every single value,
			piece of data, list, or object is considered an <a>dt:element</a>
			of its containing <a>dt:list</a>, or, if not in a list, an
			<a>dt:element</a> of a single-element <a>dt:list</a> containing it.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
		<p>
			There is a subtle difference between an index, ordinal, or
			name descriptor and an index range, ordinal range, or mass
			descriptor for <a>dt:element</a>s. An index, ordinal, or name
			descriptor evaluates to an item in the list, while an index
			range, ordinal range, or mass descriptor evaluates to a sublist.
			Consider the following:
		</p>
		<scr>
			local myList as list
			put (1,2,(3,4),5) into myList
			put the number of elements in element 3 of myList
			put the number of elements in element 3 to 3 of myList
		</scr>
		<p>
			The first line of output will be <code>2</code>,
			since <code>element 3 of myList</code> is a list
			containing two values, 3 and 4.
			However, the second line of output will be <code>1</code>,
			since <code>element 3 to 3 of myList</code> is a list
			containing that list.
		</p>
	</notes>
	<compatibility>
		<p>
			The <a>dt:element</a> and <a>dt:elements</a> data types were
			broken in OpenXION 1.0 and 1.1, and evaluated index, ordinal,
			and name descriptors as sublists rather than list items.
			This was fixed in OpenXION 1.2.
		</p>
	</compatibility>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">elements</name>
	<descriptors>
			child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <a>dt:elements</a> data type is a chunk type of <a>dt:list</a>
			that represents a sublist of that list. Every single value, piece
			of data, list, or object is considered an <a>dt:elements</a>
			similarly to how it is considered a <a>dt:list</a>.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
		<p>
			There is a subtle difference between an index, ordinal, or
			name descriptor and an index range, ordinal range, or mass
			descriptor for <a>dt:element</a>s. An index, ordinal, or name
			descriptor evaluates to an item in the list, while an index
			range, ordinal range, or mass descriptor evaluates to a sublist.
			Consider the following:
		</p>
		<scr>
			local myList as list
			put (1,2,(3,4),5) into myList
			put the number of elements in element 3 of myList
			put the number of elements in element 3 to 3 of myList
		</scr>
		<p>
			The first line of output will be <code>2</code>,
			since <code>element 3 of myList</code> is a list
			containing two values, 3 and 4.
			However, the second line of output will be <code>1</code>,
			since <code>element 3 to 3 of myList</code> is a list
			containing that list.
		</p>
	</notes>
	<compatibility>
		<p>
			The <a>dt:element</a> and <a>dt:elements</a> data types were
			broken in OpenXION 1.0 and 1.1, and evaluated index, ordinal,
			and name descriptors as sublists rather than list items.
			This was fixed in OpenXION 1.2.
		</p>
	</compatibility>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">string</name>
	<description>
		<p>
			The <a>dt:string</a> data type represents a sequence
			of Unicode characters.
		</p>
	</description>
	<notes>
		<p>
			Every single value, piece of data, list, or object
			can be converted to a <a>dt:string</a> in some way.
			A container will be converted to its contents as a
			<a>dt:string</a>. The resulting <a>dt:string</a>
			cannot necessarily be converted back to the original
			variant.
		</p>
		<p>
			The <a>dt:string</a> data type is the default when
			no other data type is specified in a variable declaration
			or parameter list or when a variable is used without
			being previously declared. Other data types, particularly
			<a>dt:variant</a>, may behave in a manner incompatible
			with HyperTalk, but that may be desirable.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">strings</name>
	<description>
		<p>
			The <a>dt:strings</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:string</a>s.
		</p>
	</description>
	<notes>
		<p>
			Every single value, piece of data, list, or object
			can be converted to a <a>dt:strings</a> in some way.
			A list will be converted to a list of the individual
			<a>dt:element</a>s as <a>dt:string</a>s. A single
			value, piece of data, or object will be converted
			to a single-element list of that variant as a
			<a>dt:string</a>.
		</p>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">boolean</name>
	<description>
		<p>
			The <a>dt:boolean</a> data type represents a single truth value,
			which may be either <a>cn:true</a> or <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			The <a>dt:boolean</a> value <a>cn:true</a> can convert to the
			<a>dt:string</a> <code>"true"</code> while the <a>dt:boolean</a>
			value <a>cn:false</a> can convert to the <a>dt:string</a>
			<code>"false"</code>. Conversely, the <a>dt:string</a>s
			<code>"true"</code> and <code>"false"</code> can convert to the
			<a>dt:boolean</a> values <a>cn:true</a> and <a>cn:false</a>
			respectively. No other value can be converted to <a>dt:boolean</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">booleans</name>
	<description>
		<p>
			The <a>dt:booleans</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:boolean</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">integer</name>
	<description>
		<p>
			The <a>dt:integer</a> data type represents an integer.
		</p>
	</description>
	<notes>
		<p>
			The XION Scripting Language Standard states that the
			<a>dt:integer</a> type must have the range of a 32-bit
			signed two's-complement integer, -2147483648 to +2147483647,
			or larger. The <a>dt:integer</a> type in OpenXION has
			arbitrary range.
		</p>
		<p>
			The XION Scripting Language Standard also states that
			if a calculation produces an integer outside the range
			of the <a>dt:integer</a> type, the result must be converted
			to a <a>dt:number</a> instead of rolling over or overflowing.
		</p>
		<p>
			An <a>dt:integer</a> can always convert to a <a>dt:string</a>,
			<a>dt:number</a>, or <a>dt:complex</a>. A <a>dt:string</a> can
			convert to an <a>dt:integer</a> if it has the correct format.
			A <a>dt:number</a> can convert to an <a>dt:integer</a> if its
			numeric value is a mathematical integer and it is within the
			range of the <a>dt:integer</a> type. A <a>dt:complex</a> can
			convert to an <a>dt:integer</a> if its imaginary part is zero
			and its real part is a mathematical integer in the range of
			the <a>dt:integer</a> type.
		</p>
		<p>
			The format used for the conversion of an <a>dt:integer</a>
			to a <a>dt:string</a> is determined by the <a>pr:numberFormat</a>
			property.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">integers</name>
	<description>
		<p>
			The <a>dt:integers</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:integer</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">number</name>
	<description>
		<p>
			The <a>dt:number</a> data type represents a real number.
			The <a>dt:number</a> data type can also represent the values
			positive <a>cn:infinity</a>, negative <a>cn:infinity</a>,
			and <a>cn:NaN</a>.
		</p>
	</description>
	<notes>
		<p>
			The XION Scripting Language Standard states that the
			<a>dt:number</a> type must have IEEE single precision
			or better. The <a>dt:number</a> type in OpenXION has
			arbitrary precision: basic arithmetic operations use the
			number of fractional digits specified by the <a>pr:precision</a>
			property, and mathematical functions can use either IEEE
			double precision or the number of fractional digits specified
			by the <a>pr:precision</a> property, depending on the setting
			of the <a>pr:mathProcessor</a> property.
		</p>
		<p>
			A <a>dt:number</a> can always convert to a <a>dt:string</a>
			or a <a>dt:complex</a>. A <a>dt:number</a> can convert to an
			<a>dt:integer</a> only if its numeric value is a mathematical
			integer and it is within the range of the <a>dt:integer</a>
			type.
		</p>
		<p>
			An <a>dt:integer</a> can always convert to a <a>dt:number</a>.
			A <a>dt:string</a> can convert to a <a>dt:number</a> if it has
			the correct format, and a <a>dt:complex</a> can convert to a
			<a>dt:number</a> if its imaginary part is zero.
		</p>
		<p>
			The format used for the conversion of a <a>dt:number</a> to a
			<a>dt:string</a> is determined by the <a>pr:numberFormat</a>
			property.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">numbers</name>
	<description>
		<p>
			The <a>dt:numbers</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:number</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">complex</name>
	<description>
		<p>
			The <a>dt:complex</a> data type represents a complex number,
			a number of the form <i>a+bi</i> where <i>a</i> and <i>b</i>
			are real numbers and <i>i</i> is the square root of -1.
		</p>
	</description>
	<notes>
		<p>
			The XION Scripting Language Standard states that both real
			and imaginary parts of the <a>dt:complex</a> type must have
			the same precision as that of the <a>dt:number</a> type.
			OpenXION follows this.
		</p>
		<p>
			A <a>dt:complex</a> can always convert to a <a>dt:string</a>.
			A <a>dt:complex</a> can convert to a <a>dt:number</a> if its
			imaginary part is zero, and can convert to an <a>dt:integer</a>
			if, in addition to its imaginary part being zero, its real part
			is a mathematical integer in the range of the <a>dt:integer</a>
			type.
		</p>
		<p>
			An <a>dt:integer</a> or a <a>dt:number</a> can always convert
			to a <a>dt:complex</a> with an imaginary part of zero. A
			<a>dt:string</a> can convert to a <a>dt:complex</a> if it has
			the correct format.
		</p>
		<p>
			The format used for the conversion of a <a>dt:complex</a> to a
			<a>dt:string</a> is determined by the <a>pr:numberFormat</a>
			property.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">complexes</name>
	<description>
		<p>
			The <a>dt:complexes</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:complex</a>es.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">point</name>
	<description>
		<p>
			The <a>dt:point</a> data type represents a point in a
			Cartesian coordinate system with integer coordinates.
		</p>
	</description>
	<notes>
		<p>
			The <a>dt:string</a> representation of a <a>dt:point</a>
			is the <a>dt:string</a> representation of the X coordinate,
			followed by a comma, followed by the <a>dt:string</a>
			representation of the Y coordinate.
		</p>
		<p>
			The <a>dt:string</a> representation of a <a>dt:point</a>
			always includes a comma; it <b>does not</b> depend on the
			setting of the <a>pr:itemDelimiter</a> property.
		</p>
	</notes>
	<compatibility>
		<p>
			In HyperTalk, you can test for a point with the <a>op:is an</a>
			operator, but the test is broken: if the value is not a
			comma-delimited list of integers, the expression will trigger
			an "Expected integer here" script error instead of evaluating to
			<a>cn:false</a>.
		</p>
	</compatibility>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">points</name>
	<description>
		<p>
			The <a>dt:points</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:point</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">rect</name>
	<name dialects="xn,oxn,hyp" modules="oxns">rectangle</name>
	<properties>
			left, top, right, bottom, topLeft, topRight, bottomLeft, botLeft,
			bottomRight, botRight, location, loc, center, width, height
	</properties>
	<description>
		<p>
			The <me/> data type represents a rectangle in a
			Cartesian coordinate system with integer coordinates.
		</p>
	</description>
	<notes>
		<p>
			The <a>dt:string</a> representation of a <me/> is the
			<a>dt:string</a> representations of the left, top, right,
			and bottom coordinates, in order, delimited by commas.
		</p>
		<p>
			The <a>dt:string</a> representation of a <me/>
			always includes a comma; it <b>does not</b> depend on the
			setting of the <a>pr:itemDelimiter</a> property.
		</p>
	</notes>
	<compatibility>
		<p>
			In HyperTalk, you can test for a rectangle with the <a>op:is an</a>
			operator, but the test is broken: if the value is not a
			comma-delimited list of integers, the expression will trigger an
			"Expected integer here" script error instead of evaluating to
			<a>cn:false</a>.
		</p>
	</compatibility>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">rects</name>
	<name dialects="xn,oxn" modules="oxns">rectangles</name>
	<description>
		<p>
			The <me/> data type represents a <a>dt:list</a> that consists
			entirely of <a>dt:rectangle</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">color</name>
	<name dialects="xn,oxn" modules="oxns">colour</name>
	<properties>
		red, green, blue, alpha, hue, saturation, brightness
	</properties>
	<description>
		<p>
			The <me/> data type represents a color in the sRGB color space.
			Each color channel is specified by an integer from 0 to 65535.
			An alpha channel may or may not be specified; if not, it is
			assumed to be 65535 (opaque).
		</p>
	</description>
	<notes>
		<p>
			The <a>pr:red</a>, <a>pr:green</a>, <a>pr:blue</a>, and
			<a>pr:alpha</a> properties are <a>dt:integer</a>s from 0 to 65535.
			The <a>pr:hue</a>, <a>pr:saturation</a>, and <a>pr:brightness</a>
			properties are <a>dt:number</a>s from 0 to 1.
		</p>
		<p>
			The <a>dt:string</a> representation of a <me/> is the
			<a>dt:string</a> representations of the red, green, blue,
			and alpha components, in order, delimited by commas.
			If the color is opaque (the alpha component is 65535),
			only the red, green, and blue components appear in the
			<a>dt:string</a> representation.
		</p>
		<p>
			The <a>dt:string</a> representation of a <me/>
			always includes a comma; it <b>does not</b> depend on the
			setting of the <a>pr:itemDelimiter</a> property.
		</p>
	</notes>
	<compatibility>
		<p>
			OpenXION 1.0 and 1.1 did not support an alpha channel.
		</p>
	</compatibility>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">colors</name>
	<name dialects="xn,oxn" modules="oxns">colours</name>
	<description>
		<p>
			The <me/> data type represents a <a>dt:list</a> that consists
			entirely of <a>dt:color</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">date</name>
	<description>
		<p>
			The <a>dt:date</a> data type represents a date and time
			in the Gregorian calendar system. A <a>dt:date</a> is obtained
			from the <a>fn:date</a> and <a>fn:time</a> functions or the
			<a>cm:convert</a> command.
		</p>
	</description>
	<notes>
		<p>
			HyperTalk considers just about any string to be a <a>dt:date</a>,
			although very few such strings can actually be converted to
			<a>dt:date</a>s. XION is much stricter and only considers a string
			a <a>dt:date</a> if it can be converted to one. The formats XION
			accepts are:
		</p>
		<ul>
			<li>
				a U.S.-formatted date with long month and day names,
				e.g. <code>"Sunday, February 15, 2009"</code>
				(<a>kw:the</a> <a>kw:English</a> <a>fn:date</a>),
			</li>
			<li>
				a U.S.-formatted date with short month and day names,
				e.g. <code>"Sun, Feb 15, 2009"</code>,
			</li>
			<li>
				a U.S.-formatted date with numbers,
				e.g. <code>"2/15/09"</code>,
			</li>
			<li>
				a U.S.-formatted time with seconds,
				e.g. <code>"9:44:26 PM"</code>
				(<a>kw:the</a> <a>kw:English</a> <a>fn:time</a>),
			</li>
			<li>
				a U.S.-formatted time without seconds,
				e.g. <code>"9:44 PM"</code>,
			</li>
			<li>
				a locale-specific formatted date with long month and day names
				(<a>kw:the</a> <a>kw:long</a> <a>fn:date</a>),
			</li>
			<li>
				a locale-specific formatted date with short month and day names
				(<a>kw:the</a> <a>kw:abbreviated</a> <a>fn:date</a>),
			</li>
			<li>
				a locale-specific formatted date with numbers
				(<a>kw:the</a> <a>kw:short</a> <a>fn:date</a>),
			</li>
			<li>
				a locale-specific formatted time with seconds
				(<a>kw:the</a> <a>kw:long</a> <a>fn:time</a> or
				<a>kw:the</a> <a>kw:abbreviated</a> <a>fn:time</a>),
			</li>
			<li>
				a locale-specific formatted time without seconds
				(<a>kw:the</a> <a>kw:short</a> <a>fn:time</a>).
			</li>
		</ul>
	</notes>
	<see-also>
		fn:date, fn:time, cm:convert
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">dates</name>
	<description>
		<p>
			The <a>dt:dates</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:date</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">binary</name>
	<description>
		<p>
			The <a>dt:binary</a> data type represents a stream of bytes.
			In <a>dt:string</a> form, a <a>dt:binary</a> appears
			as a string of hexadecimal digits.
		</p>
	</description>
	<notes>
		<p>
			A <a>dt:binary</a> is manipulated using the chunk types
			<a>dt:byte</a>, <a>dt:tinyInt</a>, <a>dt:shortInt</a>,
			<a>dt:medInt</a>, <a>dt:longInt</a>, <a>dt:halfFloat</a>,
			<a>dt:singleFloat</a>, and <a>dt:doubleFloat</a>.
		</p>
		<p>
			Two global properties, <a>pr:unsigned</a> and
			<a>pr:littleEndian</a>, control the signedness and
			byte order of the binary chunk types, respectively.
			The <a>pr:unsigned</a> property is <a>cn:false</a>,
			or signed, by default. The <a>pr:littleEndian</a>
			property is <a>cn:false</a>, or big-endian, by default.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">binaries</name>
	<description>
		<p>
			The <a>dt:binaries</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:binary</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn&ge;1.3" modules="oxns&ge;1.3">dictionary</name>
	<properties>keys, values</properties>
	<description>
		<p>
			The <a>dt:dictionary</a> data type represents a map of
			<a>dt:string</a>s to <a>dt:variant</a>s. In an XION script and
			in <a>dt:string</a> form, a <a>dt:dictionary</a> looks like:
		</p>
		<scr>
			{
			  "4" = "Steve"
			  "1" = "Bill"
			  "3" = "Andy"
			  "2" = "Dan"
			}
		</scr>
		<p>
			In this example, the <i>keys</i> are the strings <code>"4"</code>,
			<code>"1"</code>, <code>"3"</code>, and <code>"2"</code>;
			and the <i>values</i> are the strings <code>"Steve"</code>,
			<code>"Bill"</code>, <code>"Andy"</code>, and <code>"Dan"</code>.
			Keys must always be <a>dt:string</a>s. Values may be any kind
			of <a>dt:variant</a>.
		</p>
		<p>
			A <a>dt:dictionary</a> is manipulated using the <a>dt:entry</a>
			chunk type. In this example, <code>entry "2"</code> of this
			<a>dt:dictionary</a> evaluates to <code>"Dan"</code>. An ordinal
			or numeric index on an <a>dt:entry</a> is used as a key, not as
			an index; <code>entry 4</code> of this <a>dt:dictionary</a>
			evaluates to <code>"Steve"</code> even though <code>"Steve"</code>
			appears first in the <a>dt:dictionary</a>.
		</p>
		<p>
			You can iterate over the keys and values of a <a>dt:dictionary</a>
			using the <a>pr:keys</a> and <a>pr:values</a> properties of a
			<a>dt:dictionary</a>.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn&ge;1.3" modules="oxns&ge;1.3">dictionaries</name>
	<description>
		<p>
			The <a>dt:dictionaries</a> data type represents a <a>dt:list</a> that consists
			entirely of <a>dt:dictionary</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn&ge;1.3" modules="oxns&ge;1.3">entry</name>
	<descriptors>
			child-index, child-ordinal, child-name
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:dictionary</a>
			that represents an entry in the dictionary.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <me/> chunk that refers to an entry
			not in the dictionary returns <a>cn:empty</a>.
			Modifying a <me/> chunk that refers to an entry
			not in the dictionary adds a new entry to the
			parent <a>dt:dictionary</a>.
		</p>
	</notes>
	<compatibility>
		<p>
			OpenXION 1.3 did not properly handle accessing <me/> chunks
			not in the dictionary, causing the interpreter to crash.
			This was fixed in OpenXION 1.4 and later.
		</p>
	</compatibility>
</datatype>

<datatype>
	<name dialects="xn,oxn&ge;1.3" modules="oxns&ge;1.3">entries</name>
	<description>
		<p>
			The <a>dt:entries</a> data type represents a <a>dt:list</a> that consists
			entirely of <a>dt:entry</a>s.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn&ge;1.3" modules="oxns&ge;1.3">reference</name>
	<description>
		<p>
			The <a>dt:reference</a> data type is a non-container data type
			that points to a <a>dt:variant</a> that may or may not be a
			container. In <a>dt:string</a> form, a <a>dt:reference</a>
			appears as a descriptor or XION literal.
		</p>
		<p>
			A <a>dt:reference</a> is used to freely pass around a container.
			When an attempt is made to put a container into a variable,
			<a>dt:list</a>, <a>dt:dictionary</a>, or other container, or to
			pass a container as a parameter to a message or function handler,
			the container's contents are passed instead. In order to
			pass around the container itself, a reference must be created.
		</p>
	</description>
	<scripts>
		<p>
			The following example illustrates using references to change a
			string. In this example, we want to pass in the <i>container</i>
			<code>last word of greeting</code>. However, if we were to
			naively pass in <code>last word of greeting</code>, the actual
			last word, <code>"Becky."</code>, would be passed in instead.
			So instead, we pass in a reference.
		</p>
		<scr>
			on tweak what as reference, newValue as string
			  put newValue into the referent of what
			end tweak
			
			local greeting as string
			put "Hello, my name is Rebecca. But you can call me Becky." into greeting
			tweak (a reference to last word of greeting), "Beckie."
		</scr>
	</scripts>
	<see-also>
		op:a reference to, op:the referent of
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn&ge;1.3" modules="oxns&ge;1.3">references</name>
	<description>
		<p>
			The <a>dt:references</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:reference</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">object</name>
	<descriptors>index, ordinal, id, name</descriptors>
	<description>
		<p>
			The <a>dt:object</a> data type is the root of the
			class hierarchy of any user-defined data type.
		</p>
	</description>
	<notes>
		<p>
			Converting an <a>dt:object</a> to a <a>dt:string</a> results in
			a <a>dt:string</a> that looks like a descriptor. Conversely, a
			<a>dt:string</a> that is formatted like a descriptor may be
			converted to the <a>dt:object</a> it describes.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">objects</name>
	<descriptors>index-range, ordinal-range, mass</descriptors>
	<description>
		<p>
			The <a>dt:objects</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:object</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">interpreter</name>
	<name dialects="xn,oxn" modules="oxns">environment</name>
	<descriptors>
		singleton
	</descriptors>
	<properties>
		name, version, textEncoding, lineEnding,
		numberFormat, mathProcessor, precision, roundingMode,
		itemDelimiter, columnDelimiter, rowDelimiter,
		littleEndian, unsigned, userName,
		applicationPaths, documentPaths, includePaths
	</properties>
	<description>
		<p>
			The <me/> is a singleton variant that represents the XION
			interpreter. Properties of the <me/> reflect the properties
			of the global environment.
		</p>
		<p>
			You can <a>cs:pass</a>, <a>cs:send</a>, or <a>cs:tell</a>
			to the <me/> to bypass the message-passing hierarchy and
			execute a built-in command directly. You can also <a>cs:exit</a>
			to the <me/> to immediately terminate script execution.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">interpreters</name>
	<name dialects="xn,oxn" modules="oxns">environments</name>
	<description>
		<p>
			The <me/> data type represents a <a>dt:list</a> that consists
			entirely of <a>dt:interpreter</a>s.
		</p>
	</description>
	<notes>
		<p>
			In order to use lists properly, you must declare your variables
			to be a kind of list. If a list is put into a variable that is
			undeclared, or declared to be a type other than a kind of list,
			the list will be converted to a single string. For example:
		</p>
		<scr>
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>1</code> because <code>steve</code> has only
			one element: the string <code>"1,2,3,4"</code>. However, this
			example:
		</p>
		<scr>
			local steve as numbers
			put (1,2,3,4) into steve
			put the number of elements in steve
		</scr>
		<p>
			will print <code>4</code> because <code>steve</code> has
			four elements: the numbers 1, 2, 3, and 4.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">char</name>
	<name dialects="xn,oxn,hyp" modules="oxns">character</name>
	<descriptors>
		child-index, child-index-range,
		child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:string</a>
			that represents a single Unicode character or a range
			of Unicode characters.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <me/> chunk that is out of range returns
			<a>cn:empty</a>. Modifying a <me/> chunk that is out of range
			prepends or appends to the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">chars</name>
	<name dialects="xn,oxn,hyp" modules="oxns">characters</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:string</a>
			that represents a range of Unicode characters.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:character</a> chunk that is out of range
			returns <a>cn:empty</a>. Modifying a <a>dt:character</a> chunk
			that is out of range prepends or appends to the parent
			<a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">line</name>
	<descriptors>
		child-index, child-index-range,
		child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <a>dt:line</a> data type is a chunk type of <a>dt:string</a>
			that represents a line or a range of lines. This includes empty
			lines at the beginning or in the middle of the <a>dt:string</a>
			but not the last trailing empty line of the <a>dt:string</a>,
			if there is one.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:line</a> chunk that is out of range returns
			<a>cn:empty</a>. Modifying a <a>dt:line</a> chunk that is
			out of range inserts as many line breaks as necessary to insert
			text on the appropriate line of the parent <a>dt:string</a>.
		</p>
	</notes>
	<compatibility>
		<p>
			The <a>dt:line</a> chunk type in HyperTalk always and only uses
			<a>cn:return</a> as the line ending. The <a>dt:line</a> chunk type
			in XION uses <a>cn:return</a><a>op:&amp;</a><a>cn:newline</a>,
			<a>cn:newline</a>, <a>cn:return</a>, <a>cn:linesep</a>, and
			<a>cn:parasep</a> as possible line endings. When inserting
			additional line breaks, <a>dt:line</a> uses the current setting
			of the <a>pr:lineEnding</a> property.
		</p>
	</compatibility>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">lines</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <a>dt:lines</a> data type is a chunk type of <a>dt:string</a>
			that represents a range of lines. This includes empty lines
			at the beginning or in the middle of the <a>dt:string</a> but
			not the last trailing empty line of the <a>dt:string</a>,
			if there is one.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:line</a> chunk that is out of range returns
			<a>cn:empty</a>. Modifying a <a>dt:line</a> chunk that is
			out of range inserts as many line breaks as necessary to insert
			text on the appropriate line of the parent <a>dt:string</a>.
		</p>
	</notes>
	<compatibility>
		<p>
			The <a>dt:lines</a> chunk type in HyperTalk always and only uses
			<a>cn:return</a> as the line ending. The <a>dt:lines</a> chunk type
			in XION uses <a>cn:return</a><a>op:&amp;</a><a>cn:newline</a>,
			<a>cn:newline</a>, <a>cn:return</a>, <a>cn:linesep</a>, and
			<a>cn:parasep</a> as possible line endings. When inserting
			additional line breaks, <a>dt:lines</a> uses the current setting
			of the <a>pr:lineEnding</a> property.
		</p>
	</compatibility>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">item</name>
	<descriptors>
		child-index, child-index-range,
		child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <a>dt:item</a> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by the <a>pr:itemDelimiter</a>.
			This includes empty <a>dt:item</a>s but not the last trailing empty
			<a>dt:item</a> of the <a>dt:string</a>, if there is one.
		</p>
	</description>
	<notes>
		<p>
			Accessing an <a>dt:item</a> chunk that is out of range returns <a>cn:empty</a>.
			Modifying an <a>dt:item</a> chunk that is out of range inserts as many
			<a>pr:itemDelimiter</a>s as necessary to insert text in the appropriate
			<a>dt:item</a> of the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">items</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <a>dt:items</a> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by the <a>pr:itemDelimiter</a>.
			This includes empty <a>dt:item</a>s but not the last trailing empty
			<a>dt:item</a> of the <a>dt:string</a>, if there is one.
		</p>
	</description>
	<notes>
		<p>
			Accessing an <a>dt:item</a> chunk that is out of range returns <a>cn:empty</a>.
			Modifying an <a>dt:item</a> chunk that is out of range inserts as many
			<a>pr:itemDelimiter</a>s as necessary to insert text in the appropriate
			<a>dt:item</a> of the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">col</name>
	<name dialects="xn,oxn" modules="oxns">column</name>
	<descriptors>
		child-index, child-index-range,
		child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by the <a>pr:columnDelimiter</a>.
			This includes empty <me/>s but not the last trailing empty
			<me/> of the <a>dt:string</a>, if there is one.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <me/> chunk that is out of range returns <a>cn:empty</a>.
			Modifying a <me/> chunk that is out of range inserts as many
			<a>pr:columnDelimiter</a>s as necessary to insert text in the appropriate
			<me/> of the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">cols</name>
	<name dialects="xn,oxn" modules="oxns">columns</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by the <a>pr:columnDelimiter</a>.
			This includes empty <a>dt:column</a>s but not the last trailing empty
			<a>dt:column</a> of the <a>dt:string</a>, if there is one.
		</p>
	</description>
	<notes>
		<p>
			Accessing an <a>dt:column</a> chunk that is out of range returns <a>cn:empty</a>.
			Modifying an <a>dt:column</a> chunk that is out of range inserts as many
			<a>pr:columnDelimiter</a>s as necessary to insert text in the appropriate
			<a>dt:column</a> of the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">row</name>
	<descriptors>
		child-index, child-index-range,
		child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <a>dt:row</a> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by the <a>pr:rowDelimiter</a>.
			This includes empty <a>dt:row</a>s but not the last trailing empty
			<a>dt:row</a> of the <a>dt:string</a>, if there is one.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:row</a> chunk that is out of range returns <a>cn:empty</a>.
			Modifying a <a>dt:row</a> chunk that is out of range inserts as many
			<a>pr:rowDelimiter</a>s as necessary to insert text in the appropriate
			<a>dt:row</a> of the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">rows</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <a>dt:rows</a> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by the <a>pr:rowDelimiter</a>.
			This includes empty <a>dt:row</a>s but not the last trailing empty
			<a>dt:row</a> of the <a>dt:string</a>, if there is one.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:row</a> chunk that is out of range returns <a>cn:empty</a>.
			Modifying a <a>dt:row</a> chunk that is out of range inserts as many
			<a>pr:rowDelimiter</a>s as necessary to insert text in the appropriate
			<a>dt:row</a> of the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">word</name>
	<descriptors>
		child-index, child-index-range,
		child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <a>dt:word</a> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by one or more white
			space characters.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:word</a> chunk that is out of range returns
			<a>cn:empty</a>. Modifying a <a>dt:word</a> chunk that is
			out of range prepends or appends to the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn,hyp" modules="oxns">words</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <a>dt:words</a> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by one or more white
			space characters.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:word</a> chunk that is out of range returns
			<a>cn:empty</a>. Modifying a <a>dt:word</a> chunk that is
			out of range prepends or appends to the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">sent</name>
	<name dialects="xn,oxn" modules="oxns">sentence</name>
	<descriptors>
		child-index, child-index-range,
		child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text starting with a non-white space
			character and ending with a period, exclamation mark, or question
			mark followed by zero or more other non-white space characters.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <me/> chunk that is out of range returns
			<a>cn:empty</a>. Modifying a <me/> chunk that is out of range
			prepends or appends to the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">sents</name>
	<name dialects="xn,oxn" modules="oxns">sentences</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text starting with a non-white space
			character and ending with a period, exclamation mark, or question
			mark followed by zero or more other non-white space characters.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:sentence</a> chunk that is out of range
			returns <a>cn:empty</a>. Modifying a <a>dt:sentence</a> chunk
			that is out of range prepends or appends to the parent
			<a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">para</name>
	<name dialects="xn,oxn" modules="oxns">paragraph</name>
	<descriptors>
		child-index, child-index-range,
		child-ordinal, child-ordinal-range, child-name
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by one or more
			line breaks.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <me/> chunk that is out of range returns
			<a>cn:empty</a>. Modifying a <me/> chunk that is out of range
			prepends or appends to the parent <a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">paras</name>
	<name dialects="xn,oxn" modules="oxns">paragraphs</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:string</a>
			that represents a chunk of text delimited by one or more
			line breaks.
		</p>
	</description>
	<notes>
		<p>
			Accessing a <a>dt:paragraph</a> chunk that is out of range
			returns <a>cn:empty</a>. Modifying a <a>dt:paragraph</a> chunk
			that is out of range prepends or appends to the parent
			<a>dt:string</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">byte</name>
	<descriptors>
		child-index, child-index-range, child-ordinal, child-ordinal-range
	</descriptors>
	<description>
		<p>
			The <a>dt:byte</a> data type is a chunk type of <a>dt:binary</a>
			that represents a single byte or range of bytes.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <a>dt:byte</a> chunk that is out of range returns <a>cn:empty</a>.
			Modifying a <a>dt:byte</a> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">bytes</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <a>dt:bytes</a> data type is a chunk type of <a>dt:binary</a>
			that represents a range of bytes.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <a>dt:byte</a> chunk that is out of range returns <a>cn:empty</a>.
			Modifying a <a>dt:byte</a> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">tinyInt</name>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<description>
		<p>
			The <a>dt:tinyInt</a> data type is a chunk type of <a>dt:binary</a>
			that represents an 8-bit integer at a particular offset
			in the parent <a>dt:binary</a>.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <a>dt:tinyInt</a> chunk that is out of range returns <a>cn:zero</a>.
			Modifying a <a>dt:tinyInt</a> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
		<p>
			The signedness and endianness of the <a>dt:tinyInt</a> are determined by
			the <a>pr:unsigned</a> and <a>pr:littleEndian</a> global properties.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">tinyInts</name>
	<description>
		<p>
			The <a>dt:tinyInts</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:tinyInt</a>s.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">shortInt</name>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<description>
		<p>
			The <a>dt:shortInt</a> data type is a chunk type of <a>dt:binary</a>
			that represents a 16-bit integer at a particular offset
			in the parent <a>dt:binary</a>.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <a>dt:shortInt</a> chunk that is out of range returns <a>cn:zero</a>.
			Modifying a <a>dt:shortInt</a> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
		<p>
			The signedness and endianness of the <a>dt:shortInt</a> are determined by
			the <a>pr:unsigned</a> and <a>pr:littleEndian</a> global properties.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">shortInts</name>
	<description>
		<p>
			The <a>dt:shortInts</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:shortInt</a>s.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">medInt</name>
	<name dialects="xn,oxn" modules="oxns">mediumInt</name>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<description>
		<p>
			The <me/> data type is a chunk type of <a>dt:binary</a>
			that represents a 32-bit integer at a particular offset
			in the parent <a>dt:binary</a>.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <me/> chunk that is out of range returns <a>cn:zero</a>.
			Modifying a <me/> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
		<p>
			The signedness and endianness of the <me/> are determined by
			the <a>pr:unsigned</a> and <a>pr:littleEndian</a> global properties.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">medInts</name>
	<name dialects="xn,oxn" modules="oxns">mediumInts</name>
	<description>
		<p>
			The <me/> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:mediumInt</a>s.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">longInt</name>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<description>
		<p>
			The <a>dt:longInt</a> data type is a chunk type of <a>dt:binary</a>
			that represents a 64-bit integer at a particular offset
			in the parent <a>dt:binary</a>.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <a>dt:longInt</a> chunk that is out of range returns <a>cn:zero</a>.
			Modifying a <a>dt:longInt</a> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
		<p>
			The signedness and endianness of the <a>dt:longInt</a> are determined by
			the <a>pr:unsigned</a> and <a>pr:littleEndian</a> global properties.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">longInts</name>
	<description>
		<p>
			The <a>dt:longInts</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:longInt</a>s.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">halfFloat</name>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<description>
		<p>
			The <a>dt:halfFloat</a> data type is a chunk type of <a>dt:binary</a>
			that represents an IEEE-format half-precision floating point number
			at a particular offset in the parent <a>dt:binary</a>.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <a>dt:halfFloat</a> chunk that is out of range returns <a>cn:zero</a>.
			Modifying a <a>dt:halfFloat</a> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
		<p>
			The endianness of the <a>dt:halfFloat</a> is determined by
			the <a>pr:littleEndian</a> global property.
		</p>
		<p>
			The half-precision format has one sign bit, 5 exponent bits,
			and 10 mantissa bits.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">halfFloats</name>
	<description>
		<p>
			The <a>dt:halfFloats</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:halfFloat</a>s.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">singleFloat</name>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<description>
		<p>
			The <a>dt:singleFloat</a> data type is a chunk type of <a>dt:binary</a>
			that represents an IEEE-format single-precision floating point number
			at a particular offset in the parent <a>dt:binary</a>.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <a>dt:singleFloat</a> chunk that is out of range returns <a>cn:zero</a>.
			Modifying a <a>dt:singleFloat</a> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
		<p>
			The endianness of the <a>dt:singleFloat</a> is determined by
			the <a>pr:littleEndian</a> global property.
		</p>
		<p>
			The single-precision format has one sign bit, 8 exponent bits,
			and 23 mantissa bits.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">singleFloats</name>
	<description>
		<p>
			The <a>dt:singleFloats</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:singleFloat</a>s.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">doubleFloat</name>
	<descriptors>
		child-index, child-ordinal
	</descriptors>
	<description>
		<p>
			The <a>dt:doubleFloat</a> data type is a chunk type of <a>dt:binary</a>
			that represents an IEEE-format double-precision floating point number
			at a particular offset in the parent <a>dt:binary</a>.
		</p>
	</description>
	<notes>
		<p>
			The chunks of a <a>dt:binary</a> are numbered starting at zero.
			This is one of the very few instances of zero-based indexing in XION,
			as most indexes start at 1.
		</p>
		<p>
			Accessing a <a>dt:doubleFloat</a> chunk that is out of range returns <a>cn:zero</a>.
			Modifying a <a>dt:doubleFloat</a> chunk that is out of range inserts as many
			zero bytes as necessary to insert data at the appropriate offset in the
			parent <a>dt:binary</a>.
		</p>
		<p>
			The endianness of the <a>dt:doubleFloat</a> is determined by
			the <a>pr:littleEndian</a> global property.
		</p>
		<p>
			The double-precision format has one sign bit, 11 exponent bits,
			and 52 mantissa bits.
		</p>
	</notes>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">doubleFloats</name>
	<description>
		<p>
			The <a>dt:doubleFloats</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:doubleFloat</a>s.
		</p>
	</description>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">disk</name>
	<name dialects="xn,oxn" modules="oxns">volume</name>
	<descriptors>index, ordinal, name</descriptors>
	<properties>name, path, count</properties>
	<description>
		<p>
			The <me/> data type represents a mounted volume in the file system.
			A <me/> may contain <a>dt:folder</a>s and <a>dt:file</a>s.
		</p>
	</description>
	<security>
		<p>
			To use <me/>s, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		dt:folder
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">disks</name>
	<name dialects="xn,oxn" modules="oxns">volumes</name>
	<descriptors>index-range, ordinal-range, mass</descriptors>
	<description>
		<p>
			The <me/> data type represents a <a>dt:list</a> that consists
			entirely of <a>dt:disk</a>s.
		</p>
	</description>
	<security>
		<p>
			To use <me/>, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		dt:folder
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">folder</name>
	<name dialects="xn,oxn" modules="oxns">directory</name>
	<descriptors>
		index, ordinal, name,
		child-index, child-ordinal, child-name
	</descriptors>
	<properties>name, path, modificationDate, count</properties>
	<description>
		<p>
			The <me/> data type represents a folder or directory in the
			file system. A <me/> may contain <a>dt:folder</a>s and
			<a>dt:file</a>s.
		</p>
	</description>
	<notes>
		<p>
			If no parent <a>dt:disk</a>, <a>dt:volume</a>, <a>dt:folder</a>,
			or <a>dt:directory</a> is specified, the current directory is
			used as the parent.
		</p>
	</notes>
	<security>
		<p>
			To use <me/>s, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		dt:disk, dt:file
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">folders</name>
	<name dialects="xn,oxn" modules="oxns">directories</name>
	<descriptors>
		index-range, ordinal-range, mass,
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <me/> data type represents a <a>dt:list</a> that consists
			entirely of <a>dt:folder</a>s.
		</p>
	</description>
	<notes>
		<p>
			If no parent <a>dt:disk</a>, <a>dt:volume</a>, <a>dt:folder</a>,
			or <a>dt:directory</a> is specified, the current directory is
			used as the parent.
		</p>
	</notes>
	<security>
		<p>
			To use <me/>, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		dt:disk, dt:file
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">file</name>
	<descriptors>
		index, ordinal, name,
		child-index, child-ordinal, child-name
	</descriptors>
	<properties>name, path, modificationDate, size</properties>
	<description>
		<p>
			The <a>dt:file</a> data type represents a file in the file system.
			A <a>dt:file</a> may contain <a>dt:fork</a>s.
		</p>
	</description>
	<notes>
		<p>
			If no parent <a>dt:disk</a>, <a>dt:volume</a>, <a>dt:folder</a>,
			or <a>dt:directory</a> is specified, the current directory
			is used as the parent.
		</p>
	</notes>
	<security>
		<p>
			To use <me/>s, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		dt:fork, dt:folder, mg:file,
		cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">files</name>
	<descriptors>
		index-range, ordinal-range, mass,
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <a>dt:files</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:file</a>s.
		</p>
	</description>
	<notes>
		<p>
			If no parent <a>dt:disk</a>, <a>dt:volume</a>, <a>dt:folder</a>,
			or <a>dt:directory</a> is specified, the current directory
			is used as the parent.
		</p>
	</notes>
	<security>
		<p>
			To use <me/>, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		dt:fork, dt:folder, mg:file,
		cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">fork</name>
	<descriptors>
		child-index, child-ordinal, child-name
	</descriptors>
	<properties>name, size</properties>
	<description>
		<p>
			The <a>dt:fork</a> data type represents a fork, alternate stream,
			or metadata of a file in the file system.
		</p>
	</description>
	<security>
		<p>
			To use <me/>s, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		dt:file, mg:file, cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</datatype>

<datatype>
	<name dialects="xn,oxn" modules="oxns">forks</name>
	<descriptors>
		child-index-range, child-ordinal-range, child-mass
	</descriptors>
	<description>
		<p>
			The <a>dt:forks</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:fork</a>s.
		</p>
	</description>
	<security>
		<p>
			To use <me/>, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		dt:file, mg:file, cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</datatype>

<datatype>
	<name dialects="oxn,hyp" modules="oxne">clipboard</name>
	<descriptors>singleton</descriptors>
	<description>
		<p>
			The <me/> is a singleton variant that represents the clipboard.
			It is used as a container to provide copy and paste functionality
			to a script.
		</p>
	</description>
	<security>
		<p>
			To read the contents of the clipboard, OpenXION's security
			settings must allow the <code>CLIPBOARD_READ</code> security key.
			To change the contents of the clipboard, OpenXION's security
			settings must allow the <code>CLIPBOARD_WRITE</code> security key.
			If the required security key is denied, a script error
			will be triggered.
		</p>
	</security>
</datatype>

<datatype>
	<name dialects="oxn" modules="oxne">clipboards</name>
	<description>
		<p>
			The <me/> data type represents a <a>dt:list</a> that consists
			entirely of <a>dt:clipboard</a>s.
		</p>
	</description>
	<security>
		<p>
			To read the contents of the clipboard, OpenXION's security
			settings must allow the <code>CLIPBOARD_READ</code> security key.
			To change the contents of the clipboard, OpenXION's security
			settings must allow the <code>CLIPBOARD_WRITE</code> security key.
			If the required security key is denied, a script error
			will be triggered.
		</p>
	</security>
</datatype>

<datatype>
	<name dialects="oxn" modules="oxne">URL</name>
	<descriptors>name</descriptors>
	<description>
		<p>
			The <a>dt:URL</a> data type represents a URL.
		</p>
	</description>
	<notes>
		<p>
			Opening a <a>dt:URL</a> with the <a>cm:open</a> command
			without specifying an I/O method opens the URL in the user's
			default browser. Opening a <a>dt:URL</a> while specifying
			an I/O method allows using the <a>cm:read</a> and
			<a>cm:write</a> commands to read from and write to the URL.
		</p>
	</notes>
	<see-also>
		mg:URL, cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</datatype>

<datatype>
	<name dialects="oxn" modules="oxne">URLs</name>
	<description>
		<p>
			The <a>dt:URLs</a> data type represents a <a>dt:list</a>
			that consists entirely of <a>dt:URL</a>s.
		</p>
	</description>
	<notes>
		<p>
			Opening a <a>dt:URL</a> with the <a>cm:open</a> command
			without specifying an I/O method opens the URL in the user's
			default browser. Opening a <a>dt:URL</a> while specifying
			an I/O method allows using the <a>cm:read</a> and
			<a>cm:write</a> commands to read from and write to the URL.
		</p>
	</notes>
	<see-also>
		mg:URL, cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</datatype>

<property>
	<name dialects="xn,oxn" modules="oxns">textEncoding</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set textEncoding to "ISO-8859-1"
		</scr>
		<scr>
			set the textEncoding to "UTF-8"
		</scr>
		<scr>
			set textEncoding to "MacRoman"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the text encoding
			used by several commands and functions, among them <a>cm:open</a>,
			<a>fn:numToChar</a>, and <a>fn:charToNum</a>, and
			<code>\x</code> escape sequences in quoted literals.
		</p>
	</description>
	<notes>
		<p>
			The default text encoding in OpenXION is ISO-8859-1.
		</p>
		<p>
			The XION Scripting Language Standard specifies ISO-8859-1,
			UTF-8, UTF-16, and MacRoman as the minimal set of supported
			text encodings.
		</p>
	</notes>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">lineEnding</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set lineEnding to return&amp;newline -- MS-DOS style
		</scr>
		<scr>
			set lineEnding to return -- Mac OS Classic style
		</scr>
		<scr>
			set lineEnding to newline -- Unix style
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the line endings
			created by the <a>dt:line</a> chunk type and the <a>cm:sort</a>
			command, and the line endings used in the default
			<a>pr:applicationPaths</a>, <a>pr:documentPaths</a>,
			and <a>pr:includePaths</a>.
		</p>
	</description>
	<notes>
		<p>
			The default line ending in OpenXION is <a>cn:newline</a>.
		</p>
		<p>
			For consistent behavior, the <me/> should be set to one of
			the following: <a>cn:return</a><a>op:&amp;</a><a>cn:newline</a>,
			<a>cn:newline</a>, <a>cn:return</a>, <a>cn:linesep</a>,
			or <a>cn:parasep</a>. Although the <me/> can be set to anything,
			only those particular strings will be <i>recognized</i>
			as line endings, no matter what the <me/> is set to.
		</p>
	</notes>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">numberFormat</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set numberFormat to "00.##" -- displays 02.21 for 2.21
		</scr>
		<scr>
			set numberFormat to "0" -- displays 2 for 2.21
		</scr>
		<scr>
			set numberFormat to "0.0" -- displays 2.2 for 2.21
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the format used when
			<a>dt:integer</a>s, <a>dt:number</a>s, and <a>dt:complex</a>es
			are converted to <a>dt:string</a>s. Use zeroes (<code>0</code>)
			to represent digits that always appear, a period (<code>.</code>)
			to represent the decimal point, and number signs (<code>#</code>)
			to represent digits that appear only when they are non-zero.
			Use <code>E</code> followed by one or more zeroes to specify
			scientific notation. If scientific notation is specified,
			you can use <code>&lt;</code> followed by an integer to specify
			scientific notation only for numbers with an exponent less than
			or equal to that integer, and <code>&gt;</code> followed by
			an integer to specify scientific notation only for numbers
			with an exponent greater than or equal to that integer.
		</p>
		<p>
			The following table illustrates various number formats:
		</p>
		<table>
			<tr>
				<th>Format</th>
				<th>0</th>
				<th>0.00715</th>
				<th>0.0715</th>
				<th>0.715</th>
				<th>7.15</th>
				<th>71.5</th>
				<th>715</th>
				<th>7150</th>
			</tr>
			<tr>
				<td><code>0.######</code></td>
				<td><code>0</code></td>
				<td><code>0.00715</code></td>
				<td><code>0.0715</code></td>
				<td><code>0.715</code></td>
				<td><code>7.15</code></td>
				<td><code>71.5</code></td>
				<td><code>715</code></td>
				<td><code>7150</code></td>
			</tr>
			<tr>
				<td><code>0.##</code></td>
				<td><code>0</code></td>
				<td><code>0.01</code></td>
				<td><code>0.07</code></td>
				<td><code>0.72</code></td>
				<td><code>7.15</code></td>
				<td><code>71.5</code></td>
				<td><code>715</code></td>
				<td><code>7150</code></td>
			</tr>
			<tr>
				<td><code>0.#</code></td>
				<td><code>0</code></td>
				<td><code>0</code></td>
				<td><code>0.1</code></td>
				<td><code>0.7</code></td>
				<td><code>7.2</code></td>
				<td><code>71.5</code></td>
				<td><code>715</code></td>
				<td><code>7150</code></td>
			</tr>
			<tr>
				<td><code>0.000000</code></td>
				<td><code>0.000000</code></td>
				<td><code>0.007150</code></td>
				<td><code>0.071500</code></td>
				<td><code>0.715000</code></td>
				<td><code>7.150000</code></td>
				<td><code>71.500000</code></td>
				<td><code>715.000000</code></td>
				<td><code>7150.000000</code></td>
			</tr>
			<tr>
				<td><code>0.00</code></td>
				<td><code>0.00</code></td>
				<td><code>0.01</code></td>
				<td><code>0.07</code></td>
				<td><code>0.72</code></td>
				<td><code>7.15</code></td>
				<td><code>71.50</code></td>
				<td><code>715.00</code></td>
				<td><code>7150.00</code></td>
			</tr>
			<tr>
				<td><code>0.0</code></td>
				<td><code>0.0</code></td>
				<td><code>0.0</code></td>
				<td><code>0.1</code></td>
				<td><code>0.7</code></td>
				<td><code>7.2</code></td>
				<td><code>71.5</code></td>
				<td><code>715.0</code></td>
				<td><code>7150.0</code></td>
			</tr>
			<tr>
				<td><code>0.00##</code></td>
				<td><code>0.00</code></td>
				<td><code>0.0072</code></td>
				<td><code>0.0715</code></td>
				<td><code>0.715</code></td>
				<td><code>7.15</code></td>
				<td><code>71.50</code></td>
				<td><code>715.00</code></td>
				<td><code>7150.00</code></td>
			</tr>
			<tr>
				<td><code>0.0#</code></td>
				<td><code>0.0</code></td>
				<td><code>0.01</code></td>
				<td><code>0.07</code></td>
				<td><code>0.72</code></td>
				<td><code>7.15</code></td>
				<td><code>71.5</code></td>
				<td><code>715.0</code></td>
				<td><code>7150.0</code></td>
			</tr>
			<tr>
				<td><code>0</code></td>
				<td><code>0</code></td>
				<td><code>0</code></td>
				<td><code>0</code></td>
				<td><code>1</code></td>
				<td><code>7</code></td>
				<td><code>72</code></td>
				<td><code>715</code></td>
				<td><code>7150</code></td>
			</tr>
			<tr>
				<td><code>0.###E0</code></td>
				<td><code>0E0</code></td>
				<td><code>7.15E-3</code></td>
				<td><code>7.15E-2</code></td>
				<td><code>7.15E-1</code></td>
				<td><code>7.15E0</code></td>
				<td><code>7.15E1</code></td>
				<td><code>7.15E2</code></td>
				<td><code>7.15E3</code></td>
			</tr>
			<tr>
				<td><code>0.#E0</code></td>
				<td><code>0E0</code></td>
				<td><code>7.2E-3</code></td>
				<td><code>7.2E-2</code></td>
				<td><code>7.2E-1</code></td>
				<td><code>7.2E0</code></td>
				<td><code>7.2E1</code></td>
				<td><code>7.2E2</code></td>
				<td><code>7.2E3</code></td>
			</tr>
			<tr>
				<td><code>0.#E00</code></td>
				<td><code>0E00</code></td>
				<td><code>7.2E-03</code></td>
				<td><code>7.2E-02</code></td>
				<td><code>7.2E-01</code></td>
				<td><code>7.2E00</code></td>
				<td><code>7.2E01</code></td>
				<td><code>7.2E02</code></td>
				<td><code>7.2E03</code></td>
			</tr>
			<tr>
				<td><code>0.000E0</code></td>
				<td><code>0.000E0</code></td>
				<td><code>7.150E-3</code></td>
				<td><code>7.150E-2</code></td>
				<td><code>7.150E-1</code></td>
				<td><code>7.150E0</code></td>
				<td><code>7.150E1</code></td>
				<td><code>7.150E2</code></td>
				<td><code>7.150E3</code></td>
			</tr>
			<tr>
				<td><code>0.##E0&lt;-3&gt;3</code></td>
				<td><code>0</code></td>
				<td><code>7.15E-3</code></td>
				<td><code>0.07</code></td>
				<td><code>0.72</code></td>
				<td><code>7.15</code></td>
				<td><code>71.5</code></td>
				<td><code>715</code></td>
				<td><code>7.15E3</code></td>
			</tr>
			<tr>
				<td><code>0.##E0&lt;-2&gt;2</code></td>
				<td><code>0</code></td>
				<td><code>7.15E-3</code></td>
				<td><code>7.15E-2</code></td>
				<td><code>0.72</code></td>
				<td><code>7.15</code></td>
				<td><code>71.5</code></td>
				<td><code>7.15E2</code></td>
				<td><code>7.15E3</code></td>
			</tr>
			<tr>
				<td><code>0.##E0&lt;-1&gt;1</code></td>
				<td><code>0</code></td>
				<td><code>7.15E-3</code></td>
				<td><code>7.15E-2</code></td>
				<td><code>7.15E-1</code></td>
				<td><code>7.15</code></td>
				<td><code>7.15E1</code></td>
				<td><code>7.15E2</code></td>
				<td><code>7.15E3</code></td>
			</tr>
			<tr>
				<td><code>0.###'0</code></td>
				<td><code>0'0</code></td>
				<td><code>7.15''3</code></td>
				<td><code>7.15''2</code></td>
				<td><code>7.15''1</code></td>
				<td><code>7.15'0</code></td>
				<td><code>7.15'1</code></td>
				<td><code>7.15'2</code></td>
				<td><code>7.15'3</code></td>
			</tr>
			<tr>
				<td><code>0.#'0</code></td>
				<td><code>0'0</code></td>
				<td><code>7.2''3</code></td>
				<td><code>7.2''2</code></td>
				<td><code>7.2''1</code></td>
				<td><code>7.2'0</code></td>
				<td><code>7.2'1</code></td>
				<td><code>7.2'2</code></td>
				<td><code>7.2'3</code></td>
			</tr>
			<tr>
				<td><code>0.#'00</code></td>
				<td><code>0'00</code></td>
				<td><code>7.2''03</code></td>
				<td><code>7.2''02</code></td>
				<td><code>7.2''01</code></td>
				<td><code>7.2'00</code></td>
				<td><code>7.2'01</code></td>
				<td><code>7.2'02</code></td>
				<td><code>7.2'03</code></td>
			</tr>
			<tr>
				<td><code>0.000'0</code></td>
				<td><code>0.000'0</code></td>
				<td><code>7.150''3</code></td>
				<td><code>7.150''2</code></td>
				<td><code>7.150''1</code></td>
				<td><code>7.150'0</code></td>
				<td><code>7.150'1</code></td>
				<td><code>7.150'2</code></td>
				<td><code>7.150'3</code></td>
			</tr>
			<tr>
				<td><code>0.##'0&lt;-3&gt;3</code></td>
				<td><code>0</code></td>
				<td><code>7.15''3</code></td>
				<td><code>0.07</code></td>
				<td><code>0.72</code></td>
				<td><code>7.15</code></td>
				<td><code>71.5</code></td>
				<td><code>715</code></td>
				<td><code>7.15'3</code></td>
			</tr>
			<tr>
				<td><code>0.##'0&lt;-2&gt;2</code></td>
				<td><code>0</code></td>
				<td><code>7.15''3</code></td>
				<td><code>7.15''2</code></td>
				<td><code>0.72</code></td>
				<td><code>7.15</code></td>
				<td><code>71.5</code></td>
				<td><code>7.15'2</code></td>
				<td><code>7.15'3</code></td>
			</tr>
			<tr>
				<td><code>0.##'0&lt;-1&gt;1</code></td>
				<td><code>0</code></td>
				<td><code>7.15''3</code></td>
				<td><code>7.15''2</code></td>
				<td><code>7.15''1</code></td>
				<td><code>7.15</code></td>
				<td><code>7.15'1</code></td>
				<td><code>7.15'2</code></td>
				<td><code>7.15'3</code></td>
			</tr>
		</table>
	</description>
	<notes>
		<p>
			The <me/> property does not affect the accuracy or precision
			of mathematical operations, only the presentation of the results.
			To change the precision of mathematical operations, see
			<a>pr:precision</a>.
		</p>
		<p>
			The default number format in both HyperTalk and XION is
			<code>0.######</code>.
		</p>
	</notes>
	<compatibility>
		<p>
			HyperTalk supports only the <code>0</code>, <code>.</code>,
			and <code>#</code> characters in its <me/> property.
		</p>
	</compatibility>
	<see-also>
		pr:precision
	</see-also>
</property>

<property>
	<name dialects="oxn" modules="oxns">mathProcessor</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set mathProcessor to "fast"
		</scr>
		<scr>
			set mathProcessor to "big"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes how mathematical functions
			are evaluated. If the <me/> is set to <code>"fast"</code>,
			mathematical functions use IEEE double precision for the best
			performance. If the <me/> is set to <code>"big"</code>,
			mathematical functions use various methods with arbitrary precision
			for the best accuracy. The number of fractional digits used when
			the <me/> is set to <code>"big"</code> is determined by the
			<a>pr:precision</a> property.
		</p>
		<p>
			Evaluating expressions with the <me/> set to <code>"big"</code>
			will significantly slow down scripts, so the <me/> is set to
			<code>"fast"</code> by default.
		</p>
	</description>
	<notes>
		<p>
			The <me/> property is specific to OpenXION; it is not
			part of the XION Scripting Language Standard.
		</p>
	</notes>
	<see-also>
		pr:precision, pr:roundingMode
	</see-also>
</property>

<property>
	<name dialects="oxn" modules="oxns">precision</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set precision to 100
		</scr>
		<scr>
			set precision to 6
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the number of
			fractional digits used when evaluating mathematical operations,
			as well as mathematical functions, when the <a>pr:mathProcessor</a>
			is set to <code>"big"</code>.
		</p>
		<p>
			The default value of the <me/> property is 100.
		</p>
	</description>
	<notes>
		<p>
			The <me/> property does not affect the formatting of numbers,
			only the precision of calculations. See the <a>pr:numberFormat</a>
			property.
		</p>
		<p>
			The <me/> property is specific to OpenXION; it is not
			part of the XION Scripting Language Standard.
		</p>
	</notes>
	<see-also>
		pr:numberFormat, pr:roundingMode, pr:mathProcessor
	</see-also>
</property>

<property>
	<name dialects="oxn" modules="oxns">roundingMode</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set roundingMode to "even"
		</scr>
		<scr>
			set roundingMode to "down"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the rounding mode
			used when evaluating mathematical operations and functions.
			The possible values for the <me/> are
			<code>"ceiling"</code>, corresponding to the rounding
			used by the <a>fn:ceil</a> function;
			<code>"floor"</code>, corresponding to the rounding
			used by the <a>fn:floor</a> function;
			<code>"up"</code>, corresponding to the rounding
			used by the <a>fn:aug</a> function;
			<code>"down"</code>, corresponding to the rounding
			used by the <a>fn:trunc</a> function;
			<code>"nearest"</code>, corresponding to the rounding
			used by the <a>fn:round</a> function;
			and
			<code>"even"</code>, corresponding to the rounding
			used by the <a>fn:rint</a> function.
		</p>
		<p>
			The default value of the <me/> property is <code>"even"</code>.
		</p>
	</description>
	<notes>
		<p>
			The <me/> property is specific to OpenXION; it is not
			part of the XION Scripting Language Standard.
		</p>
	</notes>
	<see-also>
		pr:precision, pr:mathProcessor
	</see-also>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">itemDelimiter</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			if the itemDelimiter &lt;&gt; comma
			then set the itemDelimiter to comma
		</scr>
		<scr>
			set itemDelimiter to "#"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the character
			that delimits <a>dt:item</a> chunks.
			The default value is <a>cn:comma</a>.
		</p>
		<p>
			Changing the item delimiter has no effect on other data types,
			such as <a>dt:point</a> or <a>dt:rectangle</a>,
			or on functions, such as <a>fn:dateItems</a>.
		</p>
	</description>
	<see-also>
		dt:item, pr:rowDelimiter, pr:columnDelimiter
	</see-also>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">columnDelimiter</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set columnDelimiter to delete
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the character
			that delimits <a>dt:column</a> chunks.
			The default value is Unicode character <code>U+FFF0</code>.
		</p>
	</description>
	<see-also>
		dt:column, pr:itemDelimiter, pr:rowDelimiter
	</see-also>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">rowDelimiter</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set rowDelimiter to backspace
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the character
			that delimits <a>dt:row</a> chunks.
			The default value is Unicode character <code>U+FFF1</code>.
		</p>
	</description>
	<see-also>
		dt:row, pr:itemDelimiter, pr:columnDelimiter
	</see-also>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">littleEndian</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set the littleEndian to true -- use little-endian byte order
		</scr>
		<scr>
			set the littleEndian to false -- use big-endian byte order
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the endianness of the
			<a>dt:tinyInt</a>, <a>dt:shortInt</a>, <a>dt:mediumInt</a>,
			<a>dt:longInt</a>, <a>dt:halfFloat</a>, <a>dt:singleFloat</a>,
			and <a>dt:doubleFloat</a> binary numeric chunk types.
			A <a>cn:true</a> value indicates that binary data should be
			treated as little-endian. A <a>cn:false</a> value indicates
			that binary data should be treated as big-endian.
			The default is <a>cn:false</a>, or big-endian.
			(This was chosen as the default because the 68000 and PowerPC
			architectures running Mac OS Classic and the Java virtual machine
			are big-endian.)
		</p>
	</description>
	<see-also>
		pr:unsigned, dt:binary,
		dt:tinyInt, dt:shortInt, dt:mediumInt, dt:longInt,
		dt:halfFloat, dt:singleFloat, dt:doubleFloat
	</see-also>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">unsigned</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set the unsigned to false -- use signed integers
		</scr>
		<scr>
			set the unsigned to true -- use unsigned integers
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the signedness of the
			<a>dt:tinyInt</a>, <a>dt:shortInt</a>, <a>dt:mediumInt</a>,
			and <a>dt:longInt</a> binary numeric chunk types.
			A <a>cn:true</a> value indicates that binary data should be
			treated as unsigned. A <a>cn:false</a> value indicates that
			binary data should be treated as signed.
			The default is <a>cn:false</a>, or signed.
		</p>
	</description>
	<see-also>
		pr:littleEndian, dt:binary,
		dt:tinyInt, dt:shortInt, dt:mediumInt, dt:longInt
	</see-also>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">left</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the left of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the x coordinate
			of the top left corner of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">top</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the top of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the y coordinate
			of the top left corner of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">right</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the right of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the x coordinate
			of the bottom right corner of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">bottom</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the bottom of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the y coordinate
			of the bottom right corner of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">topLeft</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the topLeft of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the top left corner of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">topRight</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the topRight of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the top right corner of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">botLeft</name>
	<name dialects="xn,oxn" modules="oxns">bottomLeft</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the bottomLeft of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the bottom left corner of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">botRight</name>
	<name dialects="xn,oxn,hyp" modules="oxns">bottomRight</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the bottomRight of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the bottom right corner of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">loc</name>
	<name dialects="xn,oxn,hyp" modules="oxns">location</name>
	<name dialects="xn,oxn" modules="oxns">center</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the loc of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the center of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">width</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the width of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the width of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">height</name>
	<applies-to>
		<p><a>dt:Rectangle</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the height of ((100,50,600,230) as rectangle)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the height of a rectangle.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">red</name>
	<applies-to>
		<p><a>dt:Color</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the red of purple
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the intensity of the red channel
			of a color. The intensity is specified as an <a>dt:integer</a>
			between zero and 65535, inclusive.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">green</name>
	<applies-to>
		<p><a>dt:Color</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the green of purple
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the intensity of the green channel
			of a color. The intensity is specified as an <a>dt:integer</a>
			between zero and 65535, inclusive.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">blue</name>
	<applies-to>
		<p><a>dt:Color</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the blue of purple
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the intensity of the blue channel
			of a color. The intensity is specified as an <a>dt:integer</a>
			between zero and 65535, inclusive.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn&ge;1.2" modules="oxns&ge;1.2">alpha</name>
	<applies-to>
		<p><a>dt:Color</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the alpha of purple
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the alpha channel of a color.
			The alpha is specified as an <a>dt:integer</a> between zero
			(transparent) and 65535 (opaque), inclusive.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">hue</name>
	<applies-to>
		<p><a>dt:Color</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the hue of purple
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the hue of a color. The hue
			is specified as a <a>dt:number</a> between 0.0 and 1.0, inclusive.
			A hue of 0.0 is red, 0.1666... is yellow, 0.333... is green,
			0.5 is cyan, 0.666... is blue, and 0.8333... is magenta.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">saturation</name>
	<applies-to>
		<p><a>dt:Color</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the saturation of purple
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the saturation of a color. The
			saturation is specified as a <a>dt:number</a> between 0.0 and 1.0,
			inclusive. A saturation of 0.0 is a shade of gray while a
			saturation of 1.0 is a full color.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">brightness</name>
	<applies-to>
		<p><a>dt:Color</a>s</p>
	</applies-to>
	<examples>
		<scr>
			get the brightness of purple
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the brightness or value of a color.
			The value is specified as a <a>dt:number</a> between 0.0 and 1.0,
			inclusive. A value of 0.0 is black while a value of 1.0 is a full
			color.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn&ge;1.3" modules="oxns&ge;1.3">keys</name>
	<applies-to>
		<p><a>dt:Dictionary</a>s</p>
	</applies-to>
	<description>
		<p>
			The <me/> property yields a <a>dt:list</a>
			of all the keys in a <a>dt:dictionary</a>.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn&ge;1.3" modules="oxns&ge;1.3">values</name>
	<applies-to>
		<p><a>dt:Dictionary</a>s</p>
	</applies-to>
	<description>
		<p>
			The <me/> property yields a <a>dt:list</a>
			of all the values in a <a>dt:dictionary</a>.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">name</name>
	<applies-to>
		<ul>
			<li>
				File system objects (<a>dt:disk</a>s, <a>dt:folder</a>s,
				<a>dt:file</a>s, and <a>dt:fork</a>s)
			</li>
			<li>User-defined objects</li>
		</ul>
	</applies-to>
	<examples>
		<scr>
			get the name of the first file
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the name of an object.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">id</name>
	<applies-to>
		<p>User-defined objects</p>
	</applies-to>
	<examples>
		<scr>
			get the id of steve
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the unique ID number of an object.
			An object's ID number will never change during the object's
			lifetime and will be unique among objects of the same type.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn,hyp" modules="oxns">number</name>
	<applies-to>
		<ul>
			<li>Chunk types</li>
			<li>Lists</li>
			<li>User-defined objects</li>
		</ul>
	</applies-to>
	<examples>
		<scr>
			get the number of elements in steve
		</scr>
		<scr>
			get the number of words in bill
		</scr>
		<scr>
			get the number of andy
		</scr>
	</examples>
	<description>
		<p>
			For chunk types, the <me/> property determines
			the number of chunks in a range.
		</p>
		<p>
			For lists, the <me/> property determines
			the number of items in a list.
		</p>
		<p>
			For objects, the <me/> property determines
			the index of an object.
		</p>
	</description>
	<see-also>
		fn:number
	</see-also>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">path</name>
	<applies-to>
		<p>
			File system objects (<a>dt:disk</a>s, <a>dt:folder</a>s,
			<a>dt:file</a>s, and <a>dt:fork</a>s)
		</p>
	</applies-to>
	<examples>
		<scr>
			get the path of the first file
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the path
			of a file system object. Changing the path effectively
			moves the file.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">modificationDate</name>
	<applies-to>
		<p>
			File system objects (<a>dt:disk</a>s, <a>dt:folder</a>s,
			<a>dt:file</a>s, and <a>dt:fork</a>s)
		</p>
	</applies-to>
	<examples>
		<scr>
			get the modificationDate of the first file
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the modification date
			of a file system object.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">count</name>
	<applies-to>
		<p>
			Directory-type file system objects
			(<a>dt:disk</a>s and <a>dt:folder</a>s)
		</p>
	</applies-to>
	<examples>
		<scr>
			get the count of the first volume
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the number of files and folders
			in a file system object.
		</p>
	</description>
</property>

<property>
	<name dialects="xn,oxn" modules="oxns">size</name>
	<applies-to>
		<p>
			Stream-type file system objects
			(<a>dt:file</a>s and <a>dt:fork</a>s)
		</p>
	</applies-to>
	<examples>
		<scr>
			get the size of the first file
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the size in bytes
			of a file system object.
		</p>
	</description>
</property>

<property>
	<name dialects="oxn" modules="oxns">userName</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			answer "Hello," &amp;&amp; the long userName &amp; "!"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines the user's login name or full real
			name. The <a>kw:short</a> <me/> or <a>kw:abbreviated</a> <me/> is
			usually the user's login name. The <a>kw:long</a> <me/> is usually
			the user's full real name. If no modifier is specified,
			<a>kw:long</a> is assumed.
		</p>
		<p>
			In OpenXION 1.0 and 1.1, the <a>kw:long</a> <me/> can be
			<a>cm:set</a> but the <a>kw:short</a> <me/> is read-only.
			In OpenXION 1.2 and later, both the <a>kw:long</a> <me/>
			and the <a>kw:short</a> <me/> are read-only. (See note.)
		</p>
	</description>
	<notes>
		<p>
			HyperTalk did not have this property but used a
			<code>Username</code> global variable for the same purpose.
			OpenXION avoids using any XION global variables for special purposes.
		</p>
		<p>
			OpenXION 1.0 and 1.1 did not get the user's full real name
			from the system, but left the <a>kw:long</a> <me/> as a
			property to be <a>cm:set</a> by the user themselves.
			OpenXION 1.2 and later get the user's full real name
			from the system instead.
		</p>
		<p>
			The <me/> property is specific to OpenXION; it is not
			part of the XION Scripting Language Standard.
		</p>
	</notes>
</property>

<property>
	<name dialects="oxn" modules="oxns">applicationPaths</name>
	<name dialects="oxn" modules="oxns">programPaths</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<p>
			<code>set <me/> to the <me/> &amp; newline &amp; "/home/jdoe/bin/"</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the list of
			file system paths searched by the <a>cm:open</a> command
			and the <a>fn:appPath</a>, <a>fn:appFile</a>,
			<a>fn:appOrDocPath</a>, and <a>fn:appOrDocFile</a>
			functions to locate applications or program files.
		</p>
	</description>
	<notes>
		<p>
			HyperTalk did not have this property but used an
			<code>Applications</code> global variable for the same purpose.
			OpenXION avoids using any XION global variables for special purposes.
		</p>
		<p>
			The default list of paths in OpenXION is, on Mac OS X:
		</p>
		<scr>
			/Applications/
			/Applications/Utilities/
			/Applications (Mac OS 9)/
			~/Applications/
			/Developer/Applications/
			/Developer/Applications/Utilities/
			/bin/
			/sbin/
			/usr/bin/
			/usr/sbin/
			/usr/local/bin/
			/usr/local/sbin/
			/usr/shared/bin/
			/usr/shared/sbin/
			/opt/bin/
			/opt/sbin/
			/opt/local/bin/
			/opt/local/sbin/
			/opt/shared/bin/
			/opt/shared/sbin/
		</scr>
		<p>
			On Windows:
		</p>
		<scr>
			C:\Program Files\
			C:\Windows\
			C:\Windows\System32\
		</scr>
		<p>
			On all other systems:
		</p>
		<scr>
			/bin/
			/sbin/
			/usr/bin/
			/usr/sbin/
			/usr/local/bin/
			/usr/local/sbin/
			/usr/shared/bin/
			/usr/shared/sbin/
			/opt/bin/
			/opt/sbin/
			/opt/local/bin/
			/opt/local/sbin/
			/opt/shared/bin/
			/opt/shared/sbin/
		</scr>
		<p>
			(The <code>~</code> refers to the user's home directory.)
		</p>
		<p>
			OpenXION reads the value of this property from a file at startup
			and writes it back to the file upon exit. This file is located at
			<code>~/Library/Preferences/com.kreative.openxion.conf</code> (on Mac OS X),
			<code>~\Application Data\OpenXION\xion.conf</code> (on Windows),
			or <code>~/.xion.conf</code> (on all other systems).
			This is a plain text file that can be edited with any text editor.
		</p>
		<p>
			The <me/> property is specific to OpenXION; it is not
			part of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To change the value of this property, OpenXION's security settings
			must allow the <code>SEARCH_PATHS</code> security key. If the
			required security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:open, fn:appPath, fn:appFile,
		fn:appOrDocPath, fn:appOrDocFile
	</see-also>
</property>

<property>
	<name dialects="oxn" modules="oxns">documentPaths</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set documentPaths to the documentPaths &amp; newline &amp; "/home/jdoe/work/"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the list of
			file system paths searched by the <a>cm:open</a> command
			and the <a>fn:docPath</a>, <a>fn:docFile</a>,
			<a>fn:appOrDocPath</a>, and <a>fn:appOrDocFile</a>
			functions to locate document files.
		</p>
	</description>
	<notes>
		<p>
			HyperTalk did not have this property but used a
			<code>Documents</code> global variable for the same purpose.
			OpenXION avoids using any XION global variables for special purposes.
		</p>
		<p>
			The default list of paths in OpenXION is, on Mac OS X:
		</p>
		<scr>
			~/Desktop/
			~/Documents/
			~/Downloads/
			~/Pictures/
			~/Music/
			~/Movies/
			~/Public/
			~/Sites/
			~/
		</scr>
		<p>
			On Windows:
		</p>
		<scr>
			~\Desktop\
			~\My Documents\
			~\My Photos\
			~\My Music\
			~\My Videos\
			~\
		</scr>
		<p>
			On all other systems:
		</p>
		<scr>
			~/
		</scr>
		<p>
			(The <code>~</code> refers to the user's home directory.)
		</p>
		<p>
			OpenXION reads the value of this property from a file at startup
			and writes it back to the file upon exit. This file is located at
			<code>~/Library/Preferences/com.kreative.openxion.conf</code> (on Mac OS X),
			<code>~\Application Data\OpenXION\xion.conf</code> (on Windows),
			or <code>~/.xion.conf</code> (on all other systems).
			This is a plain text file that can be edited with any text editor.
		</p>
		<p>
			The <me/> property is specific to OpenXION; it is not
			part of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To change the value of this property, OpenXION's security settings
			must allow the <code>SEARCH_PATHS</code> security key. If the
			required security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:open, fn:docPath, fn:docFile,
		fn:appOrDocPath, fn:appOrDocFile
	</see-also>
</property>

<property>
	<name dialects="oxn&ge;1.1" modules="oxns&ge;1.1">includePaths</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<examples>
		<scr>
			set includePaths to the includePaths &amp; newline &amp; "/home/jdoe/scripts/"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> property determines or changes the list of
			file system paths searched by the <a>cs:include</a> and
			<a>cs:require</a> keywords and the <a>fn:includePath</a>
			and <a>fn:includeFile</a> functions to locate include files.
		</p>
	</description>
	<notes>
		<p>
			The default list of paths in OpenXION consists
			solely of the current working directory.
		</p>
		<p>
			OpenXION reads the value of this property from a file at startup
			and writes it back to the file upon exit. This file is located at
			<code>~/Library/Preferences/com.kreative.openxion.conf</code> (on Mac OS X),
			<code>~\Application Data\OpenXION\xion.conf</code> (on Windows),
			or <code>~/.xion.conf</code> (on all other systems).
			This is a plain text file that can be edited with any text editor.
		</p>
		<p>
			The <me/> property is specific to OpenXION; it is not
			part of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To change the value of this property, OpenXION's security settings
			must allow the <code>SEARCH_PATHS</code> security key. If the
			required security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cs:include, cs:require, fn:includePath, fn:includeFile
	</see-also>
</property>

<property>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">dialingPort</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<description>
		<p>
			The <me/> property determines which communications port is used
			by the <a>cm:dial</a> command to dial a phone number using a modem.
			A list of possible values for this property is returned by the
			<a>fn:serialPorts</a> function.
		</p>
	</description>
	<security>
		<p>
			To use the <me/> property, OpenXION's security settings
			must allow the <code>TELEPHONY</code> security key.
			If the required security key is denied, a script error
			will be triggered.
		</p>
	</security>
	<compatibility>
		<p>
			In HyperTalk, this property existed but was undocumented.
		</p>
	</compatibility>
	<see-also>
		cm:dial, fn:serialPorts
	</see-also>
</property>

<property>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">dialingTime</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<description>
		<p>
			The <me/> property determines the amount of time the <a>cm:dial</a>
			command waits before closing the communications port after issuing
			the modem command to dial a phone number. The amount of time
			is specified in ticks, or sixtieths of a second. The default
			value is 180 ticks, or 3 seconds.
		</p>
	</description>
	<see-also>
		cm:dial
	</see-also>
</property>

<property>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">dialingVolume</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<description>
		<p>
			The <me/> property determines the volume of the dial tones
			produced by the <a>cm:dial</a> command. The default value is 7.
		</p>
	</description>
	<notes>
		<p>
			In HyperTalk, as in old versions of Mac OS Classic, the volume was
			restricted to an <a>dt:integer</a> between 0 and 7. OpenXION uses the
			same range for compatibility, but allows any <a>dt:number</a> in order
			to give finer control over volume.
		</p>
	</notes>
	<see-also>
		cm:dial, pr:toneVolume
	</see-also>
</property>

<property>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">soundChannel</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<description>
		<p>
			The <me/> property determines which channel music produced
			by the <a>cm:play</a> command is played on. Only one sequence
			can be played on a single channel at any one time, but multiple
			sequences can be played simultaneously on different channels.
			Both HyperTalk and OpenXION support 8 channels, numbered 1
			through 8.
		</p>
	</description>
	<see-also>
		cm:play, fn:sound, pr:toneChannel
	</see-also>
</property>

<property>
	<name dialects="oxn&ge;1.2" modules="oxna&ge;1.2">toneChannel</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<description>
		<p>
			The <me/> property determines which channel tones produced
			by the <a>cm:tone</a> command is played on. Only one tone
			can be played on a single channel at any one time, but multiple
			tones can be played simultaneously on different channels.
			OpenXION supports 8 channels, numbered 1 through 8.
		</p>
	</description>
	<notes>
		<p>
			Music played with the <a>cm:play</a> command and tones produced by
			the <a>cm:tone</a> command are always played on separate channels,
			despite the similarities between the <a>pr:soundChannel</a> and
			<a>pr:toneChannel</a> properties.
		</p>
	</notes>
	<see-also>
		cm:tone, fn:tone, pr:soundChannel
	</see-also>
</property>

<property>
	<name dialects="oxn&ge;1.2" modules="oxna&ge;1.2">toneVolume</name>
	<applies-to>
		<p>Global environment</p>
	</applies-to>
	<description>
		<p>
			The <me/> property determines the volume of the tones
			produced by the <a>cm:tone</a> command. The default value is 7.
		</p>
	</description>
	<notes>
		<p>
			In HyperTalk, as in old versions of Mac OS Classic, the volume was
			restricted to an <a>dt:integer</a> between 0 and 7. OpenXION uses the
			same range for compatibility, but allows any <a>dt:number</a> in order
			to give finer control over volume.
		</p>
	</notes>
	<see-also>
		cm:tone, pr:dialingVolume
	</see-also>
</property>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">add</name>
	<syntax>
		<syn>
			add <mv>number</mv> to <mv>container</mv>
		</syn>
		<p>
			<mv>Number</mv> yields an <a>dt:integer</a>, a <a>dt:number</a>,
			or a <a>dt:complex</a>. <mv>Container</mv> yields a container
			containing an <a>dt:integer</a>, a <a>dt:number</a>, or a
			<a>dt:complex</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			add 3 to it
		</scr>
		<scr>
			add amount to total
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command adds the value of <mv>number</mv> to the value
			of <mv>container</mv> and leaves the result in <mv>container</mv>.
			The value in the container must be an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a> and is replaced
			with the new value.
		</p>
	</description>
	<scripts>
		<p>
			The following example sums a line-delimited list of numbers and prints
			the result.
		</p>
		<scr>
			on printSum numberList
			  put 0 into total
			  repeat with count = 1 to the number of lines ¬
			      in numberList
			    add line count of numberList to total
			  end repeat
			  put total
			end printSum
		</scr>
	</scripts>
	<see-also>
		cm:subtract, cm:multiply, cm:divide, cm:modulo,
		op:+, fn:sum
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">answer</name>
	<syntax>
		<syn>
			answer <mv>question</mv>
			<opt>
				with <mv>reply</mv>
				<opt>
					or <mv>reply</mv>
					<opt>
						or <mv>reply</mv>
					</opt>
				</opt>
			</opt>
			<opt>at <mv>point</mv></opt>
		</syn>
		<syn>
			answer list <mv>promptText</mv>
			with <mv>list</mv>
			<opt>at <mv>point</mv></opt>
		</syn>
		<syn>
			answer file <mv>promptText</mv>
			<opt>
				of type <mv>fileType</mv>
				<opt>
					or <mv>fileType</mv>
					<opt>
						or <mv>fileType</mv>
					</opt>
				</opt>
			</opt>
			<opt>at <mv>point</mv></opt>
		</syn>
		<syn>
			answer <ch><ci>folder</ci><ci>directory</ci></ch> <mv>promptText</mv>
			<opt>at <mv>point</mv></opt>
		</syn>
		<syn>
			answer <ch><ci>disk</ci><ci>volume</ci></ch> <mv>promptText</mv>
			<opt>at <mv>point</mv></opt>
		</syn>
		<p>
			<mv>Question</mv>, <mv>reply</mv>, <mv>promptText</mv>, and
			<mv>fileType</mv> yield <a>dt:string</a>s. <mv>List</mv> yields
			a <a>dt:list</a>. <mv>Point</mv> yields a <a>dt:point</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			answer "Which is the way the world ends?" with "Bang" or "Whimper"
		</scr>
		<scr>
			answer file "Pick a file:"
		</scr>
	</examples>
	<description>
		<p>
			The <code>answer</code> command displays a prompt to the user
			with up to three possible responses. The last response appears
			as the default response to the prompt. If no possible responses
			are specified, a single possible response will be presented with
			the text "OK." The script waits until one of the possible responses
			is chosen. The chosen response is placed in the local variable
			<code>it</code>.
		</p>
		<p>
			The <code>answer list</code> command displays a prompt to the user
			with a list of any number of possible responses. The script waits
			until one of the possible responses is selected. The chosen
			response is placed in the local variable <code>it</code> and the
			<a>fn:result</a> is set to <code>"OK"</code>. If the prompt is
			dismissed without choosing a response, <a>cn:empty</a> is placed
			in <code>it</code> and the <a>fn:result</a> is set to
			<code>"Cancel"</code>.
		</p>
		<p>
			The <code>answer file</code> command displays a prompt to the user
			asking to select a file. The script waits until a file is selected.
			The path of the selected file is placed in the local variable
			<code>it</code> and the <a>fn:result</a> is set to <code>"OK"</code>.
			If the prompt is dismissed without selecting a file, <a>cn:empty</a>
			is placed in <code>it</code> and the <a>fn:result</a> is set to
			<code>"Cancel"</code>.
		</p>
		<p>
			The <code>answer folder</code> or <code>answer directory</code>
			command displays a prompt to the user asking to select a folder.
			The script waits until a folder is selected. The path of the
			selected folder is placed in the local variable <code>it</code>
			and the <a>fn:result</a> is set to <code>"OK"</code>. If the
			prompt is dismissed without selecting a folder, <a>cn:empty</a>
			is placed in <code>it</code> and the <a>fn:result</a> is set to
			<code>"Cancel"</code>.
		</p>
		<p>
			The <code>answer disk</code> or <code>answer volume</code> command
			displays a prompt to the user asking to select a disk or volume.
			The script waits until a volume is selected. The path of the
			selected volume is placed in the local variable <code>it</code>
			and the <a>fn:result</a> is set to <code>"OK"</code>. If the prompt
			is dismissed without selecting a volume, <a>cn:empty</a> is placed
			in <code>it</code> and the <a>fn:result</a> is set to
			<code>"Cancel"</code>.
		</p>
		<p>
			The exact presentation of the prompts is left to the implementation.
			OpenXION presents a stylized text-based prompt, or a plain text-based
			prompt if the <code>-p</code> option is given. A GUI-based system,
			like HyperCard, will present an appropriate dialog box. The
			<kwd>at</kwd> parameter gives a preferred location for this dialog box.
		</p>
	</description>
	<scripts>
		<scr>
			on chooseColor
			  answer "Which color do you prefer?" with "Red" or ¬
			      "Blue" or "Yellow"
			  if it is "Red" then answer "You picked red."
			  else if it is "Blue" then answer "You picked blue."
			  else if it is "Yellow" then answer "You picked yellow."
			end chooseColor
		</scr>
	</scripts>
	<notes>
		<p>
			There is no way for a script to respond to a prompt by itself,
			so do not use <me/> in a script intended to run unattended.
		</p>
	</notes>
	<compatibility>
		<p>
			HyperTalk does not support the <code>answer list</code>,
			<code>answer directory</code>, <code>answer disk</code>,
			or <code>answer volume</code> forms, or the <code>at</code>
			parameter. However, the Power Tools stack has the
			<code>ShowList</code> XFCN that inspired the
			<code>answer list</code> command and HyperTalk itself has an
			<code>answer program</code> form that OpenXION does not.
		</p>
	</compatibility>
	<see-also>
		cm:ask
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">ask</name>
	<syntax>
		<syn>
			ask <mv>question</mv>
			<opt>with <mv>defaultAnswer</mv></opt>
			<opt>at <mv>point</mv></opt>
		</syn>
		<syn>
			ask password <opt>clear</opt> <mv>question</mv>
			<opt>with <mv>defaultAnswer</mv></opt>
			<opt>at <mv>point</mv></opt>
		</syn>
		<syn>
			ask file <mv>promptText</mv>
			<opt>with <mv>fileName</mv></opt>
			<opt>at <mv>point</mv></opt>
		</syn>
		<syn>
			ask <ch><ci>folder</ci><ci>directory</ci></ch> <mv>promptText</mv>
			<opt>with <mv>fileName</mv></opt>
			<opt>at <mv>point</mv></opt>
		</syn>
		<p>
			<mv>Question</mv>, <mv>defaultAnswer</mv>, <mv>promptText</mv>,
			and <mv>fileName</mv> yield <a>dt:string</a>s. <mv>Point</mv>
			yields a <a>dt:point</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			ask "Who needs this kind of grief?" with "Not me."
		</scr>
		<scr>
			ask password "Please enter your password:"
		</scr>
		<scr>
			ask file "Save this file as:" with "Untitled-1"
		</scr>
	</examples>
	<description>
		<p>
			The <code>ask</code> command displays a prompt to the user and
			allows the user to type a response. The optional
			<mv>defaultAnswer</mv> parameter specifies a response that
			initially appears. The prompt appears with "OK" and "Cancel"
			choices as well. The script waits until a response is typed
			and one of the choices is selected. If the "OK" choice is selected,
			the typed text is placed in the local variable <code>it</code>
			and the <a>fn:result</a> is set to <code>"OK"</code>. If the
			"Cancel" choice is selected, <a>cn:empty</a> is placed in
			<code>it</code> and the <a>fn:result</a> is set to
			<code>"Cancel"</code>.
		</p>
		<p>
			The <code>ask password</code> command hides the response from
			the user as it is being typed and hashes the response using the
			Atkinson hash (see the <a>fn:hash</a> function). The hashed
			response can be stored somewhere to be compared to a later
			response to <code>ask password</code> if, for example, you want
			the user to be able to protect data they enter.
		</p>
		<p>
			The <code>ask password clear</code> command hides the response
			from the user as it is being typed, but does not hash the response.
		</p>
		<p>
			The <code>ask file</code> command displays a prompt to the user
			asking for the location and name of a new file. The optional
			<mv>fileName</mv> parameter specifies a file name that initially
			appears. The script waits until a file name is entered. The file
			path is placed in the local variable <code>it</code> and the
			<a>fn:result</a> is set to <code>"OK"</code>. If the prompt is
			dismissed without entering a file name, <a>cn:empty</a> is placed
			in <code>it</code> and the <a>fn:result</a> is set to
			<code>"Cancel"</code>.
		</p>
		<p>
			The <code>ask folder</code> or <code>ask directory</code> command
			displays a prompt to the user asking for the location and name of
			a new folder or directory. The optional <mv>fileName</mv> parameter
			specifies a folder name that initially appears. The script waits
			until a folder name is entered. The directory path is placed in
			the local variable <code>it</code> and the <a>fn:result</a> is set
			to <code>"OK"</code>. If the prompt is dismissed without entering
			a folder name, <a>cn:empty</a> is placed in <code>it</code> and the
			<a>fn:result</a> is set to <code>"Cancel"</code>.
		</p>
		<p>
			The exact presentation of the prompts is left to the implementation.
			OpenXION presents a stylized text-based prompt, or a plain text-based
			prompt if the <code>-p</code> option is given. A GUI-based system,
			like HyperCard, will present an appropriate dialog box. The
			<kwd>at</kwd> parameter gives a preferred location for this dialog box.
		</p>
	</description>
	<notes>
		<p>
			The <code>ask password</code> command is not recommended for
			cryptographic purposes because the Atkinson hash algorithm
			is easily brute-forced. Instead, use the <code>ask password
			clear</code> command, then hash the cleartext password using
			a more secure <a>fn:hash</a> algorithm.
		</p>
		<p>
			The <code>ask file</code>, <code>ask folder</code>, and
			<code>ask directory</code> commands do not actually create
			the selected file or folder. The script must create the file
			or folder itself.
		</p>
		<p>
			There is no way for a script to respond to a prompt by itself,
			so do not use <me/> in a script intended to run unattended.
		</p>
	</notes>
	<compatibility>
		<p>
			HyperTalk does not support the <code>ask folder</code> or
			<code>ask directory</code> forms, or the <code>at</code> parameter.
		</p>
	</compatibility>
	<see-also>
		cm:answer, fn:hash
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">create</name>
	<syntax>
		<syn>
			create <mv>object</mv>
		</syn>
		<syn>
			create <opt>a</opt> new <mv>objectType</mv>
		</syn>
		<p>
			<mv>Object</mv> yields the descriptor of the object to be created.
			<mv>ObjectType</mv> is the name of an object type.
		</p>
	</syntax>
	<examples>
		<scr>
			create folder "My Files"
		</scr>
		<scr>
			create file "MyTemp"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command creates an object that did not previously exist.
			The object is created to match the given descriptor if possible.
			The newly-created object is placed in the local variable
			<code>it</code>.
		</p>
	</description>
	<compatibility>
		<p>
			HyperTalk only supports the creation of two kinds of objects,
			<code>menu</code>s and <code>stack</code>s. HyperTalk does not
			support the <code>new</code> or <code>a new</code> forms, and
			does not put the newly-created object into <code>it</code>.
		</p>
	</compatibility>
	<see-also>
		cm:delete
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">delete</name>
	<syntax>
		<syn>
			delete <mv>object</mv>
		</syn>
		<p>
			<code>Object</code> yields the descriptor of the object
			to be deleted.
		</p>
	</syntax>
	<examples>
		<scr>
			delete line 1 of steve
		</scr>
		<scr>
			delete char 1 to 5 of line 4 of bill
		</scr>
		<scr>
			delete file "MyTemp"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command deletes an object
			or removes a chunk from a container.
		</p>
	</description>
	<scripts>
		<p>
			The following example finds and deletes a name from a
			line-delimited list of names:
		</p>
		<scr>
			on zapaName
			  put "Maller\nCalhoun\nWinkler" into list
			  ask "Delete which name from the list?" with empty
			  repeat with count = the number of lines in list ¬
			      down to 1
			    if it is line count of list then ¬
			    delete line count of list
			  end repeat
			  put list
			end zapaName
		</scr>
	</scripts>
	<notes>
		<p>
			Using the <me/> command to delete a chunk is not the same
			as using <code>put empty into</code> with the same chunk.
			For example, if you delete a line with a statement like:
		</p>
		<scr>
			delete line 4 of myText
		</scr>
		<p>
			you delete the line break as well as the text; what was
			previously the fifth line becomes the fourth. The following
			statement leaves the line break in line 4:
		</p>
		<scr>
			put empty into line 4 of myText
		</scr>
		<p>
			HyperTalk only supports the deletion of chunks,
			<code>menu</code>s, <code>menuItem</code>s,
			and <code>part</code>s (<code>button</code>s
			and <code>field</code>s).
		</p>
	</notes>
	<see-also>
		cm:create, cm:put
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">divide</name>
	<syntax>
		<syn>
			divide <mv>container</mv> by <mv>number</mv>
			<opt>rounding <mv>roundingMethod</mv></opt>
		</syn>
		<p>
			<mv>Number</mv> yields an <a>dt:integer</a>, a <a>dt:number</a>,
			or a <a>dt:complex</a>. <mv>Container</mv> yields a container
			containing an <a>dt:integer</a>, a <a>dt:number</a>, or a
			<a>dt:complex</a>. <mv>RoundingMethod</mv> is <kwd>up</kwd>,
			<kwd>down</kwd>, or <kwd>to</kwd>, <kwd>toward</kwd>, or
			<kwd>towards</kwd> <kwd>zero</kwd>, <kwd>infinity</kwd>,
			<kwd>nearest</kwd>, <kwd>even</kwd>, <kwd>ceiling</kwd>, or
			<kwd>floor</kwd>.
		</p>
	</syntax>
	<examples>
		<scr>
			divide total by 3
		</scr>
		<scr>
			divide line 3 of steve by 10
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command divides the value of <mv>container</mv>
			by the value of <mv>number</mv> and leaves the result in
			<mv>container</mv>. The value in the container must be an
			<a>dt:integer</a>, a <a>dt:number</a>, or a <a>dt:complex</a>
			and is replaced with the new value.
		</p>
		<p>
			If a <mv>roundingMethod</mv> is given, the result is rounded
			to an integer. The following table shows the correspondences
			among the various <mv>roundingMethod</mv>s, rounding functions,
			and division operators:
		</p>
		<table>
			<tr>
				<th><code>rounding</code> parameter</th>
				<th>function</th>
				<th>operator</th>
				<th><code>java.math.RoundingMode</code></th>
			</tr>
			<tr>
				<td><code>to ceiling</code></td>
				<td><a>fn:ceil</a></td>
				<td></td>
				<td><code>CEILING</code></td>
			</tr>
			<tr>
				<td><code>to floor</code></td>
				<td><a>fn:floor</a></td>
				<td><a>op:div</a> / <a>op:mod</a></td>
				<td><code>FLOOR</code></td>
			</tr>
			<tr>
				<td><code>up</code> / <code>to infinity</code></td>
				<td><a>fn:aug</a></td>
				<td></td>
				<td><code>UP</code></td>
			</tr>
			<tr>
				<td><code>down</code> / <code>to zero</code></td>
				<td><a>fn:trunc</a></td>
				<td><a>op:quot</a> / <a>op:rem</a></td>
				<td><code>DOWN</code></td>
			</tr>
			<tr>
				<td><code>to nearest</code></td>
				<td><a>fn:round</a></td>
				<td></td>
				<td><code>HALF_UP</code></td>
			</tr>
			<tr>
				<td><code>to even</code></td>
				<td><a>fn:rint</a></td>
				<td></td>
				<td><code>HALF_EVEN</code></td>
			</tr>
		</table>
		<p>
			See the <a>fn:ceil</a>, <a>fn:floor</a>, <a>fn:aug</a>,
			<a>fn:trunc</a>, <a>fn:round</a>, and <a>fn:rint</a> functions
			for descriptions of how these rounding methods work.
		</p>
	</description>
	<scripts>
		<p>
			The following example prints the percentage represented by 
			a fraction of two numbers passed in as parameters:
		</p>
		<scr>
			on percent steve, bill
			  divide steve by bill
			  put trunc(steve * 100) &amp; "%"
			end percent
		</scr>
	</scripts>
	<compatibility>
		<p>
			HyperTalk does not support the <kwd>rounding</kwd> keyword.
		</p>
	</compatibility>
	<see-also>
		cm:add, cm:subtract, cm:multiply, cm:modulo,
		op:/, op:div, op:quot
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">get</name>
	<syntax>
		<syn>
			get <mv>expression</mv>
		</syn>
		<p>
			<mv>Expression</mv> yields any value.
		</p>
	</syntax>
	<examples>
		<scr>
			get the short name of file 1
		</scr>
		<scr>
			get 2+3
		</scr>
		<scr>
			get the date
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command puts the value of any expression into the
			local variable <code>it</code>. That is, <me/> <mv>expression</mv>
			is the same as <a>cm:put</a> <mv>expression</mv> <a>kw:into</a>
			<code>it</code>.
		</p>
	</description>
</command>

<command>
	<name dialects="xn,oxn" modules="oxns">let</name>
	<syntax>
		<syn>
			let <mv>container</mv> = <mv>expression</mv>
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> command copies the given value into <mv>container</mv>.
		</p>
	</description>
	<notes>
		<p>
			If the specified <mv>container</mv> is a variable name
			but the variable has not been created yet, a new local
			variable is created with that name.
		</p>
	</notes>
	<see-also>
		cm:put
	</see-also>
</command>

<command>
	<name dialects="xn,oxn" modules="oxns">modulo</name>
	<syntax>
		<syn>
			modulo <mv>container</mv> by <mv>number</mv>
			<opt>rounding <mv>roundingMethod</mv></opt>
		</syn>
		<p>
			<mv>Number</mv> yields an <a>dt:integer</a>, a <a>dt:number</a>,
			or a <a>dt:complex</a>. <mv>Container</mv> yields a container
			containing an <a>dt:integer</a>, a <a>dt:number</a>, or a
			<a>dt:complex</a>. <mv>RoundingMethod</mv> is <kwd>up</kwd>,
			<kwd>down</kwd>, or <kwd>to</kwd>, <kwd>toward</kwd>, or
			<kwd>towards</kwd> <kwd>zero</kwd>, <kwd>infinity</kwd>,
			<kwd>nearest</kwd>, <kwd>even</kwd>, <kwd>ceiling</kwd>, or
			<kwd>floor</kwd>.
		</p>
	</syntax>
	<examples>
		<scr>
			modulo steve by 17
		</scr>
		<scr>
			modulo line 13 of bill by 100
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command divides the value of <mv>container</mv>
			by the value of <mv>number</mv> and leaves the remainder
			of the division in <mv>container</mv>. The value in the
			container must be an <a>dt:integer</a>, a <a>dt:number</a>,
			or a <a>dt:complex</a> and is replaced with the new value.
		</p>
	</description>
	<notes>
		<p>
			The remainder is calculated as follows:
		</p>
		<p>
			<mv>remainder</mv> = <mv>container</mv> - <mv>number</mv> *
			<mv>roundingFunction</mv> ( <mv>container</mv> / <mv>number</mv> )
		</p>
		<p>
			where <mv>roundingFunction</mv> is the function listed
			in the table below.
		</p>
		<p>
			If no <mv>roundingMethod</mv> is specified,
			<code>to floor</code> is assumed.
		</p>
		<p>
			The following table shows the correspondences among the
			various <mv>roundingMethod</mv>s, rounding functions,
			and division operators:
		</p>
		<table>
			<tr>
				<th><code>rounding</code> parameter</th>
				<th>function</th>
				<th>operator</th>
				<th><code>java.math.RoundingMode</code></th>
			</tr>
			<tr>
				<td><code>to ceiling</code></td>
				<td><a>fn:ceil</a></td>
				<td></td>
				<td><code>CEILING</code></td>
			</tr>
			<tr>
				<td><code>to floor</code></td>
				<td><a>fn:floor</a></td>
				<td><a>op:div</a> / <a>op:mod</a></td>
				<td><code>FLOOR</code></td>
			</tr>
			<tr>
				<td><code>up</code> / <code>to infinity</code></td>
				<td><a>fn:aug</a></td>
				<td></td>
				<td><code>UP</code></td>
			</tr>
			<tr>
				<td><code>down</code> / <code>to zero</code></td>
				<td><a>fn:trunc</a></td>
				<td><a>op:quot</a> / <a>op:rem</a></td>
				<td><code>DOWN</code></td>
			</tr>
			<tr>
				<td><code>to nearest</code></td>
				<td><a>fn:round</a></td>
				<td></td>
				<td><code>HALF_UP</code></td>
			</tr>
			<tr>
				<td><code>to even</code></td>
				<td><a>fn:rint</a></td>
				<td></td>
				<td><code>HALF_EVEN</code></td>
			</tr>
		</table>
		<p>
			See the <a>fn:ceil</a>, <a>fn:floor</a>, <a>fn:aug</a>,
			<a>fn:trunc</a>, <a>fn:round</a>, and <a>fn:rint</a> functions
			for descriptions of how these rounding methods work.
		</p>
	</notes>
	<see-also>
		cm:add, cm:subtract, cm:multiply, cm:divide,
		op:%, op:mod, op:rem
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">multiply</name>
	<syntax>
		<syn>
			multiply <mv>container</mv> by <mv>number</mv>
		</syn>
		<p>
			<mv>Number</mv> yields an <a>dt:integer</a>, a <a>dt:number</a>,
			or a <a>dt:complex</a>. <mv>Container</mv> yields a container
			containing an <a>dt:integer</a>, a <a>dt:number</a>, or a
			<a>dt:complex</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			multiply Subtotal by Tax
		</scr>
		<scr>
			multiply steve by bill
		</scr>
		<scr>
			multiply line 3 of andy by 25
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command multiplies the value of <mv>container</mv>
			by the value of <mv>number</mv> and leaves the result in
			<mv>container</mv>. The value in the container must be an
			<a>dt:integer</a>, a <a>dt:number</a>, or a <a>dt:complex</a>
			and is replaced with the new value.
		</p>
	</description>
	<scripts>
		<p>
			The following example adds 6 percent to each item in a list:
		</p>
		<scr>
			on taxMe
			  put "12.45,15.00,150.00,76.95,10.00,14.95,19.87" into taxables
			  repeat with count = 1 to the number of items in taxables
			    multiply item count of taxables by 1.06
			  end repeat
			  put taxables
			end taxMe
		</scr>
	</scripts>
	<see-also>
		cm:add, cm:subtract, cm:divide, cm:modulo,
		op:*, fn:product
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">put</name>
	<syntax>
		<syn>
			put <mv>expression</mv>
			<opt>
				<ch>
					<ci>into</ci>
					<ci>before</ci>
					<ci>after</ci>
				</ch>
				<mv>container</mv>
				<opt>with <mv>propertyName</mv> <mv>propertyValue</mv></opt>
			</opt>
		</syn>
		<p>
			<mv>PropertyName</mv> is the name of a property.
		</p>
	</syntax>
	<examples>
		<scr>
			put "Hello" into steve
		</scr>
		<scr>
			put empty into it
		</scr>
		<scr>
			put it
		</scr>
		<scr>
			put "Tom" into first word of theName
		</scr>
		<scr>
			put "." after first character of last word of bill
		</scr>
		<scr>
			put steve + bill into andy
		</scr>
		<scr>
			put the date into myDate
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command without a <mv>container</mv> specified presents
			the given value to the user in an implementation-defined way.
			OpenXION prints the given value to standard output. HyperCard
			puts the given value into the message box.
		</p>
		<p>
			The <me/> command with a <mv>container</mv> copies the given
			value into <mv>container</mv>. The <a>kw:before</a> and
			<a>kw:after</a> prepositions specify that the given value
			should be inserted before or after the existing contents,
			respectively, instead of completely replacing the existing
			contents. The <kwd>with</kwd> keyword allows you to set a
			property of the new contents.
		</p>
	</description>
	<notes>
		<p>
			If the specified <mv>container</mv> is a variable name
			but the variable has not been created yet, a new local
			variable is created with that name.
		</p>
	</notes>
	<compatibility>
		<p>
			The only property HyperTalk supports for the <kwd>with</kwd>
			keyword is <code>menuMessage</code>.
		</p>
	</compatibility>
	<see-also>
		cm:let, kw:into, kw:before, kw:after
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">set</name>
	<syntax>
		<syn>
			set <opt>the</opt> <mv>propertyName</mv>
			<opt><ch><ci>of</ci><ci>in</ci></ch> <mv>object</mv></opt>
			to <mv>propertyValue</mv>
		</syn>
		<p>
			<mv>PropertyName</mv> is the name of a property.
		</p>
	</syntax>
	<examples>
		<scr>
			set the name of file "Untitled" to "MyFile"
		</scr>
		<scr>
			set itemDelimiter to ":"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command changes the specified property.
			If the object to which the property belongs is not
			specified, the <a>dt:interpreter</a> is assumed.
		</p>
	</description>
	<notes>
		<p>
			Some properties cannot be changed with the <me/> command.
			These exceptions are noted in the documentation for the
			properties themselves.
		</p>
	</notes>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">subtract</name>
	<syntax>
		<syn>
			subtract <mv>number</mv> from <mv>container</mv>
		</syn>
		<p>
			<mv>Number</mv> yields an <a>dt:integer</a>, a <a>dt:number</a>,
			or a <a>dt:complex</a>. <mv>Container</mv> yields a container
			containing an <a>dt:integer</a>, a <a>dt:number</a>, or a
			<a>dt:complex</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			subtract 2 from it
		</scr>
		<scr>
			subtract steve from bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command subtracts the value of <mv>number</mv>
			from the value of <mv>container</mv> and leaves the result in
			<mv>container</mv>. The value in the container must be an
			<a>dt:integer</a>, a <a>dt:number</a>, or a <a>dt:complex</a>
			and is replaced with the new value.
		</p>
	</description>
	<see-also>
		cm:add, cm:multiply, cm:divide, cm:modulo, op:-
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">beep</name>
	<syntax>
		<syn>
			beep <opt><mv>number</mv> <opt>times</opt></opt>
		</syn>
		<p>
			<mv>Number</mv> yields a non-negative <a>dt:integer</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			beep 5
		</scr>
		<scr>
			beep twice
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command causes the computer to
			beep the specified number of times.
			If no number is given, the computer beeps once.
		</p>
	</description>
	<compatibility>
		<p>
			HyperTalk does not support the <kwd>times</kwd> keyword.
			It can be left off without changing the command's behavior.
		</p>
	</compatibility>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">close</name>
	<syntax>
		<syn>
			close <mv>object</mv>
		</syn>
		<syn>
			close <mv>applicationPath</mv>
		</syn>
		<syn>
			close <mv>documentPath</mv>
			<ch><ci>with</ci><ci>in</ci></ch> <mv>applicationPath</mv>
		</syn>
		<p>
			<mv>Object</mv> yields an object with an appropriate I/O manager.
			<mv>DocumentPath</mv> and <mv>applicationPath</mv> yield file paths
			to a document file and an application file, respectively.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> command, when given an object with an appropriate
			I/O manager (e.g., a <a>dt:file</a> or <a>dt:URL</a>),
			closes an object previously opened with the <a>cm:open</a>
			command.
		</p>
		<p>
			If the parameter to the <me/> command does not have an
			appropriate I/O manager or is not an object, or if the
			<kwd>with</kwd> or <kwd>in</kwd> parameter is given, the
			<me/> command closes an open application or document.
			OpenXION currently only supports this on Mac OS X.
		</p>
	</description>
	<security>
		<p>
			To close an open application or document, OpenXION's security
			settings must allow the <code>FILE_LAUNCH</code> security key.
			To close an object with an I/O manager, any security keys
			required are determined by the I/O manager; see the documentation
			for the I/O manager itself (e.g., <a>mg:file</a> or <a>mg:URL</a>).
			If the required security key is denied, a script error will be
			triggered.
		</p>
	</security>
	<see-also>
		cm:open, cm:read, cm:write, cm:truncate
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">convert</name>
	<syntax>
		<syn>
			convert <mv>container</mv>
			<opt>
				from <mv>format</mv>
				<opt>and <mv>format</mv></opt>
			</opt>
			to <mv>format</mv>
			<opt>and <mv>format</mv></opt>
		</syn>
		<p>
			<mv>Format</mv> is one of the following:
			<kwd>date</kwd>, <kwd>short date</kwd>, <kwd>abbreviated date</kwd>,
			<kwd>long date</kwd>, <kwd>English date</kwd>, <kwd>short time</kwd>,
			<kwd>abbreviated time</kwd>, <kwd>long time</kwd>, <kwd>English time</kwd>,
			<kwd>seconds</kwd>, or <kwd>dateItems</kwd>.
		</p>
	</syntax>
	<examples>
		<scr>
			convert line 1 of steve from date to dateItems
		</scr>
		<scr>
			convert bill from date and time to dateItems
		</scr>
		<scr>
			convert andy to seconds
		</scr>
		<scr>
			convert first line of steve to long date and short time
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command gets a date or time and converts it from a
			particular format, if specified, to a particular format. This
			command works with either the local date format or the U.S.
			date format.
		</p>
		<p>
			If the first parameter to the <me/> command is a container,
			the converted date or time is placed in that container. If the
			first parameter is not a container, the converted date or time
			is placed in the local variable <code>it</code>.
		</p>
		<p>
			A script that needs to work with dates and times should convert
			them to the <kwd>seconds</kwd> or <kwd>dateItems</kwd> format
			before working on them. This avoids problems that may occur when
			running the script in a different locale. The <kwd>seconds</kwd>
			and <kwd>dateItems</kwd> formats are the only ones guaranteed
			to be recognized in any locale.
		</p>
	</description>
	<scripts>
		<p>
			The following example prints tomorrow's date in the short format
			regardless of the current locale:
		</p>
		<scr>
			on printTomorrow
			  get the date
			  convert it to dateItems
			  add 1 to item 3 of it
			  convert it to short date
			  put it
			end printTomorrow
		</scr>
	</scripts>
	<see-also>
		dt:date, fn:date, fn:time, fn:seconds, fn:dateItems
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">open</name>
	<syntax>
		<syn>
			open <mv>object</mv> <opt>as <mv>method</mv></opt>
		</syn>
		<syn>
			open <mv>applicationPath</mv>
		</syn>
		<syn>
			open <mv>documentPath</mv>
			<ch><ci>with</ci><ci>in</ci></ch> <mv>applicationPath</mv>
		</syn>
		<p>
			<mv>Object</mv> yields an object with an appropriate I/O manager.
			<mv>Method</mv> yields the name of an I/O method.
			<mv>DocumentPath</mv> and <mv>applicationPath</mv> yield file
			paths to a document file and an application file, respectively.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> command, when given an object with an appropriate
			I/O manager (e.g., a <a>dt:file</a> or <a>dt:URL</a>), opens
			an object for reading or writing. If the object is a <a>dt:file</a>
			and the file does not exist, the <a>mg:file</a> I/O manager
			creates it.
		</p>
		<p>
			If the parameter to the <me/> command does not have an appropriate
			I/O manager or is not an object, or if the <kwd>with</kwd> or
			<kwd>in</kwd> parameter is given, the <me/> command launches an
			application or document. The <me/> command without a <kwd>with</kwd>
			or <kwd>in</kwd> parameter first looks for applications, then
			documents. The <me/> command with a <kwd>with</kwd> or <kwd>in</kwd>
			parameter opens the file <mv>documentPath</mv> with the application
			<mv>applicationPath</mv> regardless of what application would
			normally open the file. In OpenXION, the locations searched for
			applications and documents are determined by the
			<a>pr:applicationPaths</a> and <a>pr:documentPaths</a> properties,
			respectively. In HyperTalk, the locations searched for applications
			and documents are determined by the global variables
			<code>Applications</code> and <code>Documents</code>.
		</p>
	</description>
	<scripts>
		<p>
			The following example opens a file, reads a line of data from it,
			then closes the file:
		</p>
		<scr>
			on printALine
			  open file "MyFile"
			  read from file "MyFile"
			  put it
			  close file "MyFile"
			end printALine
		</scr>
		<p>
			The following example opens a URL with the user's default
			web browser:
		</p>
		<scr>
			on myLink
			  open url "http://www.openxion.org"
			end myLink
		</scr>
		<p>
			The following example opens a URL and reads its contents:
		</p>
		<scr>
			on readURL
			  open URL "http://www.openxion.org/" as "text"
			  read from URL "http://www.openxion.org/" until eof
			  put it
			  close URL "http://www.openxion.org/"
			end readURL
		</scr>
		<p>
			The following example queries the user for a document and
			application before executing the <me/> command:
		</p>
		<scr>
			on openSomething
			  answer file "Select a document:"
			  if it is not empty then
			    put it into doc
			    answer file "Select an application:"
			    if it is not empty then open doc with it
			  end if
			end openSomething
		</scr>
	</scripts>
	<notes>
		<p>
			If the <me/> <mv>applicationPath</mv> or <me/> <mv>documentPath</mv>
			<kwd>with</kwd> <mv>applicationPath</mv> form is used and the
			specified application or document cannot be found, the interpreter
			must present a prompt to the user asking them to select the
			appropriate file. To avoid this prompt, you can use the
			<a>fn:appPath</a>, <a>fn:appFile</a>, <a>fn:docPath</a>,
			<a>fn:docFile</a>, <a>fn:appOrDocPath</a>, or <a>fn:appOrDocFile</a>
			functions. If the function returns <a>cn:empty</a>, then the
			application or document cannot be found.
		</p>
	</notes>
	<security>
		<p>
			To launch applications and documents, OpenXION's security
			settings must allow the <code>FILE_LAUNCH</code> security key.
			To open an object with an I/O manager, any security keys required
			are determined by the I/O manager (e.g., <a>mg:file</a> or
			<a>mg:URL</a>); see the documentation for the I/O manager itself.
			If the required security key is denied, a script error will be
			triggered.
		</p>
	</security>
	<compatibility>
		<p>
			HyperTalk does not support the <kwd>as</kwd> parameter
			or reading from or writing to URLs.
		</p>
	</compatibility>
	<see-also>
		cm:read, cm:write, cm:truncate, cm:close,
		mg:file, mg:URL, mt:text, mt:binary
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">read</name>
	<syntax>
		<syn>
			read from <mv>object</mv>
			<opt>at <mv>offset</mv></opt>
			<opt>for <mv>length</mv></opt>
			<opt>until <mv>data</mv></opt>
		</syn>
		<p>
			<mv>Object</mv> yields an object with an appropriate I/O manager.
			<mv>Offset</mv> yields an <a>dt:integer</a> identifying the
			position where reading starts.
			<mv>Length</mv> yields a non-negative <a>dt:integer</a>
			identifying the length of data to be read.
			<mv>Data</mv> yields the last data to be read.
		</p>
	</syntax>
	<examples>
		<scr>
			read from file "MyData" at 4 for 20
		</scr>
		<scr>
			read from file "MyData" until tab
		</scr>
		<scr>
			read from file "MyData" at -20 until eof
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command reads from the specified object, which must be
			opened already with the <a>cm:open</a> command, into the local
			variable <code>it</code>. Reading starts at the specified offset
			or, if no offset is specified, from where the last <a>cm:read</a>
			or <a>cm:write</a> left off. A negative offset indicates an offset
			from the end of the file, while a positive offset indicates an
			offset from the beginning of the file. Reading continues until
			either the specified data is read, or the specified length of data
			is read, whichever occurs first. If neither is specified, reading
			continues until the end of a line (if the <a>mt:text</a> I/O method
			is used) or the end of file (if the <a>mt:binary</a> I/O method
			is used).
		</p>
	</description>
	<compatibility>
		<p>
			HyperTalk uses only the first character of <mv>data</mv>
			to find a stopping point. OpenXION uses the whole <mv>data</mv>.
		</p>
		<p>
			HyperTalk converts null characters to spaces when reading.
			OpenXION refuses to do such an unspeakable thing.
		</p>
	</compatibility>
	<see-also>
		cm:open, cm:write, cm:truncate, cm:close,
		mg:file, mg:URL, mt:text, mt:binary
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">sort</name>
	<syntax>
		<syn>
			sort <mv>container</mv>
			<opt><mv>direction</mv></opt>
			<opt><mv>sortType</mv></opt>
			<opt>by <mv>expression</mv></opt>
		</syn>
		<p>
			<mv>Direction</mv> is <kwd>ascending</kwd> or <kwd>descending</kwd>.
			The default is <kwd>ascending</kwd>. <mv>SortType</mv> is
			<kwd>text</kwd>, <kwd>numeric</kwd>, <kwd>dateTime</kwd>, or
			<kwd>international</kwd>. The default is <kwd>text</kwd>.
			<mv>Expression</mv> is any expression.
		</p>
	</syntax>
	<examples>
		<scr>
			sort lines of steve by last word of each
		</scr>
		<scr>
			sort items of bill descending numeric by word 2 of each
		</scr>
		<scr>
			sort lines of steve ascending
		</scr>
		<scr>
			sort items of bill dateTime
		</scr>
		<scr>
			sort andy
		</scr>
		<scr>
			sort it numeric
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command will sort chunks of a <a>dt:string</a>,
			elements of a <a>dt:list</a>, bytes of a <a>dt:binary</a>,
			or child objects of an object that supports sorting.
		</p>
		<p>
			The <kwd>ascending</kwd> direction sorts in normal,
			ascending order, while the <kwd>descending</kwd> direction
			sorts in reverse, descending order.
		</p>
		<p>
			The <kwd>text</kwd> sort type sorts by the Unicode code points
			of the characters in a string. The <kwd>international</kwd>
			sort type sorts using the current locale's collation rules.
			The <kwd>numeric</kwd> sort type sorts strings that look like
			numbers as numbers rather than strings. The <kwd>dateTime</kwd>
			sort type sorts strings that look like dates as dates rather
			than strings.
		</p>
		<p>
			The <kwd>by</kwd> keyword sorts based on the values of the
			<mv>expression</mv>. The item being sorted is represented by
			the variable <code>each</code>.
		</p>
	</description>
</command>

<command>
	<name dialects="xn,oxn" modules="oxns">truncate</name>
	<syntax>
		<syn>
			truncate <mv>object</mv>
			<opt>at <mv>offset</mv></opt>
		</syn>
		<p>
			<mv>Object</mv> yields an object with an appropriate I/O manager.
			<mv>Offset</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> command truncates the specified object, which must be
			opened already with the <a>cm:open</a> command. In other words,
			any data after the specified offset is deleted. If no offset is
			specified, the object will be truncated where the last <a>cm:read</a>
			or <a>cm:write</a> left off.
		</p>
	</description>
	<notes>
		<p>
			If you <a>cm:open</a> a file that already exists and
			<a>cm:write</a> some data to it, the file may still contain
			old data that did not get overwritten. The <a>cm:truncate</a>
			command allows you to remove the contents of a file
			before writing to it.
		</p>
	</notes>
	<see-also>
		cm:open, cm:read, cm:write, cm:close,
		mg:file, mg:URL, mt:text, mt:binary
	</see-also>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">wait</name>
	<syntax>
		<syn>
			wait <ch><ci>until</ci><ci>while</ci></ch> <mv>condition</mv>
		</syn>
		<syn>
			wait <opt>for</opt> <mv>number</mv> <opt><mv>unit</mv></opt>
		</syn>
		<p>
			<mv>Condition</mv> is an expression that always yields
			<a>cn:true</a> or <a>cn:false</a>. <mv>Number</mv> yields an
			<a>dt:integer</a> or a <a>dt:number</a>. <mv>Unit</mv> is one
			of the following: <kwd>nanoseconds</kwd>, <kwd>microseconds</kwd>,
			<kwd>milliseconds</kwd>, <kwd>seconds</kwd>, <kwd>ticks</kwd>,
			<kwd>minutes</kwd>, <kwd>hours</kwd>, <kwd>nanosecond</kwd>,
			<kwd>microsecond</kwd>, <kwd>millisecond</kwd>, <kwd>second</kwd>,
			<kwd>tick</kwd>, <kwd>minute</kwd>, or <kwd>hour</kwd>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> command causes the interpreter to pause before executing
			the rest of the script. The <code>wait until</code> form will pause
			until the specified condition becomes <a>cn:true</a>. The
			<code>wait while</code> form will pause until the specified
			condition becomes <a>cn:false</a>. The <code>wait for</code> form
			will pause for the specified length of time.
		</p>
		<p>
			If no <mv>unit</mv> is specified, the <me/> command assumes
			<kwd>ticks</kwd>, defined as sixtieths of a second.
		</p>
	</description>
	<notes>
		<p>
			The <me/> command causes a busy wait—the interpreter keeps running
			in an infinite loop, checking the specified condition or the elapsed
			time since the command began executing. Although you can specify a
			length of time as short as a nanosecond, there is absolutely no
			guarantee on how long the wait will actually be. The <me/> command
			<b>cannot</b> be used for thread synchronization or real-time
			applications.
		</p>
	</notes>
	<compatibility>
		<p>
			HyperTalk only supports <kwd>seconds</kwd>, <kwd>ticks</kwd>,
			<kwd>second</kwd>, and <kwd>tick</kwd> for the unit.
		</p>
	</compatibility>
</command>

<command>
	<name dialects="xn,oxn,hyp" modules="oxns">write</name>
	<syntax>
		<syn>
			write <mv>data</mv> to <mv>object</mv>
			<opt>at <mv>offset</mv></opt>
		</syn>
		<p>
			<mv>Object</mv> yields an object with an appropriate I/O manager.
			<mv>Offset</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			write address to file "MyFile"
		</scr>
		<scr>
			write "first line" &amp; newline &amp; "second line" to file "TwoLiner"
		</scr>
		<scr>
			write steve to file "MyFile" at -15
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command copies the specified data to the specified
			object, which must be opened already with the <a>cm:open</a>
			command. Writing starts at the specified offset or, if no offset
			is specified, from where the last <a>cm:read</a> or <a>cm:write</a>
			left off. A negative offset indicates an offset from the end of
			the file, while a positive offset indicates an offset from the
			beginning of the file.
		</p>
	</description>
	<compatibility>
		<p>
			In HyperTalk, in OpenXION 1.2 or later, and according to the
			XION Scripting Language Standard, if you write to a file without
			specifying an offset and without having previously read from,
			written to, or truncated the file, the file will automatically
			get truncated before the data is written. Otherwise, the file
			will not be automatically truncated and any data that was not
			overwritten will remain.
		</p>
		<p>
			OpenXION 1.0 and 1.1 did not automatically truncate files,
			requiring the use of the <a>cm:truncate</a> command before
			writing to files. This was a bug, not a feature, and was fixed
			in OpenXION 1.2.
		</p>
	</compatibility>
	<see-also>
		cm:open, cm:read, cm:truncate, cm:close,
		mg:file, mg:URL, mt:text, mt:binary
	</see-also>
</command>

<command>
	<name dialects="oxn&ge;1.2" modules="oxne&ge;1.2">sql</name>
	<syntax>
		<syn>
			sql connect to <mv>url</mv>
			<opt>with driver <mv>driver</mv></opt>
			<opt>with username <mv>username</mv></opt>
			<opt>with password <mv>password</mv></opt>
		</syn>
		<syn>
			sql disconnect <opt>from <mv>url</mv></opt>
		</syn>
		<syn>
			sql prepare <opt>statement</opt> <mv>query</mv>
			<opt>using connection <mv>url</mv></opt>
		</syn>
		<syn>
			sql prepare set <mv>parameter</mv> to <mv>value</mv>
			<opt>using connection <mv>url</mv></opt>
		</syn>
		<syn>
			sql prepare execute
			<opt>using connection <mv>url</mv></opt>
		</syn>
		<syn>
			sql execute prepared
			<opt>using connection <mv>url</mv></opt>
		</syn>
		<syn>
			sql execute <mv>query</mv>
			<opt>using connection <mv>url</mv></opt>
		</syn>
		<p>
			<mv>URL</mv> yields the database's URL as a <a>dt:string</a>.
			<mv>Driver</mv> yields the JDBC driver's class name as a <a>dt:string</a>.
			<mv>Username</mv> and <mv>password</mv> yield the login name and
			password used to connect to the database as <a>dt:string</a>s.
			<mv>Query</mv> yields a SQL query as a <a>dt:string</a>.
			<mv>Parameter</mv> yields the index into the prepared statement's
			parameters, starting from 1, as an <a>dt:integer</a>.
			<mv>Value</mv> yields the parameter's value as a <a>dt:string</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			sql connect to "mysql://localhost/studentdb" with driver "com.mysql.jdbc.Driver" with username "admin" with password "woot"
		</scr>
		<scr>
			sql execute "select * from students" using connection "mysql://localhost/studentdb"
		</scr>
		<scr>
			sql prepare "update students set name=? where id=?" using connection "mysql://localhost/studentdb"
		</scr>
		<scr>
			sql prepare set 1 to "Little Bobby Tables"
		</scr>
		<scr>
			sql prepare set 2 to 16777216
		</scr>
		<scr>
			sql execute prepared
		</scr>
		<scr>
			sql disconnect from "mysql://localhost/studentdb"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command connects to, disconnects from, and submits
			queries to a database.
		</p>
		<p>
			The <code>sql connect</code> form opens a connection to a database.
			If a connection has already been opened, the <mv>driver</mv> cannot
			be found or loaded, the database <mv>url</mv> is invalid, or the
			specified <mv>username</mv> and <mv>password</mv> are invalid, a
			script error is triggered.
		</p>
		<p>
			The <code>sql disconnect</code> form closes an open connection
			to a database. If no <mv>url</mv> is specified, the last
			successfully-used <mv>url</mv> is used. If there is no open
			connection to the database, a script error is triggered.
		</p>
		<p>
			The <code>sql prepare statement</code> form creates a prepared
			statement for the specified database. Parameters in the prepared
			statement are indicated by question marks in the query string.
			If no <mv>url</mv> is specified, the last successfully-used
			<mv>url</mv> is used. If there is no open connection to the
			database, a script error is triggered.
		</p>
		<p>
			The <code>sql prepare set</code> form sets the value of a parameter
			in the last prepared statement created for the specified database.
			The first parameter in the prepared statement is parameter 1.
			If no <mv>url</mv> is specified, the last successfully-used
			<mv>url</mv> is used. If there is no open connection to the
			database, no prepared statement has been created for the specified
			database, or the specified parameter index is invalid, a script
			error is triggered.
		</p>
		<p>
			The <code>sql prepare execute</code> and <code>sql execute
			prepared</code> forms execute the prepared statement. The number
			of rows affected or returned by the query is put into the
			<a>fn:result</a>. If any rows are returned, they are put into
			<code>it</code>. Rows are delimited by the <a>pr:rowDelimiter</a>
			and columns are delimited by the <a>pr:columnDelimiter</a>.
			If no <mv>url</mv> is specified, the last successfully-used
			<mv>url</mv> is used. If there is no open connection to the
			database, the query contains a syntax error, or the query cannot
			be executed successfully, a script error is triggered.
		</p>
		<p>
			The <code>sql execute</code> form executes a query immediately,
			without requiring the creation of a prepared statement. The number
			of rows affected or returned by the query is put into the
			<a>fn:result</a>. If any rows are returned, they are put into
			<code>it</code>. Rows are delimited by the <a>pr:rowDelimiter</a>
			and columns are delimited by the <a>pr:columnDelimiter</a>.
			If no <mv>url</mv> is specified, the last successfully-used
			<mv>url</mv> is used. If there is no open connection to the
			database, the query contains a syntax error, or the query cannot
			be executed successfully, a script error is triggered.
		</p>
	</description>
	<scripts>
		<p>
			The following scripts demonstrate two possible ways to list
			the contents of a table:
		</p>
		<scr>
			sql execute "select * from students"
			repeat foreach x in the rows of it
			  put replaceall(x, the columndelimiter, tab)
			end repeat
		</scr>
		<scr>
			set the rowDelimiter to newline
			set the columnDelimiter to tab
			sql execute "select * from students"
			put it
		</scr>
	</scripts>
	<notes>
		<p>
			It is also possible to execute a query without quotes
			by leaving out the <kwd>execute</kwd> keyword, e.g.:
		</p>
		<scr>
			sql select * from students where firstname = "Steve"
		</scr>
		<p>
			However, this is prone to error and is not recommended.
			(If you're curious, among the reasons are:
			SQL and XION use different lexicographical rules, so it's possible
			for the query to confuse OpenXION or the database or both;
			it is impossible to use any XION expressions in such a statement,
			so you are limited to static queries;
			and this feature may change in future versions of OpenXION.)
		</p>
	</notes>
</command>

<command>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">dial</name>
	<syntax>
		<syn>
			dial <mv>number</mv>
			<opt>with modem <opt><mv>command</mv></opt></opt>
		</syn>
		<p>
			<mv>Number</mv> and <mv>command</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			dial steve -- steve is a variable containing a phone number
		</scr>
		<scr>
			dial "555-1212"
		</scr>
		<scr>
			dial "555-1212" with modem
		</scr>
		<scr>
			dial "555-1212" with modem "ATS0=0S7=1DT"
		</scr>
	</examples>
	<description>
		<p>
			Without the <code>with modem</code> keyword, the <me/> command
			plays the dial tones for the given phone <mv>number</mv>. With
			some land-line telephones, you can hold the handset against your
			computer's speaker while the <me/> command is executing to dial
			the given phone <mv>number</mv>. The volume of the generated
			tones is controlled by the <a>pr:dialingVolume</a> property.
		</p>
		<p>
			With the <code>with modem</code> keyword, the <me/> command will
			dial the given phone <mv>number</mv> using a modem attached to a
			communications port. If no modem <mv>command</mv> is specified,
			the default is <code>"ATDT"</code>. The communications port used
			is determined by the <a>pr:dialingPort</a> property. There is a
			one-second delay between opening the communications port and
			issuing the <mv>command</mv>, and a delay between issuing the
			<mv>command</mv> and closing the port determined by the
			<a>pr:dialingTime</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> command is synchronous: it will not return until it
			has finished dialing. (This is different from the <a>cm:play</a>,
			<a>cm:speak</a>, and <a>cm:tone</a> commands, which are
			asynchronous.)
		</p>
		<p>
			OpenXION will use RXTX (<code>gnu.io</code> package) or the Java
			Communications API (<code>javax.comm</code> package) to communicate
			with the modem, whichever is available. If neither package is
			available, <me/> will do nothing but set the <a>fn:result</a>
			to an error message.
		</p>
	</notes>
	<security>
		<p>
			To use the <code>with modem</code> keyword, OpenXION's security
			settings must allow the <code>TELEPHONY</code> security key.
			If the required security key is denied, a script error will be
			triggered.
		</p>
	</security>
	<see-also>
		pr:dialingVolume, pr:dialingTime, pr:dialingPort, fn:serialPorts
	</see-also>
</command>

<command>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">play</name>
	<syntax>
		<syn>
			play <mv>instrument</mv>
			<opt><opt>tempo <mv>tempo</mv></opt> <mv>notes</mv></opt>
		</syn>
		<syn>
			play stop
		</syn>
		<p>
			<mv>Instrument</mv> and <mv>notes</mv> yield <a>dt:string</a>s.
			<mv>Tempo</mv> yields a <a>dt:number</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			play "harpsichord" "ch d e f g a b c5w"
		</scr>
		<scr>
			play "music box" "c4e c dq c f eh"
		</scr>
		<scr>
			play "harpsichord" "c4 a3 f c4 a3 f c4 d c c c"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> command plays the specified sequence of <mv>notes</mv>
			with the specified <mv>instrument</mv> using a MIDI synthesizer
			(in OpenXION) or sampled sounds (in HyperTalk). The <mv>tempo</mv>
			parameter specifies the number of quarter notes per minute;
			the default value is 120.
		</p>
		<p>
			The <me/> command in OpenXION uses an extended version of the
			scripted music notation originally found in HyperTalk. A sequence
			of notes is represented as a <a>dt:string</a> with notes delimited
			by whitespace. Each note has the following format for a regular note:
		</p>
		<syn>
			<mv>noteName</mv>
			<opt><mv>octave</mv></opt>
			<opt><mv>duration</mv></opt>
			<opt><mv>velocity</mv></opt>
			<opt><mv>effect</mv></opt>
		</syn>
		<p>
			or the following format for a rest:
		</p>
		<syn>
			<mv>duration</mv> r
		</syn>
		<p>
			<mv>NoteName</mv> is a letter between <code>A</code> and
			<code>G</code>, which may or may not be followed by any number
			of <code>#</code> symbols, each of which raises the pitch
			a half step, or any number of <code>b</code> symbols, each
			of which lowers the pitch a half step. In OpenXION,
			<mv>noteName</mv> can also be one of the letters <code>M</code>,
			<code>N</code>, or <code>P</code> followed by the MIDI dollar
			value, for which 60 is middle C. <mv>NoteName</mv> is the only
			required part of a note string.
		</p>
		<p>
			<mv>Octave</mv> is an integer specifying which octave the note
			belongs to. If the <mv>octave</mv> is not specified, the last
			<mv>octave</mv> specified is used. The default is 4, the octave
			starting with middle C.
		</p>
		<p>
			(Middle C corresponds to the note string <code>C4</code> or
			<code>B#3</code>. The note one half step below middle C is
			<code>B3</code> or <code>Cb4</code>. 440 Hz corresponds to
			the note string <code>A4</code>.)
		</p>
		<p>
			<mv>Duration</mv> is one of the following letters:
		</p>
		<table>
			<tr>
				<td><code>w</code></td>
				<td>whole note</td>
			</tr>
			<tr>
				<td><code>h</code></td>
				<td>half note</td>
			</tr>
			<tr>
				<td><code>q</code></td>
				<td>quarter note</td>
			</tr>
			<tr>
				<td><code>e</code></td>
				<td>eighth note</td>
			</tr>
			<tr>
				<td><code>s</code></td>
				<td>16th note</td>
			</tr>
			<tr>
				<td><code>t</code></td>
				<td>32nd note</td>
			</tr>
			<tr>
				<td><code>x</code></td>
				<td>64th note</td>
			</tr>
			<tr>
				<td><code>o</code></td>
				<td>128th note</td>
			</tr>
		</table>
		<p>
			which may or may not be followed by any number of <code>.</code>
			symbols, each of which multiplies the duration by 1.5 to create
			a dotted note, or any number of <code>3</code> symbols, each of
			which divides the duration by 3 to create a triplet note.
			(In OpenXION, you can use any digit 2 through 9 to divide the
			duration by that value. Also in OpenXION, <mv>duration</mv> can
			be the letter <code>d</code> followed by the duration in MIDI
			ticks. OpenXION uses 64 ticks per quarter note.) If the
			<mv>duration</mv> is not specified, the last <mv>duration</mv>
			specified is used. The default is <code>q</code>, the duration
			of a quarter note.
		</p>
		<p>
			<mv>Velocity</mv> is an extension provided by OpenXION not found
			in HyperTalk. It may be any of the following strings:
		</p>
		<table>
			<tr>
				<td><code>fff</code></td>
				<td>triple forte (velocity 127)</td>
			</tr>
			<tr>
				<td><code>ff</code></td>
				<td>fortissimo (velocity 112)</td>
			</tr>
			<tr>
				<td><code>f</code></td>
				<td>forte (velocity 96)</td>
			</tr>
			<tr>
				<td><code>mff</code></td>
				<td>(velocity 88)</td>
			</tr>
			<tr>
				<td><code>mf</code></td>
				<td>mezzo forte (velocity 80)</td>
			</tr>
			<tr>
				<td><code>m</code></td>
				<td>(velocity 72)</td>
			</tr>
			<tr>
				<td><code>mp</code></td>
				<td>mezzo piano (velocity 64)</td>
			</tr>
			<tr>
				<td><code>mpp</code></td>
				<td>(velocity 56)</td>
			</tr>
			<tr>
				<td><code>p</code></td>
				<td>piano (velocity 48)</td>
			</tr>
			<tr>
				<td><code>pp</code></td>
				<td>pianissimo (velocity 32)</td>
			</tr>
			<tr>
				<td><code>ppp</code></td>
				<td>triple piano (velocity 16)</td>
			</tr>
		</table>
		<p>
			<mv>Velocity</mv> can also be the letter <code>v</code> followed
			by the velocity of the note from 0 to 127. If the <mv>velocity</mv>
			is not specified, the last <mv>velocity</mv> specified is used.
			The default is <code>fff</code> or 127.
		</p>
		<p>
			<mv>Effect</mv> is another extension provided by OpenXION not found
			in HyperTalk. It is one or more of the following characters:
		</p>
		<table>
			<tr>
				<td><code>,</code></td>
				<td>
					The note is stopped a few MIDI ticks before it normally
					would be, creating a stoccato effect.
				</td>
			</tr>
			<tr>
				<td><code>*</code></td>
				<td>
					The note keeps playing after its duration has passed.
					This can be used to start a fermata. (This overrides
					the effect of any <code>,</code> or any preceding
					<code>!</code>.)
				</td>
			</tr>
			<tr>
				<td><code>!</code></td>
				<td>
					Stops a note previously started by <code>*</code>
					after the duration has passed. This can be used to end
					a fermata. If the note is not already playing, this is
					equivalent to a rest. (This overrides the effect of any
					preceding <code>*</code>.)
				</td>
			</tr>
			<tr>
				<td><code>+</code></td>
				<td>
					Starts the next note at the same time as this note,
					creating a chord.
				</td>
			</tr>
		</table>
		<p>
			If <mv>effect</mv> is not specified, no effects are applied.
		</p>
		<p>
			If the note string contains an <code>r</code>, it is a rest
			and only the duration can be specified.
		</p>
	</description>
	<notes>
		<p>
			The <me/> command is asynchronous: it will return immediately
			while the sound keeps playing in the background. If there is
			already sound playing on the current <a>pr:soundChannel</a>,
			the next sound to be played will be added to a queue. The
			<code>play stop</code> form of the <me/> command will stop
			playing any sound on the current <a>pr:soundChannel</a>. The
			<code>stop sound</code> command will stop all currently-playing
			and pending sounds on all <a>pr:soundChannel</a>s.
		</p>
		<p>
			Early versions of HyperTalk limited the length of the note string
			to 254 characters. OpenXION and later versions of HyperTalk do not
			limit the length of the note string.
		</p>
		<p>
			In HyperTalk, the <me/> command accepted note strings that were
			left unquoted, and this was often done. For example:
		</p>
		<scr>
			play harpsichord c4 a3 f c4 a3 f c4 d c c c
		</scr>
		<p>
			OpenXION will also accept unquoted note strings, but this is
			highly discouraged. You cannot use any special symbols (such as
			<code>#</code>, <code>.</code>, or <code>+</code>) in an unquoted
			note string, and if one of the notes in an unquoted note string
			turns out to also be the name of a constant or variable, the value
			of the constant or the contents of the variable will be played
			instead of the intended note.
		</p>
	</notes>
	<see-also>
		cm:stop, fn:sound, fn:sounds, pr:soundChannel
	</see-also>
</command>

<command>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">speak</name>
	<syntax>
		<syn>
			speak <mv>phrase</mv>
			<opt><ch>
				<ci>with <mv>gender</mv> voice</ci>
				<ci>with voice <mv>voice</mv></ci>
			</ch></opt>
		</syn>
		<p>
			<mv>Phrase</mv> and <mv>voice</mv> yield <a>dt:string</a>s.
			<mv>Gender</mv> is <kwd>male</kwd>, <kwd>female</kwd>, or
			<mv>neuter</mv>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> command speaks the specified <mv>phrase</mv> using a
			text-to-speech synthesizer. If the <mv>voice</mv> is specified,
			the <mv>phrase</mv> will be read using the specified <mv>voice</mv>.
			Otherwise, the default voice is used.
		</p>
	</description>
	<notes>
		<p>
			The <me/> command is asynchronous: it will return immediately
			while the speech keeps playing in the background. If there is
			already text being spoken, the next text to be spoken will be
			added to a queue. The <code>stop speech</code> command will stop
			all current and pending speech.
		</p>
		<p>
			HyperTalk and OpenXION running under Mac OS use the speech
			synthesizer built in to Mac OS. OpenXION running under other
			platforms will use JSAPI (Java Speech API), if available.
			If JSAPI is not available, <me/> will do nothing but set the
			<a>fn:result</a> to an error message.
		</p>
	</notes>
	<see-also>
		cm:stop, fn:speech, fn:voice, fn:voices
	</see-also>
</command>

<command>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">stop</name>
	<syntax>
		<syn>
			stop sound
		</syn>
		<syn>
			stop speech
		</syn>
		<syn>
			stop tone
		</syn>
	</syntax>
	<description>
		<p>
			The <code>stop sound</code> command immediately stops all current
			and pending sound started or queued by the <a>cm:play</a> command
			on all <a>pr:soundChannel</a>s. To stop sound on the current
			<a>pr:soundChannel</a> only, use the <code>play stop</code> form
			of <a>cm:play</a>.
		</p>
		<p>
			The <code>stop speech</code> command immediately stops all current
			and pending speech started or queued by the <a>cm:speak</a> command.
		</p>
		<p>
			The <code>stop tone</code> command immediately stops all current
			and pending tones started or queued by the <a>cm:tone</a> command
			on all <a>pr:toneChannel</a>s.
		</p>
	</description>
	<compatibility>
		<p>
			HyperTalk does not have a <a>cm:tone</a> or <code>stop tone</code>
			command.
		</p>
	</compatibility>
	<see-also>
		cm:play, cm:speak, cm:tone
	</see-also>
</command>

<command>
	<name dialects="oxn&ge;1.2" modules="oxna&ge;1.2">tone</name>
	<syntax>
		<syn>
			tone <mv>frequency</mv>
			<opt>for <mv>duration</mv> <opt><mv>unit</mv></opt></opt>
		</syn>
		<p>
			<mv>Frequency</mv> and <mv>duration</mv> yield <a>dt:number</a>s.
			<mv>Unit</mv> is <kwd>hour</kwd>, <kwd>hours</kwd>,
			<kwd>min</kwd>, <kwd>mins</kwd>, <kwd>minute</kwd>,
			<kwd>minutes</kwd>, <kwd>sec</kwd>, <kwd>secs</kwd>,
			<kwd>second</kwd>, <kwd>seconds</kwd>, <kwd>tick</kwd>,
			<kwd>ticks</kwd>, <kwd>milli</kwd>, <kwd>millis</kwd>,
			<kwd>millisecond</kwd>, or <kwd>milliseconds</kwd>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> command plays a tone of a single <mv>frequency</mv>
			(in Hz) for a specified <mv>duration</mv>. Unless specified,
			the default <mv>unit</mv> for the <mv>duration</mv> is
			<kwd>ticks</kwd>, or sixtieths of a second. The volume of the
			generated tone is determined by the <a>pr:toneVolume</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> command is asynchronous: it will return immediately
			while the tone keeps playing in the background. If there is
			already a tone playing on the current <a>pr:toneChannel</a>,
			the next tone to be played will be added to a queue.
			The <code>stop tone</code> command will stop all currently-playing
			and pending tones on all <a>pr:toneChannel</a>s.
		</p>
	</notes>
	<see-also>
		cm:stop, fn:tone, pr:toneVolume, pr:toneChannel
	</see-also>
</command>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">abs</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put abs(a-b) into theDifference
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the absolute value of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a>, an <a>dt:integer</a>
			is returned.
		</p>
		<p>
			If the argument is a <a>dt:number</a>, a <a>dt:number</a>
			is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned. The returned <a>dt:complex</a> will have a real
			part of the distance of the passed in <a>dt:complex</a> from
			the origin, and an imaginary part of zero.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to the <a>fn:hypot</a> and
			<a>fn:radius</a> functions, but takes one numeric argument
			rather than a list.
		</p>
	</notes>
	<see-also>
		fn:hypot, fn:radius
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">acos</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put acos(theCosine) into theAngle
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse cosine of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">acosh</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put acosh(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse hyperbolic cosine of
			its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">acot</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put acot(theCotangent) into theAngle
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse cotangent of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">acoth</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put acoth(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse hyperbolic cotangent
			of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">acsc</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put acsc(theCosecant) into theAngle
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse cosecant of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">acsch</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put acsch(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse hyperbolic cosecant
			of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">agm</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put agm(steve, bill) into andy
		</scr>
	</examples>
	<description>
		<p>
			The <a>fn:agm</a> function returns the arithmetic-geometric
			mean of its arguments.
		</p>
		<p>
			The following function handler mimics the behavior of this
			built-in function for valid arguments:
		</p>
		<scr>
			function agm a,b
			  repeat while a is not b
			    put (a+b)/2 into arithmeticMean
			    put sqrt(a*b) into geometricMean
			    put arithmeticMean into a
			    put geometricMean into b
			  end repeat
			  return a
			end agm
		</scr>
		<p>
			The <me/> function is faster and more accurate than using
			the above handler.
		</p>
		<p>
			If both arguments are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If either argument is negative,
			<a>cn:NaN</a> is returned. To get a <a>dt:complex</a> result,
			convert the arguments to <a>dt:complex</a>es.
		</p>
		<p>
			If either argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
	<notes>
		<p>
			To use this function with more than two arguments,
			use this construction:
		</p>
		<p>
			<code><a>cm:get</a> <a>fn:agm</a>(<a>fn:avg</a>(<mv>list</mv>),
			<a>fn:geom</a>(<mv>list</mv>))</code>
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">and</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:booleans</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if
			all of its arguments are <a>cn:true</a>. If any argument
			is <a>cn:false</a>, it returns <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:and</a> operator.
		</p>
	</notes>
	<see-also>
		op:and, op:&amp;&amp;&amp;, fn:or, fn:xor
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">annuity</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>rate</mv>, <mv>periods</mv> )
		</syn>
		<syn>
			<me/> ( <mv>rate</mv>, <mv>periods</mv> )
		</syn>
		<p>
			<mv>Rate</mv> and <mv>periods</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put myPayment*annuity(.015,12) into presentValue
		</scr>
		<scr>
			put myPayment*annuity(.015,12)*compound(.015,12) ¬
			    into futureValue
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function is used to calculate the present or future
			value of an ordinary annuity. <mv>Rate</mv> is the interest rate
			per period, and <mv>periods</mv> is the number of periods over
			which the value is calculated.
		</p>
		<p>
			The formula for the <me/> function is:
		</p>
		<p>
			<code><a>fn:annuity</a>(<mv>rate</mv>, <mv>periods</mv>) =
			(1-((1+<mv>rate</mv>)^(-<mv>periods</mv>)))/<mv>rate</mv></code>
		</p>
		<p>
			The <me/> function is faster and more accurate than using
			the above formula.
		</p>
	</description>
	<notes>
		<p>
			You can use <a>dt:complex</a> arguments to this function,
			but what this means exactly is up to the accountants and
			economists to figure out, not me.
		</p>
	</notes>
	<see-also>
		fn:compound
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxns">appFile</name>
	<name dialects="oxn" modules="oxns">applicationFile</name>
	<name dialects="oxn" modules="oxns">progFile</name>
	<name dialects="oxn" modules="oxns">programFile</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a <a>dt:file</a> that represents
			the application with the specified name. If no such application
			can be found, the <me/> function returns <a>cn:empty</a>.
			In OpenXION, the locations searched for applications are
			determined by the <a>pr:applicationPaths</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> function is specific to OpenXION; it is not part
			of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:open, pr:applicationPaths, fn:appPath, fn:docPath, fn:docFile,
		fn:appOrDocPath, fn:appOrDocFile
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxns">appPath</name>
	<name dialects="oxn" modules="oxns">applicationPath</name>
	<name dialects="oxn" modules="oxns">progPath</name>
	<name dialects="oxn" modules="oxns">programPath</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the path of the application with
			the specified name. If no such application can be found, the
			<me/> function returns <a>cn:empty</a>. In OpenXION, the
			locations searched for applications are determined by the
			<a>pr:applicationPaths</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> function is specific to OpenXION; it is not part
			of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:open, pr:applicationPaths, fn:appFile, fn:docPath, fn:docFile,
		fn:appOrDocPath, fn:appOrDocFile
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxns">appOrDocFile</name>
	<name dialects="oxn" modules="oxns">applicationOrDocumentFile</name>
	<name dialects="oxn" modules="oxns">progOrDocFile</name>
	<name dialects="oxn" modules="oxns">programOrDocumentFile</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a <a>dt:file</a> that represents
			the application or document with the specified name. If no such
			application or document can be found, the <me/> function returns
			<a>cn:empty</a>. In OpenXION, the locations searched for
			applications and documents are determined by the
			<a>pr:applicationPaths</a> and <a>pr:documentPaths</a> properties,
			respectively.
		</p>
	</description>
	<notes>
		<p>
			The <me/> function is specific to OpenXION; it is not part
			of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:open, pr:applicationPaths, pr:documentPaths, fn:appPath, fn:appFile,
		fn:docPath, fn:docFile, fn:appOrDocPath
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxns">appOrDocPath</name>
	<name dialects="oxn" modules="oxns">applicationOrDocumentPath</name>
	<name dialects="oxn" modules="oxns">progOrDocPath</name>
	<name dialects="oxn" modules="oxns">programOrDocumentPath</name>
	<name dialects="oxn" modules="oxns">path</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the path of the application or document
			with the specified name. If no such application or document can be
			found, the <me/> function returns <a>cn:empty</a>. In OpenXION, the
			locations searched for applications and documents are determined by
			the <a>pr:applicationPaths</a> and <a>pr:documentPaths</a>
			properties, respectively.
		</p>
	</description>
	<notes>
		<p>
			The <me/> function is specific to OpenXION; it is not part
			of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:open, pr:applicationPaths, pr:documentPaths, fn:appPath, fn:appFile,
		fn:docPath, fn:docFile, fn:appOrDocFile
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">arg</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put arg(3,4) into angle
		</scr>
	</examples>
	<description>
		<p>
			The <a>fn:arg</a> function returns the complex argument
			of its argument.
		</p>
		<p>
			If the argument is a negative <a>dt:integer</a> or
			<a>dt:number</a>, <a>cn:pi</a> is returned. If the argument
			is a positive <a>dt:integer</a> or <a>dt:number</a>,
			or if the argument is <a>cn:zero</a>, <a>cn:zero</a>
			is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned. The returned <a>dt:complex</a> will have a real
			part of the angle, in radians, of the passed in <a>dt:complex</a>
			from the positive x-axis, and an imaginary part of zero.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to the <a>fn:atan2</a> and <a>fn:theta</a>
			functions, but takes one numeric argument rather than two.
		</p>
	</notes>
	<see-also>
		fn:atan2, fn:theta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">asc</name>
	<name dialects="xn,oxn" modules="oxns">ascending</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv>
			yield any kind of <a>dt:list</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if
			its arguments are in a monotonically increasing sequence.
			That is, every element in the list must be greater than
			or equal to the elements preceding it, and less than or
			equal to the elements following it. The elements are compared
			as if by the <a>op:&lt;=</a> operator.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:&lt;=</a> operator.
		</p>
	</notes>
	<see-also>
		fn:inc, fn:increasing, fn:desc, fn:descending, fn:dec, fn:decreasing, op:&lt;=
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">asec</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put asec(theSecant) into theAngle
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse secant of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">asech</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put asech(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse hyperbolic secant
			of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">asin</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put asin(theSine) into theAngle
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse sine of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">asinh</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put asinh(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse hyperbolic sine
			of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">atan</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put atan(theTangent) into theAngle
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse tangent of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
	<see-also>
		fn:atan2
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">atan2</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>
			or a <a>dt:number</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put atan2(steve, bill) into andy
		</scr>
	</examples>
	<description>
		<p>
			The <a>fn:atan2</a> function returns the angle, in radians,
			of the specified coordinates from the positive x-axis. The
			first argument is the y coordinate, and the second argument
			is the x coordinate.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to the <a>fn:theta</a> function,
			but the arguments are in opposite order. It is also similar
			to the <a>fn:arg</a> function, but it takes two arguments
			rather than one, and the elements are in opposite order.
		</p>
	</notes>
	<see-also>
		fn:atan, fn:arg, fn:theta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">atanh</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put atanh(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the inverse hyperbolic tangent
			of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">aug</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put aug(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the given value rounded towards
			unsigned infinity, or away from zero. If the given value is
			an <a>dt:integer</a>, the given value is returned. Otherwise,
			the given value is rounded to the integer with the next
			highest absolute value and the same sign.
		</p>
		<p>
			The following table illustrates the behavior of the <me/> function:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th>result</th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
		<p>
			If the given value is a <a>dt:complex</a>, the real and imaginary
			parts of the complex number are each rounded individually.
		</p>
	</description>
	<notes>
		<p>
			The following table shows the correspondences among the
			various <mv>roundingMethod</mv>s, rounding functions,
			and division operators:
		</p>
		<table>
			<tr>
				<th><code>rounding</code> parameter</th>
				<th>function</th>
				<th>operator</th>
				<th><code>java.math.RoundingMode</code></th>
			</tr>
			<tr>
				<td><code>to ceiling</code></td>
				<td><a>fn:ceil</a></td>
				<td></td>
				<td><code>CEILING</code></td>
			</tr>
			<tr>
				<td><code>to floor</code></td>
				<td><a>fn:floor</a></td>
				<td><a>op:div</a> / <a>op:mod</a></td>
				<td><code>FLOOR</code></td>
			</tr>
			<tr>
				<td><code>up</code> / <code>to infinity</code></td>
				<td><a>fn:aug</a></td>
				<td></td>
				<td><code>UP</code></td>
			</tr>
			<tr>
				<td><code>down</code> / <code>to zero</code></td>
				<td><a>fn:trunc</a></td>
				<td><a>op:quot</a> / <a>op:rem</a></td>
				<td><code>DOWN</code></td>
			</tr>
			<tr>
				<td><code>to nearest</code></td>
				<td><a>fn:round</a></td>
				<td></td>
				<td><code>HALF_UP</code></td>
			</tr>
			<tr>
				<td><code>to even</code></td>
				<td><a>fn:rint</a></td>
				<td></td>
				<td><code>HALF_EVEN</code></td>
			</tr>
		</table>
		<p>
			The following table illustrates the behavior of the rounding
			functions side-by-side:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th><a>fn:ceil</a></th>
				<th><a>fn:floor</a></th>
				<th><a>fn:aug</a></th>
				<th><a>fn:trunc</a></th>
				<th><a>fn:round</a></th>
				<th><a>fn:rint</a></th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
	</notes>
	<see-also>
		fn:ceil, fn:floor, fn:trunc, fn:round, fn:rint
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">average</name>
	<name dialects="xn,oxn" modules="oxns">avg</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put average(1,3,4) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the arithmetic mean,
			or average, of the numeric values passed to it.
			This is equal to the sum of the passed values
			divided by the number of values.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:geom, fn:geomean
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">bc</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>sourceBase</mv>, <mv>destinationBase</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>sourceBase</mv>, <mv>destinationBase</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields a <a>dt:string</a>.
			<mv>SourceBase</mv> and <mv>destinationBase</mv> yield positive
			<a>dt:integer</a>s between 2 and 36, inclusive.
		</p>
	</syntax>
	<examples>
		<scr>
			put bc("09F91102", 16, 10) into myNumber
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function converts a real or complex number in any base,
			or radix, to the same number in another base. For example,
			<code>bc("FF",16,10)</code> gives <code>"255"</code>, and
			<code>bc("255",10,16)</code> gives <code>"FF"</code>.
		</p>
	</description>
	<notes>
		<p>
			If the given <mv>sourceBase</mv> or <mv>destinationBase</mv>
			is less than 2 or greater than 36, a script error is triggered.
		</p>
	</notes>
	<see-also>
		fn:bin, fn:hex, fn:oct
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">beta</name>
	<name dialects="xn,oxn" modules="oxns">β</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function computes the value of the beta function,
			also known as the Euler integral of the first kind.
		</p>
		<p>
			The expression <code><me/>(<mv>x</mv>,<mv>y</mv>)</code> is
			equivalent to <code><a>fn:gamma</a>(<mv>x</mv>) *
			<a>fn:gamma</a>(<mv>y</mv>) /
			<a>fn:gamma</a>(<mv>x</mv>+<mv>y</mv>)</code>.
		</p>
	</description>
	<see-also>
		fn:factorial, fn:gamma, fn:lnfactorial, fn:lngamma, fn:lnbeta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">bin</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put bin(6789) into steve
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function converts a real or complex number in decimal,
			or base ten, to the same number in binary, or base two. For example,
			<code>bin(42)</code> gives <code>"101010"</code>.
		</p>
	</description>
	<see-also>
		fn:bc, fn:hex, fn:oct
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">binToChar</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield a <a>dt:binary</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put the binToChar of "6364" -- yields "cd"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the <a>dt:string</a> encoded by the
			<a>dt:binary</a> passed to it in the text encoding specified
			by the <a>pr:textEncoding</a> property.
		</p>
	</description>
	<see-also>
		fn:binToUni, fn:charToBin, fn:charToNum,
		fn:numToChar, fn:numToUni, fn:uniToBin, fn:uniToNum
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">binToUni</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield a <a>dt:binary</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put the binToUni of "CEB3CEB4" -- yields "γδ"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the <a>dt:string</a> encoded by the
			<a>dt:binary</a> passed to it in the UTF-8 text encoding.
		</p>
	</description>
	<see-also>
		fn:binToChar, fn:charToBin, fn:charToNum,
		fn:numToChar, fn:numToUni, fn:uniToBin, fn:uniToNum
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">cbrt</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put cbrt(27) -- puts 3
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the cube root of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
	<see-also>
		fn:sqrt
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">ceil</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put ceil(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the given value rounded towards
			positive infinity. If the given value is an <a>dt:integer</a>,
			the given value is returned. Otherwise, the given value is
			rounded to the next highest integer, regardless of sign.
		</p>
		<p>
			The following table illustrates the behavior of the <me/> function:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th>result</th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
		<p>
			If the given value is a <a>dt:complex</a>, the real and imaginary
			parts of the complex number are each rounded individually.
		</p>
	</description>
	<notes>
		<p>
			The following table shows the correspondences among the
			various <mv>roundingMethod</mv>s, rounding functions,
			and division operators:
		</p>
		<table>
			<tr>
				<th><code>rounding</code> parameter</th>
				<th>function</th>
				<th>operator</th>
				<th><code>java.math.RoundingMode</code></th>
			</tr>
			<tr>
				<td><code>to ceiling</code></td>
				<td><a>fn:ceil</a></td>
				<td></td>
				<td><code>CEILING</code></td>
			</tr>
			<tr>
				<td><code>to floor</code></td>
				<td><a>fn:floor</a></td>
				<td><a>op:div</a> / <a>op:mod</a></td>
				<td><code>FLOOR</code></td>
			</tr>
			<tr>
				<td><code>up</code> / <code>to infinity</code></td>
				<td><a>fn:aug</a></td>
				<td></td>
				<td><code>UP</code></td>
			</tr>
			<tr>
				<td><code>down</code> / <code>to zero</code></td>
				<td><a>fn:trunc</a></td>
				<td><a>op:quot</a> / <a>op:rem</a></td>
				<td><code>DOWN</code></td>
			</tr>
			<tr>
				<td><code>to nearest</code></td>
				<td><a>fn:round</a></td>
				<td></td>
				<td><code>HALF_UP</code></td>
			</tr>
			<tr>
				<td><code>to even</code></td>
				<td><a>fn:rint</a></td>
				<td></td>
				<td><code>HALF_EVEN</code></td>
			</tr>
		</table>
		<p>
			The following table illustrates the behavior of the rounding
			functions side-by-side:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th><a>fn:ceil</a></th>
				<th><a>fn:floor</a></th>
				<th><a>fn:aug</a></th>
				<th><a>fn:trunc</a></th>
				<th><a>fn:round</a></th>
				<th><a>fn:rint</a></th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
	</notes>
	<see-also>
		fn:floor, fn:aug, fn:trunc, fn:round, fn:rint
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">center</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>length</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>length</mv> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Length</mv>
			yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the middle <mv>length</mv>
			characters of the specified <mv>string</mv>.
		</p>
	</description>
	<notes>
		<p>
			If <mv>length</mv> is zero or negative, <a>cn:empty</a> is returned.
			If <mv>length</mv> is longer than the specified <mv>string</mv>,
			the original <mv>string</mv> is returned.
		</p>
	</notes>
	<see-also>
		fn:left, fn:mid, fn:right
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">charToBin</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield a <a>dt:string</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put the charToBin of "ab" into it -- yields "6162"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a <a>dt:binary</a> of the string
			passed to it encoded in the text encoding specified by the
			<a>pr:textEncoding</a> property.
		</p>
	</description>
	<see-also>
		fn:binToChar, fn:binToUni, fn:charToNum,
		fn:numToChar, fn:numToUni, fn:uniToBin, fn:uniToNum
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">charToNum</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield a character.
		</p>
	</syntax>
	<examples>
		<scr>
			put the charToNum of "a" into it -- yields 97
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the equivalent value of the
			character passed to it in the text encoding specified by the
			<a>pr:textEncoding</a> property.
		</p>
	</description>
	<notes>
		<p>
			If more than one character is passed, <me/> returns the value
			of the first character.
		</p>
	</notes>
	<see-also>
		fn:binToChar, fn:binToUni, fn:charToBin,
		fn:numToChar, fn:numToUni, fn:uniToBin, fn:uniToNum
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">compound</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>rate</mv>, <mv>periods</mv> )
		</syn>
		<syn>
			<me/> ( <mv>rate</mv>, <mv>periods</mv> )
		</syn>
		<p>
			<mv>Rate</mv> and <mv>periods</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put futureValue/compound(.10,12) into presentValue
		</scr>
		<scr>
			put presentValue*compound(.10,12) into futureValue
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function is used to calculate the present or future
			value of a compound interest-bearing account. <mv>Rate</mv> is
			the interest rate per period, and <mv>periods</mv> is the number
			of periods over which the value is calculated.
		</p>
		<p>
			The formula for the <me/> function is:
		</p>
		<p>
			<code><a>fn:compound</a>(<mv>rate</mv>, <mv>periods</mv>) =
			(1+<mv>rate</mv>)^<mv>periods</mv></code>.
		</p>
		<p>
			The <me/> function is faster and more accurate
			than using the above formula.
		</p>
	</description>
	<scripts>
		<p>
			The following example calculates the value in one year of an account
			earning 7.5 percent interest compounded monthly:
		</p>
		<scr>
			on calcInterest
			  ask "Enter the beginning balance:" with empty
			  put "Value in 1 year $" &amp; it * compound(.075/12, 12)
			end calcInterest
		</scr>
	</scripts>
	<notes>
		<p>
			You can use <a>dt:complex</a> arguments to this function, but
			what this means exactly is up to the accountants and economists
			to figure out, not me.
		</p>
	</notes>
	<see-also>
		fn:annuity
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">concat</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:strings</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string concatenation
			of all of its arguments.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:&amp;</a> operator.
		</p>
	</notes>
	<see-also>
		fn:concatsp, fn:implode, fn:lconcat
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">concatsp</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:strings</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string concatenation of all
			of its arguments, with a single space between each argument.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:&amp;&amp;</a>
			operator.
		</p>
	</notes>
	<see-also>
		fn:concat, fn:implode, fn:lconcat
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">conj</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put conj(3,4) -- yields 3,-4
		</scr>
	</examples>
	<description>
		<p>
			The <a>fn:conj</a> function returns the complex conjugate
			of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			the argument itself is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned. The returned <a>dt:complex</a> will have the same
			real part, and the negation of the imaginary part.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">cos</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the cos of 2 -- yields -0.416147
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the cosine of the angle that is
			passed to it. The angle must be expressed in radians.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			Radians can be converted to degrees with the <a>fn:toDegrees</a>
			function, or by multiplying by 180 and dividing by <a>cn:pi</a>.
			Degrees can be converted to radians with the <a>fn:toRadians</a>
			function, or by multiplying by <a>cn:pi</a> and dividing by 180.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">cosh</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the cosh of 2 -- yields 3.762196
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the hyperbolic cosine of the value
			that is passed to it.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">cot</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the cot of 2 -- yields -0.457658
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the cotangent of the angle that is
			passed to it. The angle must be expressed in radians.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			Radians can be converted to degrees with the <a>fn:toDegrees</a>
			function, or by multiplying by 180 and dividing by <a>cn:pi</a>.
			Degrees can be converted to radians with the <a>fn:toRadians</a>
			function, or by multiplying by <a>cn:pi</a> and dividing by 180.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">coth</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the coth of 2 -- yields 1.037315
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the hyperbolic cotangent of the value
			that is passed to it.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">countFields</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>String</mv> and <mv>delimiter</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the number of chunks in the specified
			<mv>string</mv> delimited by the specified <mv>delimiter</mv>,
			not including any trailing empty chunks.
		</p>
		<p>
			The <mv>delimiter</mv> is case-insensitive. For a case-sensitive
			version of this function, see <a>fn:csCountFields</a>. For a
			regular expression-based version of this function, see
			<a>fn:regCountFields</a>.
		</p>
	</description>
	<see-also>
		fn:csCountFields, fn:regCountFields, fn:trCountFields,
		fn:nthField, fn:csNthField, fn:regNthField, fn:trNthField
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">cpad</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>,
			<mv>length</mv><opt>, <mv>padding</mv></opt> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>,
			<mv>length</mv><opt>, <mv>padding</mv></opt> )
		</syn>
		<p>
			<mv>String</mv> and <mv>padding</mv> yield any <a>dt:string</a>s.
			<mv>Length</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function both prepends and appends the specified
			<mv>padding</mv> to the specified <mv>string</mv> until the
			resulting string is longer than the specified <mv>length</mv>,
			then returns the middle <mv>length</mv> characters of the
			resulting string. In other words, the string is padded to be
			aligned in the center. If no <mv>padding</mv> is specified,
			spaces are used.
		</p>
	</description>
	<notes>
		<p>
			If <mv>length</mv> is zero or negative, <a>cn:empty</a> is returned.
			If <mv>length</mv> is shorter than the specified <mv>string</mv>,
			only the middle <mv>length</mv> characters of the original
			<mv>string</mv> are returned.
		</p>
	</notes>
	<see-also>
		fn:lpad, fn:rpad
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csc</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the csc of 2 -- yields 1.099750
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the cosecant of the angle that
			is passed to it. The angle must be expressed in radians.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			Radians can be converted to degrees with the <a>fn:toDegrees</a>
			function, or by multiplying by 180 and dividing by <a>cn:pi</a>.
			Degrees can be converted to radians with the <a>fn:toRadians</a>
			function, or by multiplying by <a>cn:pi</a> and dividing by 180.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csch</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the csch of 2 -- yields 0.275721
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the hyperbolic cosecant
			of the value that is passed to it.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csCountFields</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>String</mv> and <mv>delimiter</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the number of chunks in the specified
			<mv>string</mv> delimited by the specified <mv>delimiter</mv>,
			not including any trailing empty chunks.
		</p>
		<p>
			The <mv>delimiter</mv> is case-sensitive. For a case-insensitive
			version of this function, see <a>fn:countFields</a>. For a regular
			expression-based version of this function, see <a>fn:regCountFields</a>.
		</p>
	</description>
	<see-also>
		fn:countFields, fn:regCountFields, fn:trCountFields,
		fn:nthField, fn:csNthField, fn:regNthField, fn:trNthField
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csExplode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>String</mv> and <mv>delimiter</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a <a>dt:list</a> of the chunks in the
			specified <mv>string</mv> delimited by the specified
			<mv>delimiter</mv>, not including any trailing empty chunks.
		</p>
		<p>
			The <mv>delimiter</mv> is case-sensitive. For a case-insensitive
			version of this function, see <a>fn:explode</a>. For a regular
			expression-based version of this function, see <a>fn:regExplode</a>.
		</p>
	</description>
	<see-also>
		fn:explode, fn:regExplode, fn:trExplode, fn:implode
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csInstr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> and <mv>needle</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the first appearance of
			the string <mv>needle</mv> in the string <mv>haystack</mv>,
			starting at 1. If <mv>needle</mv> cannot be found in
			<mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is case-sensitive. For a case-insensitive version
			of this function, see <a>fn:instr</a>. For a regular
			expression-based version of this function, see <a>fn:regInstr</a>.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to <a>fn:csOffset</a>,
			but the arguments are in reverse order.
		</p>
	</notes>
	<see-also>
		fn:instr, fn:regInstr, fn:trInstr,
		fn:offset, fn:csOffset, fn:regOffset, fn:trOffset,
		fn:rinstr, fn:csRinstr, fn:regRinstr, fn:trRinstr
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csNthField</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv>,
			<mv>index</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv>, <mv>index</mv> )
		</syn>
		<p>
			<mv>String</mv> and <mv>delimiter</mv> yield <a>dt:string</a>s.
			<mv>Index</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a chunk of the specified
			<mv>string</mv> delimited by the specified <mv>delimiter</mv>.
			<mv>Index</mv> starts at 1.
		</p>
		<p>
			If <mv>index</mv> is less than 1 or greater than
			<code><a>fn:csCountFields</a>(<mv>string</mv>,
			<mv>delimiter</mv>)</code>, <a>cn:empty</a> is returned.
		</p>
		<p>
			The <mv>delimiter</mv> is case-sensitive. For a case-insensitive
			version of this function, see <a>fn:nthField</a>. For a regular
			expression-based version of this function, see <a>fn:regNthField</a>.
		</p>
	</description>
	<see-also>
		fn:nthField, fn:regNthField, fn:trNthField,
		fn:countFields, fn:csCountFields, fn:regCountFields, fn:trCountFields
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csOffset</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>needle</mv>, <mv>haystack</mv> )
		</syn>
		<syn>
			<me/> ( <mv>needle</mv>, <mv>haystack</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> and <mv>needle</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the first appearance of
			the string <mv>needle</mv> in the string <mv>haystack</mv>,
			starting at 1. If <mv>needle</mv> cannot be found in
			<mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is case-sensitive. For a case-insensitive version
			of this function, see <a>fn:offset</a>. For a regular
			expression-based version of this function, see <a>fn:regOffset</a>.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to <a>fn:csInstr</a>,
			but the arguments are in reverse order.
		</p>
	</notes>
	<see-also>
		fn:offset, fn:regOffset, fn:trOffset,
		fn:instr, fn:csInstr, fn:regInstr, fn:trInstr,
		fn:rinstr, fn:csRinstr, fn:regRinstr, fn:trRinstr
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csReplace</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv>, <mv>needle</mv>, and <mv>noodle</mv>
			yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string <mv>haystack</mv>
			with the first occurrence of the string <mv>needle</mv>
			replaced with the string <mv>noodle</mv>.
		</p>
		<p>
			<mv>Needle</mv> is case-sensitive. For a case-insensitive version
			of this function, see <a>fn:replace</a>. For a regular
			expression-based version of this function, see <a>fn:regReplace</a>.
		</p>
	</description>
	<see-also>
		fn:csReplaceAll, fn:replace, fn:regReplace, fn:trReplace
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csReplaceAll</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv>, <mv>needle</mv>, and <mv>noodle</mv>
			yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string <mv>haystack</mv>
			with every occurrence of the string <mv>needle</mv>
			replaced with the string <mv>noodle</mv>.
		</p>
		<p>
			<mv>Needle</mv> is case-sensitive. For a case-insensitive version
			of this function, see <a>fn:replaceAll</a>. For a regular
			expression-based version of this function, see <a>fn:regReplaceAll</a>.
		</p>
	</description>
	<see-also>
		fn:csReplace, fn:replaceAll, fn:regReplaceAll, fn:trReplaceAll
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csRinstr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> and <mv>needle</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the last appearance of
			the string <mv>needle</mv> in the string <mv>haystack</mv>,
			starting at 1. If <mv>needle</mv> cannot be found in
			<mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is case-sensitive. For a case-insensitive version
			of this function, see <a>fn:rinstr</a>. For a regular
			expression-based version of this function, see <a>fn:regRinstr</a>.
		</p>
	</description>
	<see-also>
		fn:rinstr, fn:regRinstr, fn:trRinstr,
		fn:instr, fn:csInstr, fn:regInstr, fn:trInstr,
		fn:offset, fn:csOffset, fn:regOffset, fn:trOffset
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">csStrcmp</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields a <a>dt:string</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <a>fn:strcmp</a> function compares the two given
			<a>dt:string</a>s by Unicode code point. If the first string
			comes before the second, a negative <a>dt:integer</a> is returned.
			If the first string comes after the second, a positive
			<a>dt:integer</a> is returned. If the two strings are equal,
			<a>cn:zero</a> is returned.
		</p>
		<p>
			The <a>fn:csStrcmp</a> function is case-sensitive. For a
			case-insensitive version of this function, see <a>fn:strcmp</a>.
			For a regular expression-based version of this function, see
			<a>fn:regMatch</a>.
		</p>
	</description>
	<see-also>
		fn:strcmp, fn:regMatch, fn:trMatch
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">date</name>
	<syntax>
		<syn>
			the <opt><mv>modifier</mv></opt> <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
		<p>
			<mv>Modifier</mv> is <a>kw:short</a>, <a>kw:abbreviated</a>,
			<a>kw:long</a>, or <a>kw:English</a>. The default is <a>kw:short</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put the last word of the long date into currentYear
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a <a>dt:date</a> representing the current date.
			There are four forms of the <me/> function:
		</p>
		<table>
			<tr>
				<td><code>the short date</code></td>
				<td><code>20/7/93</code></td>
			</tr>
			<tr>
				<td><code>the abbrev date</code></td>
				<td><code>Tue 20 Oct 1992</code></td>
			</tr>
			<tr>
				<td><code>the long date</code></td>
				<td><code>Tuesday 7 October 1989</code></td>
			</tr>
			<tr>
				<td><code>the English date</code></td>
				<td><code>Saturday, February 15, 1986</code></td>
			</tr>
		</table>
	</description>
	<notes>
		<p>
			The format of the date is dependent on the current locale. This is
			important if you want to write scripts that work anywhere without
			modification. You cannot assume that the <me/> function will always
			return a date in the same format.
		</p>
		<p>
			To prevent issues caused by differing local date formats, use the
			<a>fn:seconds</a> or the <a>fn:dateItems</a> to store and perform
			calculations with dates and times.
		</p>
	</notes>
	<see-also>
		cm:convert, fn:dateItems, fn:seconds, fn:ticks, fn:time
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">dateItems</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the first item of the dateItems into currentYear
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a <a>dt:date</a> representing the
			current date as a comma-delimited list of integers representing
			the year, month (from 1 for January to 12 for December), day,
			hour (from 0 to 23), minute, second, and day of week
			(from 1 for Sunday to 7 for Saturday). The format of the <me/>
			is fixed.
		</p>
	</description>
	<see-also>
		cm:convert, fn:date, fn:seconds, fn:ticks, fn:time
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">dec</name>
	<name dialects="xn,oxn" modules="oxns">decreasing</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv>
			yield any kind of <a>dt:list</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if its
			arguments are in a strictly decreasing sequence. That is,
			every element in the list must be less than the elements
			preceding it, and greater than the elements following it.
			The elements are compared as if by the <a>op:&gt;</a> operator.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:&gt;</a> operator.
		</p>
	</notes>
	<compatibility>
		<p>
			In OpenXION 1.3 and earlier, this was a synonym of <a>fn:descending</a>.
		</p>
	</compatibility>
	<see-also>
		fn:desc, fn:descending, fn:inc, fn:increasing, fn:asc, fn:ascending, op:&gt;
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">desc</name>
	<name dialects="xn,oxn" modules="oxns">descending</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv>
			yield any kind of <a>dt:list</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if its
			arguments are in a monotonically decreasing sequence. That is,
			every element in the list must be less than or equal to the
			elements preceding it, and greater than or equal to the elements
			following it. The elements are compared as if by the <a>op:&gt;=</a>
			operator.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:&gt;=</a> operator.
		</p>
	</notes>
	<see-also>
		fn:dec, fn:decreasing, fn:inc, fn:increasing, fn:asc, fn:ascending, op:&gt;=
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxns">docFile</name>
	<name dialects="oxn" modules="oxns">documentFile</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a <a>dt:file</a> that represents the
			document with the specified name. If no such document can be found,
			the <me/> function returns <a>cn:empty</a>. In OpenXION, the
			locations searched for documents are determined by the
			<a>pr:documentPaths</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> function is specific to OpenXION; it is not part
			of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:open, pr:documentPaths, fn:appPath, fn:appFile, fn:docPath,
		fn:appOrDocPath, fn:appOrDocFile
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxns">docPath</name>
	<name dialects="oxn" modules="oxns">documentPath</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the path of the document with the
			specified name. If no such document can be found, the <me/>
			function returns <a>cn:empty</a>. In OpenXION, the locations
			searched for documents are determined by the
			<a>pr:documentPaths</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> function is specific to OpenXION; it is not part
			of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:open, pr:documentPaths, fn:appPath, fn:appFile, fn:docFile,
		fn:appOrDocPath, fn:appOrDocFile
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">equal</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv>
			yield any kind of <a>dt:list</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if all
			of its arguments are equal to each other. If any two arguments
			are not equal, the <me/> function returns <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			If the given values are <a>dt:integer</a>s or <a>dt:number</a>s,
			the values will be compared numerically. If the given values are
			<a>dt:date</a>s, the values will be compared chronologically.
			Otherwise, the values will be compared as strings.
		</p>
		<p>
			This is the infinite-arity version of the <a>op:=</a> operator.
		</p>
	</notes>
	<see-also>
		op:=
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">exp</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the exp of 2 -- yields 7.389056
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the mathematical exponential of its
			argument, defined as the constant <i>e</i>, which is approximately
			2.7182818284, raised to the power specified by the argument.
			That is, it returns:
		</p>
		<p>
			<code><a>cn:euler</a>^<mv>number</mv></code>
		</p>
		<p>
			The <me/> function is faster and more accurate than using
			the above formula.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:exp1, fn:exp2, fn:exp10, fn:ln, fn:ln1, fn:log2, fn:log10, fn:log
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">exp1</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the exp1 of 2 -- yields 6.389056
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns 1 less than the mathematical
			exponential of its argument. That is, it returns:
		</p>
		<p>
			<code>(<a>cn:euler</a>^<mv>number</mv>)-1</code>
		</p>
		<p>
			The <me/> function is faster and more accurate than using
			the above formula.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:exp, fn:exp2, fn:exp10, fn:ln, fn:ln1, fn:log2, fn:log10, fn:log
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">exp10</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the exp10 of 4 -- yields 10000
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the value of 10 raised to the
			power specified by its argument. That is, it returns:
		</p>
		<p>
			<code>10^<mv>number</mv></code>
		</p>
		<p>
			The <me/> function is faster and more accurate than using
			the above formula.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:exp, fn:exp1, fn:exp2, fn:ln, fn:ln1, fn:log2, fn:log10, fn:log
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">exp2</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the exp2 of 16 -- yields 65536
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the value of 2 raised to the
			power specified by its argument. That is, it returns:
		</p>
		<p>
			<code>2^<mv>number</mv></code>
		</p>
		<p>
			The <me/> function is faster and more accurate than using
			the above formula.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:exp, fn:exp1, fn:exp10, fn:ln, fn:ln1, fn:log2, fn:log10, fn:log
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">explode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>String</mv> and <mv>delimiter</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a <a>dt:list</a> of the chunks
			in the specified <mv>string</mv> delimited by the specified
			<mv>delimiter</mv>, not including any trailing empty chunks.
		</p>
		<p>
			The <mv>delimiter</mv> is case-insensitive. For a case-sensitive
			version of this function, see <a>fn:csExplode</a>. For a regular
			expression-based version of this function, see <a>fn:regExplode</a>.
		</p>
	</description>
	<see-also>
		fn:csExplode, fn:regExplode, fn:trExplode, fn:implode
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">fact</name>
	<name dialects="xn,oxn" modules="oxns">factorial</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<p>
			<code>put the <me/> of 5 -- yields 120</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the factorial of its argument. For
			positive integers, the factorial is defined as the product of
			the integers from 1 to the specified integer, e.g.
			<code>fact(5) = 1 * 2 * 3 * 4 * 5 = 120</code>. For other real
			or complex numbers, the factorial is defined in terms of the
			<a>fn:gamma</a> function, i.e. <code><a>fn:fact</a>(<mv>n</mv>) =
			<a>fn:gamma</a>(<mv>n</mv>+1)</code>.
		</p>
	</description>
	<see-also>
		fn:gamma, fn:beta, fn:lnfactorial, fn:lngamma, fn:lnbeta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn&ge;1.4" modules="oxns&ge;1.4">filter</name>
	<syntax>
		<syn>
			the <me/> of ( <mv>list</mv>, <mv>functionName</mv> )
		</syn>
		<syn>
			<me/> ( <mv>list</mv>, <mv>functionName</mv> )
		</syn>
		<p>
			<mv>List</mv> yields a <a>dt:list</a>. <mv>FunctionName</mv>
			yields the name of a function.
		</p>
	</syntax>
	<examples>
		<scr>
			put filter((1,2,inf,NaN,-7), "isFinite") -- prints 1,2,-7
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function applies the specified <mv>functionName</mv>
			to each item in the specified <mv>list</mv> and returns a list
			of the values for which the function returned <a>cn:true</a>.
			The function must return either <a>cn:true</a> or <a>cn:false</a>
			for each item in the <mv>list</mv>; otherwise, a script error
			will be triggered.
		</p>
	</description>
	<see-also>
		fn:map, fn:reduce
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">floor</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put floor(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the given value rounded towards
			negative infinity. If the given value is an <a>dt:integer</a>,
			the given value is returned. Otherwise, the given value is rounded
			to the next lowest integer, regardless of sign.
		</p>
		<p>
			The following table illustrates the behavior of the <me/> function:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th>result</th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
		<p>
			If the given value is a <a>dt:complex</a>, the real and imaginary
			parts of the complex number are each rounded individually.
		</p>
	</description>
	<notes>
		<p>
			The following table shows the correspondences among the
			various <mv>roundingMethod</mv>s, rounding functions,
			and division operators:
		</p>
		<table>
			<tr>
				<th><code>rounding</code> parameter</th>
				<th>function</th>
				<th>operator</th>
				<th><code>java.math.RoundingMode</code></th>
			</tr>
			<tr>
				<td><code>to ceiling</code></td>
				<td><a>fn:ceil</a></td>
				<td></td>
				<td><code>CEILING</code></td>
			</tr>
			<tr>
				<td><code>to floor</code></td>
				<td><a>fn:floor</a></td>
				<td><a>op:div</a> / <a>op:mod</a></td>
				<td><code>FLOOR</code></td>
			</tr>
			<tr>
				<td><code>up</code> / <code>to infinity</code></td>
				<td><a>fn:aug</a></td>
				<td></td>
				<td><code>UP</code></td>
			</tr>
			<tr>
				<td><code>down</code> / <code>to zero</code></td>
				<td><a>fn:trunc</a></td>
				<td><a>op:quot</a> / <a>op:rem</a></td>
				<td><code>DOWN</code></td>
			</tr>
			<tr>
				<td><code>to nearest</code></td>
				<td><a>fn:round</a></td>
				<td></td>
				<td><code>HALF_UP</code></td>
			</tr>
			<tr>
				<td><code>to even</code></td>
				<td><a>fn:rint</a></td>
				<td></td>
				<td><code>HALF_EVEN</code></td>
			</tr>
		</table>
		<p>
			The following table illustrates the behavior of the rounding
			functions side-by-side:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th><a>fn:ceil</a></th>
				<th><a>fn:floor</a></th>
				<th><a>fn:aug</a></th>
				<th><a>fn:trunc</a></th>
				<th><a>fn:round</a></th>
				<th><a>fn:rint</a></th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
	</notes>
	<see-also>
		fn:ceil, fn:aug, fn:trunc, fn:round, fn:rint
	</see-also>
</function>

<function>
	<name dialects="xn,oxn&ge;1.4" modules="oxns&ge;1.4">format</name>
	<name dialects="xn,oxn&ge;1.4" modules="oxns&ge;1.4">'</name>
	<syntax>
		<syn>
			the <me/> of ( <mv>format</mv>
			<opt>, <mv>parameter</mv>
			<opt>, <mv>parameter</mv>
			<opt>, ...</opt></opt></opt> )
		</syn>
		<syn>
			<me/> ( <mv>format</mv>
			<opt>, <mv>parameter</mv>
			<opt>, <mv>parameter</mv>
			<opt>, ...</opt></opt></opt> )
		</syn>
		<p>
			<mv>Format</mv> yields a format <a>dt:string</a>.
			<mv>Parameter</mv> yields any <a>dt:variant</a>.
		</p>
	</syntax>
	<examples>
		<p>
			<code><me/>("Hello, ^1!", "World")</code>
		</p>
		<p>
			<code><me/>("^{^1?no items|one item|^1 items}", myCount)</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns a string produced from the given
			<mv>format</mv> string using the given <mv>parameter</mv>s.
		</p>
		<p>
			Sequences in the <mv>format</mv> string starting with the ^
			character are replaced with <mv>parameter</mv>s, conditional
			text, or special characters as described below.
		</p>
		<p>
			A ^ character followed by an integer is replaced with a parameter.
			The parameter after the format string is parameter 1.
			The parameter number may be followed by a lowercase <code>n</code>
			and a minimum string length; a lowercase <code>m</code> and a
			maximum string length; a lowercase <code>l</code> and a character
			for left padding; or a lowercase <code>r</code> and a character
			for right padding. Optionally, the sequence can end with one of
			the following format specifiers:
		</p>
		<table>
			<tr>
				<td><code>s</code></td>
				<td>a string (the default)</td>
			</tr>
			<tr>
				<td><code>l</code></td>
				<td>a list, delimited by commas</td>
			</tr>
			<tr>
				<td><code>L</code></td>
				<td>a list, delimited by a comma followed by a space</td>
			</tr>
			<tr>
				<td><code>i</code></td>
				<td>an integer, using the current <a>pr:numberFormat</a></td>
			</tr>
			<tr>
				<td><code>I</code></td>
				<td>an integer, using the local number format</td>
			</tr>
			<tr>
				<td><code>n</code></td>
				<td>a number, using the current <a>pr:numberFormat</a></td>
			</tr>
			<tr>
				<td><code>N</code></td>
				<td>a number, using the local number format</td>
			</tr>
			<tr>
				<td><code>o</code></td>
				<td>an octal number</td>
			</tr>
			<tr>
				<td><code>h</code></td>
				<td>a hexadecimal number, in lowercase</td>
			</tr>
			<tr>
				<td><code>H</code></td>
				<td>a hexadecimal number, in uppercase</td>
			</tr>
			<tr>
				<td><code>c</code></td>
				<td>a complex, using the current <a>pr:numberFormat</a></td>
			</tr>
			<tr>
				<td><code>C</code></td>
				<td>a complex, using the local number format</td>
			</tr>
			<tr>
				<td><code>d</code></td>
				<td>a date</td>
			</tr>
			<tr>
				<td><code>t</code></td>
				<td>a time</td>
			</tr>
			<tr>
				<td><code>b</code></td>
				<td>a binary, without spacing between bytes</td>
			</tr>
			<tr>
				<td><code>B</code></td>
				<td>a binary, with spacing between bytes</td>
			</tr>
		</table>
		<p>
			Finally, if the sequence will be followed by a digit or letter,
			a tilde (~) can be used to indicate the end of the sequence.
		</p>
		<p>
			A ^ character followed by an opening brace is replaced with
			conditional text. The opening brace must be followed by an
			expression using only parameter numbers preceded by ^, string
			and number literals, and operators named using only symbols.
			A question mark (?) separates the expression from a list of
			alternatives. Each alternative is a format string of its own.
			The first alternative corresponds to a value of true or zero,
			the second alternative to a value of false or one, the third
			alternative to a value of two, and so on; the last alternative
			is chosen if the value is greater than the number of alternatives.
			Alternatives are delimited using vertical bars (|). Finally,
			a closing brace indicates the end of the list of alternatives.
		</p>
		<p>
			Finally, the special sequences <code>^}</code>, <code>^|</code>,
			and <code>^^</code> are replaced with a literal closing brace,
			vertical bar, or caret, respectively.
		</p>
		<p>
			The <a>fn:'</a> form of this function is used with strings that
			should be localized. By running OpenXION with the <code>-M</code>
			parameter, a message file will be generated for your language and
			locale. By editing the message file, you or other people can
			translate your script's messages into other languages without
			having to modify the script itself.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">frac</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put frac(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the fractional part of the given value,
			discarding the integer part, regardless of sign. The sign of the
			result will be the same as the sign of the given value.
		</p>
		<p>
			The following table illustrates the behavior of the <me/> function:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th>result</th>
			</tr>
			<tr>
				<td>2</td>
				<td>0</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>0.75</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>0.5</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>0.25</td>
			</tr>
			<tr>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>0.75</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>0.5</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>0.25</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>-0.25</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>-0.5</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>-0.75</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-0.25</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-0.5</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-0.75</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>0</td>
			</tr>
		</table>
		<p>
			If the given value is a <a>dt:complex</a>, the real and imaginary
			parts of the complex number are each processed individually.
		</p>
	</description>
	<see-also>
		fn:int
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">gamma</name>
	<name dialects="xn,oxn" modules="oxns">Γ</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function computes the value of the gamma function.
		</p>
	</description>
	<see-also>
		fn:factorial, fn:beta, fn:lnfactorial, fn:lngamma, fn:lnbeta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">gcd</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put gcd(steve, bill) into andy
		</scr>
	</examples>
	<description>
		<p>
			The <a>fn:gcd</a> function returns the greatest
			common divisor of its arguments.
		</p>
	</description>
	<see-also>
		fn:lcm
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">geom</name>
	<name dialects="xn,oxn" modules="oxns">geomean</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<p>
			<code>put <me/>(1,3,4) into bill</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the geometric mean
			of the numeric values passed to it.
			This is equal to the product of the passed values
			raised to the power of one over the number of values.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:avg, fn:average
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">hash</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>data</mv>
		</syn>
		<syn>
			<opt>the</opt> <me/> of ( <mv>data</mv>, <mv>algorithm</mv> )
		</syn>
		<syn>
			<me/> ( <mv>data</mv><opt>, <mv>algorithm</mv></opt> )
		</syn>
		<p>
			<mv>Data</mv> yields a <a>dt:binary</a> or a <a>dt:string</a>.
			<mv>Algorithm</mv> yields the name of a hash algorithm.
		</p>
	</syntax>
	<examples>
		<scr>
			put hash(steve, "Atkinson") into bill
		</scr>
		<scr>
			put hash(data, "MD5") into md5
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function hashes the specified <mv>data</mv> with
			the specified hash <mv>algorithm</mv> and returns an
			<a>dt:integer</a>, a <a>dt:binary</a>, or a <a>dt:string</a>
			containing the resulting hash.
		</p>
		<p>
			If <mv>data</mv> is not a <a>dt:binary</a>, it is converted
			to a <a>dt:string</a>, converted to lowercase, and
			then converted to a <a>dt:binary</a> using the text
			encoding specified by the <a>pr:textEncoding</a>
			property.
		</p>
		<p>
			If the hash <mv>algorithm</mv> is not specified, the default is
			the Atkinson hash algorithm. The Atkinson algorithm is
			the only hash algorithm required by the XION Scripting
			Language Standard. The resulting hash is returned as
			an unsigned <a>dt:integer</a>. The Atkinson hash algorithm
			is as follows:
		</p>
		<p>
			<br/>if the binary is zero-length:
			<br/>        initialize <mv>hash</mv> to <code>0x42696C6C</code> (<code>'Bill'</code>)
			<br/>else:
			<br/>        initialize <mv>hash</mv> to zero
			<br/>        initialize <mv>seed</mv> to the unsigned value of the first byte, plus the number of bytes
			<br/>        for each bit <mv>b</mv> in the binary, starting with the most significant bit of the first byte:
			<br/>                multiply <mv>seed</mv> by <code>0x41A7</code>
			<br/>                while <mv>seed</mv> ≥ <code>0x80000000</code>:
			<br/>                        set <mv>seed</mv> to ( <mv>seed</mv> &amp; <code>0x7FFFFFFF</code> ) + ( <mv>seed</mv> &gt;&gt; 31 )
			<br/>                if <mv>seed</mv> = <code>0x7FFFFFFF</code>:
			<br/>                        set <mv>seed</mv> to zero
			<br/>                if bit <mv>b</mv> is set:
			<br/>                        add <mv>seed</mv> to <mv>hash</mv>
			<br/>return the 32 least significant bits of <mv>hash</mv>
		</p>
	</description>
	<notes>
		<p>
			OpenXION supports Atkinson, returning an unsigned <a>dt:integer</a>,
			as well as MD2, MD5, SHA-1, SHA-256, SHA-384, and SHA-512,
			returning a <a>dt:binary</a>.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">head</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the first element in a list.
		</p>
	</description>
	<see-also>
		fn:tail
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">hex</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put hex(6789) into steve
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function converts a real or complex number in decimal,
			or base ten, to the same number in hexadecimal, or base sixteen.
			For example, <code>hex(8984)</code> gives <code>"2318"</code>.
		</p>
	</description>
	<see-also>
		fn:bc, fn:bin, fn:oct
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">hypot</name>
	<name dialects="xn,oxn" modules="oxns">radius</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<p>
			<code>put <me/>(3,4) -- yields 5</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the square root of the sum of the
			squares of its arguments. For one argument, this is equivalent
			to the <a>fn:abs</a> function. For <mv>n</mv> arguments, this
			is equivalent to the distance from the origin of the specified
			point in <mv>n</mv>-dimensional space.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to the <a>fn:abs</a> function,
			but can take more than one argument.
		</p>
	</notes>
	<see-also>
		fn:abs, fn:xcoord, fn:ycoord, fn:theta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">Im</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the imaginary part of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			<a>cn:zero</a> is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, the imaginary part
			of the argument is returned as a <a>dt:number</a>.
		</p>
	</description>
	<see-also>
		fn:Re
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">implode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>list</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>list</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>List</mv> yields a <a>dt:list</a> of <a>dt:strings</a>.
			<mv>Delimiter</mv> yields a <a>dt:string</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string concatenation of all
			of its arguments, with the specified <mv>delimiter</mv>
			between each argument.
		</p>
	</description>
	<see-also>
		fn:concat, fn:concatsp,
		fn:explode, fn:csExplode, fn:regExplode, fn:trExplode
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">inc</name>
	<name dialects="xn,oxn" modules="oxns">increasing</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv>
			yield any kind of <a>dt:list</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if
			its arguments are in a strictly increasing sequence.
			That is, every element in the list must be greater than
			the elements preceding it, and less than the elements
			following it. The elements are compared as if by the
			<a>op:&lt;</a> operator.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:&lt;</a> operator.
		</p>
	</notes>
	<compatibility>
		<p>
			In OpenXION 1.3 and earlier, this was a synonym of <a>fn:ascending</a>.
		</p>
	</compatibility>
	<see-also>
		fn:asc, fn:ascending, fn:desc, fn:descending, fn:dec, fn:decreasing, op:&lt;
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.1" modules="oxns&ge;1.1">includeFile</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a <a>dt:file</a> that represents the
			include with the specified name. If no such include can be found,
			the <me/> function returns <a>cn:empty</a>. In OpenXION, the
			locations searched for includes are determined by the
			<a>pr:includePaths</a> property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> function is specific to OpenXION; it is not part
			of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cs:include, cs:require, pr:includePaths, fn:includePath
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.1" modules="oxns&ge;1.1">includePath</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the path of the include with the
			specified name. If no such include can be found, the <me/> 
			function returns <a>cn:empty</a>. In OpenXION, the locations
			searched for includes are determined by the <a>pr:includePaths</a>
			property.
		</p>
	</description>
	<notes>
		<p>
			The <me/> function is specific to OpenXION; it is not part
			of the XION Scripting Language Standard.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cs:include, cs:require, pr:includePaths, fn:includeFile
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">instr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> and <mv>needle</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the first appearance of
			the string <mv>needle</mv> in the string <mv>haystack</mv>,
			starting at 1. If <mv>needle</mv> cannot be found in
			<mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is case-insensitive. For a case-sensitive version
			of this function, see <a>fn:csInstr</a>. For a regular
			expression-based version of this function, see <a>fn:regInstr</a>.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to <a>fn:offset</a>,
			but the arguments are in reverse order.
		</p>
	</notes>
	<see-also>
		fn:csInstr, fn:regInstr, fn:trInstr,
		fn:offset, fn:csOffset, fn:regOffset, fn:trOffset,
		fn:rinstr, fn:csRinstr, fn:regRinstr, fn:trRinstr
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">isFinite</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if the specified value
			is defined and finite, or <a>cn:false</a> if the specified value
			is <a>cn:NaN</a>, <a>cn:infinity</a>, or -<a>cn:infinity</a>.
		</p>
	</description>
	<see-also>
		fn:isInfinite, fn:isNaN
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">isInfinite</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if the specified value
			is <a>cn:infinity</a> or -<a>cn:infinity</a>, or <a>cn:false</a>
			if the specified value is defined and finite or <a>cn:NaN</a>.
		</p>
	</description>
	<see-also>
		fn:isFinite, fn:isNaN
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">isNaN</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if the specified value
			is <a>cn:NaN</a>, or <a>cn:false</a> if the specified value is
			defined and finite, <a>cn:infinity</a>, or -<a>cn:infinity</a>.
		</p>
	</description>
	<see-also>
		fn:isFinite, fn:isInfinite
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">lcase</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function converts all the letters in the specified
			<a>dt:string</a> to lowercase and returns the resulting
			<a>dt:string</a>. For example, <code>lcase("Hello, my name is
			Rebecca. But you can call me Beckie.") = "hello, my name is
			rebecca. but you can call me beckie."</code>.
		</p>
	</description>
	<see-also>
		fn:ucase, fn:tcase
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">lcm</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put lcm(steve, bill) into andy
		</scr>
	</examples>
	<description>
		<p>
			The <a>fn:lcm</a> function returns the least common multiple
			of its arguments.
		</p>
	</description>
	<see-also>
		fn:gcd
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">lconcat</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield
			<a>dt:list</a>s of <a>dt:lists</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the list concatenation
			of all of its arguments.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <code>op::</code>
			operator.
		</p>
	</notes>
	<see-also>
		fn:concat, fn:concatsp
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">left</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>length</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>length</mv> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Length</mv>
			yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the leftmost <mv>length</mv>
			characters of the specified <mv>string</mv>.
		</p>
	</description>
	<notes>
		<p>
			If <mv>length</mv> is zero or negative, <a>cn:empty</a> is returned.
			If <mv>length</mv> is longer than the specified <mv>string</mv>,
			the original <mv>string</mv> is returned.
		</p>
	</notes>
	<see-also>
		fn:center, fn:mid, fn:right
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">length</name>
	<name dialects="xn,oxn" modules="oxns">len</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<examples>
		<p>
			<code>put <me/>("tail") into it -- yields 4</code>
		</p>
		<p>
			<code>put <me/>("Nu är det slut…") -- yields 15</code>
		</p>
		<p>
			<code>if the <me/> of word n of steve > 25 ¬<br/>
			&nbsp;&nbsp;then add 1 to fogIndex</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the number of characters (including
			spaces, tabs, line breaks, and other control and formatting
			characters) in the <a>dt:string</a> passed to it.
		</p>
	</description>
	<notes>
		<p>
			The expression <code><me/>(<mv>factor</mv>)</code> is identical
			in effect to <code>the number of characters in <mv>factor</mv></code>
			but is more efficient.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn&ge;1.2" modules="oxns&ge;1.2">llength</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield lists.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the number of elements in a list.
		</p>
	</description>
	<see-also>
		fn:number
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">ln</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the ln of 10 -- yields 2.302585
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the base-<i>e</i> (natural) logarithm
			of the number passed to it.
		</p>
		<p>
			If the argument is a positive <a>dt:integer</a> or <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is <a>cn:zero</a>,
			negative <a>cn:infinity</a> is returned. If the argument is a
			negative <a>dt:integer</a> or <a>dt:number</a>, <a>cn:NaN</a>
			is returned. To get a <a>dt:complex</a> result, convert the argument
			to a <a>dt:complex</a>.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:exp, fn:exp1, fn:exp2, fn:exp10, fn:ln1, fn:log2, fn:log10, fn:log
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">ln1</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the ln1 of 10 -- yields 2.397895
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the base-<i>e</i> (natural) logarithm
			of 1 plus the number passed to it. That is, it returns:
		</p>
		<p>
			<code><a>fn:ln</a>(1+<mv>number</mv>)</code>
		</p>
		<p>
			The <me/> function is faster and more accurate than using
			the above formula.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>
			greater than -1, a <a>dt:number</a> is returned. If the argument
			is -1 exactly, negative <a>cn:infinity</a> is returned. If the
			argument is an <a>dt:integer</a> or a <a>dt:number</a> less than
			-1, <a>cn:NaN</a> is returned. To get a <a>dt:complex</a> result,
			convert the argument to a <a>dt:complex</a>.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
	<see-also>
		fn:exp, fn:exp1, fn:exp2, fn:exp10, fn:ln, fn:log2, fn:log10, fn:log
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">lnbeta</name>
	<name dialects="xn,oxn" modules="oxns">lnβ</name>
	<syntax>
		<syn>
			the <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>,
			a <a>dt:number</a>, or a <a>dt:complex</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function computes the natural logarithm
			of the beta function.
		</p>
		<p>
			The expression <code><me/>(<mv>x</mv>,<mv>y</mv>)</code> is
			equivalent to <code><a>fn:lngamma</a>(<mv>x</mv>) +
			<a>fn:lngamma</a>(<mv>y</mv>) -
			<a>fn:lngamma</a>(<mv>x</mv>+<mv>y</mv>)</code>.
		</p>
	</description>
	<see-also>
		fn:factorial, fn:gamma, fn:beta, fn:lnfactorial, fn:lngamma
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">lnfact</name>
	<name dialects="xn,oxn" modules="oxns">lnfactorial</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<p>
			<code>put the <me/> of 5 -- yields 4.787492</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the natural logarithm of the factorial
			of its argument. For positive integers, the factorial is defined
			as the product of the integers from 1 to the specified integer,
			e.g. <code>fact(5) = 1 * 2 * 3 * 4 * 5 = 120</code>. For other
			real or complex numbers, the factorial is defined in terms of the
			<a>fn:gamma</a> function, i.e. <code><a>fn:fact</a>(<mv>n</mv>) =
			<a>fn:gamma</a>(<mv>n</mv>+1)</code>.
		</p>
	</description>
	<see-also>
		fn:factorial, fn:gamma, fn:beta, fn:lngamma, fn:lnbeta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">lngamma</name>
	<name dialects="xn,oxn" modules="oxns">lnΓ</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function computes the natural logarithm
			of the gamma function.
		</p>
	</description>
	<see-also>
		fn:factorial, fn:gamma, fn:beta, fn:lnfactorial, fn:lnbeta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">log</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>argument</mv>, <mv>base</mv> )
		</syn>
		<syn>
			<me/> ( <mv>argument</mv>, <mv>base</mv> )
		</syn>
		<p>
			<mv>Argument</mv> and <mv>base</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put log(10,4) -- yields 1.660964
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the base-<mv>base</mv> logarithm
			of <mv>argument</mv>. That is, it returns:
		</p>
		<p>
			<code><a>fn:ln</a>(<mv>argument</mv>)/<a>fn:ln</a>(<mv>base</mv>)</code>
		</p>
		<p>
			The <me/> function is faster and more accurate than using
			the above formula.
		</p>
		<p>
			If both arguments are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If either argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:exp, fn:exp1, fn:exp2, fn:exp10, fn:ln, fn:ln1, fn:log2, fn:log10
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">log10</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the log10 of 42 -- yields 1.623249
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the base-10 (common) logarithm
			of the number passed to it.
		</p>
		<p>
			If the argument is a positive <a>dt:integer</a> or <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is <a>cn:zero</a>,
			negative <a>cn:infinity</a> is returned. If the argument is a
			negative <a>dt:integer</a> or <a>dt:number</a>, <a>cn:NaN</a>
			is returned. To get a <a>dt:complex</a> result, convert the
			argument to a <a>dt:complex</a>.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
	<see-also>
		fn:exp, fn:exp1, fn:exp2, fn:exp10, fn:ln, fn:ln1, fn:log2, fn:log
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">log2</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the log2 of 10 -- yields 3.321928
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the base-2 (binary) logarithm
			of the number passed to it.
		</p>
		<p>
			If the argument is a positive <a>dt:integer</a> or <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is <a>cn:zero</a>,
			negative <a>cn:infinity</a> is returned. If the argument is a
			negative <a>dt:integer</a> or <a>dt:number</a>, <a>cn:NaN</a>
			is returned. To get a <a>dt:complex</a> result, convert the
			argument to a <a>dt:complex</a>.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
	<see-also>
		fn:exp, fn:exp1, fn:exp2, fn:exp10, fn:ln, fn:ln1, fn:log10, fn:log
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">lpad</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>,
			<mv>length</mv><opt>, <mv>padding</mv></opt> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>length</mv><opt>,
			<mv>padding</mv></opt> )
		</syn>
		<p>
			<mv>String</mv> and <mv>padding</mv> yield any <a>dt:string</a>s.
			<mv>Length</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function prepends the specified <mv>padding</mv> to the
			specified <mv>string</mv> until the resulting string is longer than
			the specified <mv>length</mv>, then returns the rightmost
			<mv>length</mv> characters of the resulting string. In other words,
			the string is padded on the left to be aligned to the right. If no
			<mv>padding</mv> is specified, spaces are used.
		</p>
	</description>
	<notes>
		<p>
			If <mv>length</mv> is zero or negative, <a>cn:empty</a> is returned.
			If <mv>length</mv> is shorter than the specified <mv>string</mv>,
			only the rightmost <mv>length</mv> characters of the original
			<mv>string</mv> are returned.
		</p>
	</notes>
	<see-also>
		fn:cpad, fn:rpad
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">lreverse</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			put lreverse(1,2,3,4) -- yields 4,3,2,1
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the reversal of the specified
			<a>dt:list</a>. The last element of the given <a>dt:list</a>
			becomes the first element of the resulting <a>dt:list</a>,
			and vice versa.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">ltrim</name>
	<syntax>
		<syn>
			the <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			put ltrim("  Hello, world!  ") -- yields "Hello, world!  "
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function trims all spaces, tabs, line breaks, control
			characters, line separators, and paragraph separators from the
			beginning of the given <a>dt:string</a> and returns the trimmed string.
		</p>
	</description>
	<see-also>
		fn:trim, fn:rtrim
	</see-also>
</function>

<function>
	<name dialects="xn,oxn&ge;1.4" modules="oxns&ge;1.4">map</name>
	<syntax>
		<syn>
			the <me/> of ( <mv>list</mv>, <mv>functionName</mv> )
		</syn>
		<syn>
			<me/> ( <mv>list</mv>, <mv>functionName</mv> )
		</syn>
		<p>
			<mv>List</mv> yields a <a>dt:list</a>. <mv>FunctionName</mv>
			yields the name of a function.
		</p>
	</syntax>
	<examples>
		<scr>
			put map((1,4,9,16,25), "sqrt") -- prints 1,2,3,4,5
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function applies the specified <mv>functionName</mv>
			to each item in the specified <mv>list</mv> and returns a list
			of the return values.
		</p>
	</description>
	<see-also>
		fn:filter, fn:reduce
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">max</name>
	<name dialects="xn,oxn" modules="oxns">maximum</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv>
			yield any kind of <a>dt:list</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the largest element of its arguments.
			The elements are compared as if by the <a>op:&gt;</a> operator.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">mid</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>,
			<mv>offset</mv><opt>, <mv>length</mv></opt> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>,
			<mv>offset</mv><opt>, <mv>length</mv></opt> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Offset</mv>
			and <mv>length</mv> yield <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <mv>length</mv> characters of the
			specified <mv>string</mv> starting at the specified <mv>offset</mv>.
			The first character of the string is at offset 1.
		</p>
		<p>
			If no <mv>length</mv> is specified, all characters of the string
			starting at the specified <mv>offset</mv> are returned.
		</p>
	</description>
	<notes>
		<p>
			If <mv>length</mv> is zero or negative, or <mv>offset</mv> is
			greater than the length of the <mv>string</mv>, <a>cn:empty</a>
			is returned. If <mv>offset</mv> is zero or negative, the leftmost
			<mv>length</mv>+<mv>offset</mv>-1 characters of the <mv>string</mv>
			are returned.
		</p>
	</notes>
	<see-also>
		fn:left, fn:center, fn:right, fn:substr, fn:substring
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">min</name>
	<name dialects="xn,oxn" modules="oxns">minimum</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv>
			yield any kind of <a>dt:list</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the smallest element of its arguments.
			The elements are compared as if by the <a>op:&lt;</a> operator.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">nCr</name>
	<name dialects="xn,oxn" modules="oxns">choose</name>
	<syntax>
		<syn>
			the <me/> of ( <mv>n</mv>, <mv>r</mv> )
		</syn>
		<syn>
			<me/> ( <mv>n</mv>, <mv>r</mv> )
		</syn>
		<p>
			<mv>N</mv> and <mv>r</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the number of combinations
			where <mv>n</mv> is the number of things to choose from and
			<mv>r</mv> is the number of things chosen.
		</p>
		<p>
			The formula for the <me/> function is:
		</p>
		<p>
			<code><me/>(<mv>n</mv>,<mv>r</mv>) = <a>fn:fact</a>(<mv>n</mv>) /
			(<a>fn:fact</a>(<mv>r</mv>) * <a>fn:fact</a>(<mv>n</mv>-<mv>r</mv>))</code>
		</p>
		<p>
			The <me/> function is faster and more accurate than
			using the above formula.
		</p>
		<p>
			If both arguments are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If either argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:nPr, fn:pick
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">nPr</name>
	<name dialects="xn,oxn" modules="oxns">pick</name>
	<syntax>
		<syn>
			the <me/> of ( <mv>n</mv>, <mv>r</mv> )
		</syn>
		<syn>
			<me/> ( <mv>n</mv>, <mv>r</mv> )
		</syn>
		<p>
			<mv>N</mv> and <mv>r</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the number of permutations
			where <mv>n</mv> is the number of things to choose from and
			<mv>r</mv> is the number of things chosen.
		</p>
		<p>
			The formula for the <me/> function is:
		</p>
		<p>
			<code><me/>(<mv>n</mv>,<mv>r</mv>) = <a>fn:fact</a>(<mv>n</mv>) /
			<a>fn:fact</a>(<mv>n</mv>-<mv>r</mv>)</code>
		</p>
		<p>
			The <me/> function is faster and more accurate than
			using the above formula.
		</p>
		<p>
			If both arguments are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If either argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:nCr, fn:choose
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">nthField</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv>, <mv>index</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv>, <mv>index</mv> )
		</syn>
		<p>
			<mv>String</mv> and <mv>delimiter</mv> yield <a>dt:string</a>s.
			<mv>Index</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a chunk of the specified
			<mv>string</mv> delimited by the specified <mv>delimiter</mv>.
			<mv>Index</mv> starts at 1.
		</p>
		<p>
			If <mv>index</mv> is less than 1 or greater than
			<code><a>fn:countFields</a>(<mv>string</mv>, <mv>delimiter</mv>)</code>,
			<a>cn:empty</a> is returned.
		</p>
		<p>
			The <mv>delimiter</mv> is case-insensitive. For a case-sensitive
			version of this function, see <a>fn:csNthField</a>. For a regular
			expression-based version of this function, see <a>fn:regNthField</a>.
		</p>
	</description>
	<see-also>
		fn:csNthField, fn:regNthField, fn:trNthField,
		fn:countFields, fn:csCountFields, fn:regCountFields, fn:trCountFields
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">number</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield chunk expressions,
			lists, or objects.
		</p>
	</syntax>
	<examples>
		<scr>
			get the number of elements in steve
		</scr>
		<scr>
			get the number of words in bill
		</scr>
		<scr>
			get the number of andy
		</scr>
	</examples>
	<description>
		<p>
			For chunk expressions, the <me/> function returns the number
			of chunks in a range.
		</p>
		<p>
			For lists, the <me/> function returns the number
			of elements in a list.
		</p>
		<p>
			For objects, the <me/> function returns the index
			of an object.
		</p>
	</description>
	<see-also>
		pr:number, fn:llength
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">numToChar</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield non-negative
			<a>dt:integer</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			put numToChar(67) into it -- yields C
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the character whose equivalent value
			in the text encoding specified by the <a>pr:textEncoding</a>
			property is that of the <a>dt:integer</a> passed to it.
		</p>
	</description>
	<compatibility>
		<p>
			In HyperTalk, <code>numToChar(0)</code> triggers a script error.
			In XION, <code>numToChar(0)</code> returns <a>cn:null</a>.
		</p>
	</compatibility>
	<see-also>
		fn:binToChar, fn:binToUni, fn:charToBin, fn:charToNum,
		fn:numToUni, fn:uniToBin, fn:uniToNum
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">numToUni</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield non-negative
			<a>dt:integer</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			put numToUni(915) into it -- yields Γ
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the character whose Unicode
			code point is that of the <a>dt:integer</a> passed to it.
		</p>
	</description>
	<see-also>
		fn:binToChar, fn:binToUni, fn:charToBin, fn:charToNum,
		fn:numToChar, fn:uniToBin, fn:uniToNum
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">oct</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put oct(6789) into steve
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function converts a real or complex number in decimal,
			or base ten, to the same number in octal, or base eight. For example,
			<code>oct(493)</code> gives <code>"755"</code>.
		</p>
	</description>
	<see-also>
		fn:bc, fn:bin, fn:hex
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">offset</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>needle</mv>, <mv>haystack</mv> )
		</syn>
		<syn>
			<me/> ( <mv>needle</mv>, <mv>haystack</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> and <mv>needle</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the first appearance of
			the string <mv>needle</mv> in the string <mv>haystack</mv>,
			starting at 1. If <mv>needle</mv> cannot be found in
			<mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is case-insensitive. For a case-sensitive version
			of this function, see <a>fn:csOffset</a>. For a regular
			expression-based version of this function, see <a>fn:regOffset</a>.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to <a>fn:instr</a>, but the arguments
			are in reverse order.
		</p>
	</notes>
	<see-also>
		fn:csOffset, fn:regOffset, fn:trOffset,
		fn:instr, fn:csInstr, fn:regInstr, fn:trInstr,
		fn:rinstr, fn:csRinstr, fn:regRinstr, fn:trRinstr
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">or</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:booleans</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if any of its arguments
			are <a>cn:true</a>. If all arguments are <a>cn:false</a>, it
			returns <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:or</a> operator.
		</p>
	</notes>
	<see-also>
		op:or, op:|||, fn:and, fn:xor
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">param</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			if param(1) is empty then answer ¬
			  "The first parameter is null."
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a parameter value from the parameter
			list passed to the currently executing handler. The parameter
			returned is the <mv>n</mv>th parameter, where <mv>n</mv> is the
			<a>dt:integer</a> passed to the function. The value of
			<code>param(0)</code> is the message name.
		</p>
	</description>
	<scripts>
		<p>
			The following example sums the arguments passed to it, regardless of
			how many there are. In other words, it is functionally equivalent to
			the <a>fn:sum</a> function:
		</p>
		<scr>
			function addUp
			  put 0 into total
			  repeat with i = 1 to the paramCount
			    add param(i) to total
			  end repeat
			  return total
			end addUp
		</scr>
	</scripts>
	<see-also>
		fn:paramCount, fn:params
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">paramCount</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			if the paramCount &lt; 3 then ¬
			  put "I need at least three arguments."
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the number of parameters passed
			to the currently executing handler.
		</p>
	</description>
	<scripts>
		<p>
			The following example multiplies the arguments passed to it,
			regardless of how many there are. In other words, it is functionally
			equivalent to the <a>fn:product</a> function:
		</p>
		<scr>
			function theProduct
			  put 1 into total
			  repeat with i = 1 to the paramCount
			    multiply total by param(i)
			  end repeat
			  return total
			end theProduct
		</scr>
	</scripts>
	<see-also>
		fn:param, fn:params
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">params</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the params
		</scr>
	</examples>
	<description>
		<p>
			In XION, the <me/> function returns a <a>dt:list</a> of the
			parameters passed to the currently executing handler, not
			including the message name. In other words, <code>the params</code>
			looks like:
		</p>
		<p>
			<code><mv>parameter</mv>,<mv>parameter</mv>,<mv>parameter</mv>,...</code>
		</p>
		<p>
			In HyperTalk, the <me/> function returns a string containing
			the message name and the entire parameter list passed to the
			currently executing handler. The returned string is suitable
			for the <a>cs:do</a> keyword (if the handler is a message handler)
			or the <a>fn:value</a> function (if the handler is a function
			handler). In other words, <code>the params</code> looks like:
		</p>
		<p>
			<code><mv>messageName</mv> "<mv>parameter</mv>","<mv>parameter</mv>","<mv>parameter</mv>",...</code>
		</p>
		<p>
			or:
		</p>
		<p>
			<code><mv>functionName</mv>("<mv>parameter</mv>","<mv>parameter</mv>","<mv>parameter</mv>",...)</code>
		</p>
	</description>
	<see-also>
		fn:param, fn:paramCount
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">parent</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield an object with a parent.
		</p>
	</syntax>
	<examples>
		<scr>
			put the parent of char 3 of "Hello" -- yields "Hello"
		</scr>
		<scr>
			put the parent of file 1
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the parent object of its argument.
			This is valid only for certain kinds of objects, such as
			chunks and file system objects. If the specified object does
			not have a parent, a script error is triggered.
		</p>
		<p>
			For chunks, the <me/> function returns the container originally
			specified in the chunk expression.
		</p>
		<p>
			For <a>dt:file</a>s and <a>dt:folder</a>s, the <me/> function returns
			the containing <a>dt:folder</a>. For <a>dt:fork</a>s, the <me/> function
			returns the containing <a>dt:file</a>.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">pow</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the value of the power tower
			of the numeric values passed to it. For example,
			<code>pow(4,3,2)</code> evaluates to <code>4^3^2</code> or 262144.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:^</a> operator.
		</p>
	</notes>
	<see-also>
		op:^, fn:sum, fn:product, fn:root
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">prod</name>
	<name dialects="xn,oxn" modules="oxns">product</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<p>
			<code>get <me/>(1,2,3,4)</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the product of a list of
			numeric values passed to it.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:*</a> operator.
		</p>
	</notes>
	<see-also>
		op:*, fn:sum, fn:pow
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">pstddev</name>
	<name dialects="xn,oxn" modules="oxns">stddev</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<p>
			<code>get <me/>(1,2,3,4)</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the population standard deviation
			of a list of numeric values passed to it.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:sstddev, fn:variance
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">pvariance</name>
	<name dialects="xn,oxn" modules="oxns">variance</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<p>
			<code>get <me/>(1,2,3,4)</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the population variance
			of a list of numeric values passed to it.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:svariance, fn:stddev
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">random</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a random integer between 1
			and the specified <a>dt:integer</a>, inclusive.
			If the specified <a>dt:integer</a> is less than 1,
			the <me/> function always returns 1.
		</p>
	</description>
	<scripts>
		<p>
			The following example draws 10 unique random numbers
			between 1 and 100:
		</p>
		<scr>
			on drawRandom
			  put empty into randomList
			  repeat until the number of items in randomList is 10
			    get random of 100
			    if (the itemdelimiter &amp; it &amp; the itemdelimiter) is not in ¬
			        (the itemdelimiter &amp; randomList &amp; the itemdelimiter) then
			      put it &amp; the itemdelimiter after randomList
			    end if
			  end repeat
			  delete last char of randomList
			  put randomList
			end drawRandom
		</scr>
	</scripts>
	<see-also>
		fn:randomDecimal, fn:randomRange
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">randomDecimal</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<description>
		<p>
			The <me/> function returns a random real number
			between zero, exclusive, and one, inclusive.
			That is, it is possible for the returned value
			to be one, but not zero.
		</p>
	</description>
	<notes>
		<p>
			Most programming languages have a random number
			function that returns a number between zero, inclusive,
			and one, exclusive. That is, it is possible for
			the function to return zero, but not one. In XION,
			however, the <me/> function can return one, but not
			zero. For the terminally curious, this is due to the
			implementation of a <me/> function in KHyX, an
			extension stack for HyperCard; this also reflects
			the fact that the <a>fn:random</a> function can return
			the integer passed to it, but cannot return zero.
			To match the functionality of other languages,
			you can subtract the value returned from <me/>
			from one.
		</p>
	</notes>
	<see-also>
		fn:random, fn:randomRange
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">randomRange</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>start</mv>, <mv>end</mv> )
		</syn>
		<syn>
			<me/> ( <mv>start</mv>, <mv>end</mv> )
		</syn>
		<p>
			<mv>Start</mv> and <mv>end</mv> yield <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a random integer between <mv>start</mv>
			and <mv>end</mv>, inclusive. If <mv>end</mv> is less than
			<mv>start</mv>, the <me/> function always returns <mv>start</mv>.
		</p>
	</description>
	<scripts>
		<p>
			The following example draws 10 unique 3-digit random numbers:
		</p>
		<scr>
			on drawRandom
			  put empty into randomList
			  repeat until the number of items in randomList is 10
			    get randomRange(100, 999)
			    if (the itemdelimiter &amp; it &amp; the itemdelimiter) is not in ¬
			        (the itemdelimiter &amp; randomList &amp; the itemdelimiter) then
			      put it &amp; the itemdelimiter after randomList
			    end if
			  end repeat
			  delete last char of randomList
			  put randomList
			end drawRandom
		</scr>
	</scripts>
	<see-also>
		fn:random, fn:randomDecimal
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">Re</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the real part of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			the argument itself is returned.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, the real part of the
			argument is returned as a <a>dt:number</a>.
		</p>
	</description>
	<see-also>
		fn:Im
	</see-also>
</function>

<function>
	<name dialects="xn,oxn&ge;1.4" modules="oxns&ge;1.4">reduce</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>list</mv>,
			<mv>functionName</mv><opt>, <mv>initialValue</mv></opt> )
		</syn>
		<syn>
			<me/> ( <mv>list</mv>,
			<mv>functionName</mv><opt>, <mv>initialValue</mv></opt> )
		</syn>
		<p>
			<mv>List</mv> yields a <a>dt:list</a>.
			<mv>FunctionName</mv> yields the name of a function.
			<mv>InitialValue</mv> yields any <a>dt:variant</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put reduce((1,2,3,4,5), "sum") -- prints 15
		</scr>
		<scr>
			put reduce((1,2,3,4,5), "product", 1) -- prints 120
		</scr>
	</examples>
	<description>
		<p>
			First, the <me/> function sets the <mv>initialValue</mv>,
			or <a>cn:empty</a> if <mv>initialValue</mv> is not specified,
			to be its current value. Then, for each item in the <mv>list</mv>,
			the <me/> function evaluates the specified <mv>functionName</mv>
			with the current value and the item from the <mv>list</mv> as its
			two arguments. The return value of the function becomes the new
			current value. Finally, the <me/> function returns its current
			value.
		</p>
	</description>
	<notes>
		<p>
			The first time the <me/> function evaluates the specified
			<mv>functionName</mv>, the first parameter will be the
			<mv>initialValue</mv> and the second parameter will be the
			first item in the <mv>list</mv>. To start with the first and
			second items in the <mv>list</mv>, do something like the following:
		</p>
		<scr>
			local myList as list is (1,2,3,4,5)
			put reduce(tail(myList), "product", head(myList))
		</scr>
	</notes>
	<see-also>
		fn:map, fn:filter
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">replace</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>,
			<mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv>, <mv>needle</mv>, and <mv>noodle</mv>
			yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string <mv>haystack</mv>
			with the first occurrence of the string <mv>needle</mv>
			replaced with the string <mv>noodle</mv>.
		</p>
		<p>
			<mv>Needle</mv> is case-insensitive. For a case-sensitive version
			of this function, see <a>fn:csReplace</a>. For a regular
			expression-based version of this function, see <a>fn:regReplace</a>.
		</p>
	</description>
	<see-also>
		fn:replaceAll, fn:csReplace, fn:regReplace, fn:trReplace
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">replaceAll</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>,
			<mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv>, <mv>needle</mv>, and <mv>noodle</mv>
			yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string <mv>haystack</mv>
			with every occurrence of the string <mv>needle</mv>
			replaced with the string <mv>noodle</mv>.
		</p>
		<p>
			<mv>Needle</mv> is case-insensitive. For a case-sensitive version
			of this function, see <a>fn:csReplaceAll</a>. For a regular
			expression-based version of this function, see <a>fn:regReplaceAll</a>.
		</p>
	</description>
	<see-also>
		fn:replace, fn:csReplaceAll, fn:regReplaceAll, fn:trReplaceAll
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">result</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			if the result is not empty then answer "Try again."
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the return value of the last command
			executed. Most built-in commands only set the <me/> if the command
			was executed unsuccessfully; otherwise, the <me/> is set to
			<a>cn:empty</a>. A user-defined command can set the <me/> with a
			<a>cs:return</a> statement. The <a>cm:answer</a> and <a>cm:ask</a>
			commands use the <me/> to tell the script if the user cancelled
			a prompt instead of choosing a proper response.
		</p>
	</description>
	<see-also>
		cs:on, cs:return, cm:ask, cm:answer, cm:sql
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">reverse</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			put reverse("hello") -- yields "olleh"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the reversal of the specified
			<a>dt:string</a>. The last character of the given <a>dt:string</a>
			becomes the first character of the resulting <a>dt:string</a>,
			and vice versa.
		</p>
	</description>
	<see-also>
		fn:reverseBits, fn:reverseBytes
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">reverseBits</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>value</mv>, <mv>width</mv> )
		</syn>
		<syn>
			<me/> ( <mv>value</mv>, <mv>width</mv> )
		</syn>
		<p>
			<mv>Value</mv> and <mv>width</mv> return <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the value obtained by reversing the
			bits of the two's complement representation of the specified
			<mv>value</mv>. <mv>Width</mv> is the number of bytes in the
			two's complement representation.
		</p>
	</description>
	<see-also>
		fn:reverseBytes
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">reverseBytes</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>value</mv>, <mv>width</mv> )
		</syn>
		<syn>
			<me/> ( <mv>value</mv>, <mv>width</mv> )
		</syn>
		<p>
			<mv>Value</mv> and <mv>width</mv> return <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the value obtained by reversing the
			bytes of the two's complement representation of the specified
			<mv>value</mv>. <mv>Width</mv> is the number of bytes in the
			two's complement representation.
		</p>
	</description>
	<see-also>
		fn:reverseBits
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">right</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>length</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>length</mv> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Length</mv>
			yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the rightmost <mv>length</mv>
			characters of the specified <mv>string</mv>.
		</p>
	</description>
	<notes>
		<p>
			If <mv>length</mv> is zero or negative, <a>cn:empty</a> is returned.
			If <mv>length</mv> is longer than the specified <mv>string</mv>,
			the original <mv>string</mv> is returned.
		</p>
	</notes>
	<see-also>
		fn:left, fn:center, fn:mid
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">rinstr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> and <mv>needle</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the last appearance of
			the string <mv>needle</mv> in the string <mv>haystack</mv>,
			starting at 1. If <mv>needle</mv> cannot be found in
			<mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is case-insensitive. For a case-sensitive version
			of this function, see <a>fn:csRinstr</a>. For a regular
			expression-based version of this function, see <a>fn:regRinstr</a>.
		</p>
	</description>
	<see-also>
		fn:csRinstr, fn:regRinstr, fn:trRinstr,
		fn:instr, fn:csInstr, fn:regInstr, fn:trInstr,
		fn:offset, fn:csOffset, fn:regOffset, fn:trOffset
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">rint</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put rint(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the given value rounded towards the
			nearest integer. If the given value is an <a>dt:integer</a>,
			the given value is returned. Otherwise, the given value is rounded
			to the nearest integer. If the fractional part of the given value
			is exactly .5, the given value is rounded towards the nearest
			even number.
		</p>
		<p>
			The following table illustrates the behavior of the <me/> function:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th>result</th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
		<p>
			If the given value is a <a>dt:complex</a>, the real and imaginary
			parts of the complex number are each rounded individually.
		</p>
	</description>
	<notes>
		<p>
			The following table shows the correspondences among the
			various <mv>roundingMethod</mv>s, rounding functions,
			and division operators:
		</p>
		<table>
			<tr>
				<th><code>rounding</code> parameter</th>
				<th>function</th>
				<th>operator</th>
				<th><code>java.math.RoundingMode</code></th>
			</tr>
			<tr>
				<td><code>to ceiling</code></td>
				<td><a>fn:ceil</a></td>
				<td></td>
				<td><code>CEILING</code></td>
			</tr>
			<tr>
				<td><code>to floor</code></td>
				<td><a>fn:floor</a></td>
				<td><a>op:div</a> / <a>op:mod</a></td>
				<td><code>FLOOR</code></td>
			</tr>
			<tr>
				<td><code>up</code> / <code>to infinity</code></td>
				<td><a>fn:aug</a></td>
				<td></td>
				<td><code>UP</code></td>
			</tr>
			<tr>
				<td><code>down</code> / <code>to zero</code></td>
				<td><a>fn:trunc</a></td>
				<td><a>op:quot</a> / <a>op:rem</a></td>
				<td><code>DOWN</code></td>
			</tr>
			<tr>
				<td><code>to nearest</code></td>
				<td><a>fn:round</a></td>
				<td></td>
				<td><code>HALF_UP</code></td>
			</tr>
			<tr>
				<td><code>to even</code></td>
				<td><a>fn:rint</a></td>
				<td></td>
				<td><code>HALF_EVEN</code></td>
			</tr>
		</table>
		<p>
			The following table illustrates the behavior of the rounding
			functions side-by-side:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th><a>fn:ceil</a></th>
				<th><a>fn:floor</a></th>
				<th><a>fn:aug</a></th>
				<th><a>fn:trunc</a></th>
				<th><a>fn:round</a></th>
				<th><a>fn:rint</a></th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
	</notes>
	<see-also>
		fn:ceil, fn:floor, fn:aug, fn:trunc, fn:round
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">rms</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put rms(2,3,4) -- yields 3.109126
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the root mean square, or the square
			root of the arithmetic mean of the squares, of its arguments.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">root</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the value of the nested radicals
			represented by the numeric values passed to it. For example,
			<code>root(9,8,3)</code> evaluates to <code>9^(1/(8^(1/3)))</code>
			or 3.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		op:^, fn:pow
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">rot13</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the text passed to it enciphered
			(or deciphered) with the ROT13 substitution cipher. All a's
			in the text become n's, b's become o's, c's become p's, and
			so on and vice versa.
		</p>
		<p>
			In the following example, the punchline of the joke has been
			enciphered with ROT13:
		</p>
		<scr>
			How can you tell an extrovert from an introvert at NSA?
			Va gur ryringbef, gur rkgebireg ybbxf ng gur BGURE thl'f fubrf.
		</scr>
		<p>
			Applying the ROT13 function to this text enciphers the setup
			and deciphers the punchline:
		</p>
		<scr>
			Ubj pna lbh gryy na rkgebireg sebz na vagebireg ng AFN?
			In the elevators, the extrovert looks at the OTHER guy's shoes.
		</scr>
		<p>
			A further application of the ROT13 function
			will return the original text.
		</p>
	</description>
	<notes>
		<p>
			The ROT13 cipher should <b>never</b> be used for
			cryptographic purposes.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">round</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put round(steve) into bill
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the given value rounded towards the
			nearest integer. If the given value is an <a>dt:integer</a>,
			the given value is returned. Otherwise, the given value is rounded
			to the nearest integer. If the fractional part of the given value
			is exactly .5, the given value is rounded towards unsigned infinity,
			or away from zero.
		</p>
		<p>
			The following table illustrates the behavior of the <me/> function:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th>result</th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
		<p>
			If the given value is a <a>dt:complex</a>, the real and imaginary
			parts of the complex number are each rounded individually.
		</p>
	</description>
	<notes>
		<p>
			The following table shows the correspondences among the
			various <mv>roundingMethod</mv>s, rounding functions,
			and division operators:
		</p>
		<table>
			<tr>
				<th><code>rounding</code> parameter</th>
				<th>function</th>
				<th>operator</th>
				<th><code>java.math.RoundingMode</code></th>
			</tr>
			<tr>
				<td><code>to ceiling</code></td>
				<td><a>fn:ceil</a></td>
				<td></td>
				<td><code>CEILING</code></td>
			</tr>
			<tr>
				<td><code>to floor</code></td>
				<td><a>fn:floor</a></td>
				<td><a>op:div</a> / <a>op:mod</a></td>
				<td><code>FLOOR</code></td>
			</tr>
			<tr>
				<td><code>up</code> / <code>to infinity</code></td>
				<td><a>fn:aug</a></td>
				<td></td>
				<td><code>UP</code></td>
			</tr>
			<tr>
				<td><code>down</code> / <code>to zero</code></td>
				<td><a>fn:trunc</a></td>
				<td><a>op:quot</a> / <a>op:rem</a></td>
				<td><code>DOWN</code></td>
			</tr>
			<tr>
				<td><code>to nearest</code></td>
				<td><a>fn:round</a></td>
				<td></td>
				<td><code>HALF_UP</code></td>
			</tr>
			<tr>
				<td><code>to even</code></td>
				<td><a>fn:rint</a></td>
				<td></td>
				<td><code>HALF_EVEN</code></td>
			</tr>
		</table>
		<p>
			The following table illustrates the behavior of the rounding
			functions side-by-side:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th><a>fn:ceil</a></th>
				<th><a>fn:floor</a></th>
				<th><a>fn:aug</a></th>
				<th><a>fn:trunc</a></th>
				<th><a>fn:round</a></th>
				<th><a>fn:rint</a></th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
	</notes>
	<see-also>
		fn:ceil, fn:floor, fn:aug, fn:trunc, fn:rint
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">rpad</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>,
			<mv>length</mv><opt>, <mv>padding</mv></opt> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>,
			<mv>length</mv><opt>, <mv>padding</mv></opt> )
		</syn>
		<p>
			<mv>String</mv> and <mv>padding</mv> yield any <a>dt:string</a>s.
			<mv>Length</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function appends the specified <mv>padding</mv> to the
			specified <mv>string</mv> until the resulting string is longer
			than the specified <mv>length</mv>, then returns the leftmost
			<mv>length</mv> characters of the resulting string. In other words,
			the string is padded on the right to be aligned to the left. If no
			<mv>padding</mv> is specified, spaces are used.
		</p>
	</description>
	<notes>
		<p>
			If <mv>length</mv> is zero or negative, <a>cn:empty</a> is returned.
			If <mv>length</mv> is shorter than the specified <mv>string</mv>,
			only the leftmost <mv>length</mv> characters of the original
			<mv>string</mv> are returned.
		</p>
	</notes>
	<see-also>
		fn:lpad, fn:cpad
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">rsr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put rsr(2,3,6) -- yields 1
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the reciprocal of the sum
			of the reciprocals of its arguments.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
		<p>
			One possible application of this function is in electronics.
			The <a>fn:rsr</a> of a list of resistances is equal to the
			equivalent resistance of resistors in parallel.
			The <a>fn:rsr</a> of a list of capacitances is equal to the
			equivalent capacitance of capacitors in series.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">rtrim</name>
	<syntax>
		<syn>
			the <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			put rtrim("  Hello, world!  ") -- yields "  Hello, world!"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function trims all spaces, tabs, line breaks, control
			characters, line separators, and paragraph separators from the
			end of the given <a>dt:string</a> and returns the trimmed string.
		</p>
	</description>
	<see-also>
		fn:trim, fn:ltrim
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">sec</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the sec of 2 -- yields -2.402998
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the secant of the angle that
			is passed to it. The angle must be expressed in radians.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			Radians can be converted to degrees with the <a>fn:toDegrees</a>
			function, or by multiplying by 180 and dividing by <a>cn:pi</a>.
			Degrees can be converted to radians with the <a>fn:toRadians</a>
			function, or by multiplying by <a>cn:pi</a> and dividing by 180.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">sech</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the sech of 2 -- yields 0.265802
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the hyperbolic secant of the value
			that is passed to it.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">seconds</name>
	<name dialects="xn,oxn,hyp" modules="oxns">secs</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put (the seconds-startTime) into runTime
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns an integer representing the number
			of seconds since midnight, January 1, 1904, known as the
			Mac OS epoch.
		</p>
	</description>
	<see-also>
		cm:convert, fn:date, fn:dateItems, fn:ticks, fn:time
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">sgn</name>
	<name dialects="xn,oxn" modules="oxns">signum</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<description>
		<p>
			If its argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			the <me/> function returns -1 if the specified numeric value is
			negative, 1 if the specified numeric value is positive, 0 if the
			specified numeric value is zero, and <a>cn:NaN</a> if the specified
			numeric value is <a>cn:NaN</a>.
		</p>
		<p>
			If its argument is a <a>dt:complex</a>, the <me/> function returns
			a <a>dt:complex</a> with the same complex argument but an absolute
			value of 1. For example, <code><me/>(3,4)</code> returns
			<code>0.6,0.8</code>.
		</p>
	</description>
	<notes>
		<p>
			For nonzero values of <mv>n</mv>, <code><me/>(<mv>n</mv>) =
			<mv>n</mv> / <a>fn:abs</a>(<mv>n</mv>)</code>.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">sin</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the sin of 2 -- yields 0.909297
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the sine of the angle that
			is passed to it. The angle must be expressed in radians.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			Radians can be converted to degrees with the <a>fn:toDegrees</a>
			function, or by multiplying by 180 and dividing by <a>cn:pi</a>.
			Degrees can be converted to radians with the <a>fn:toRadians</a>
			function, or by multiplying by <a>cn:pi</a> and dividing by 180.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">sinh</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the sinh of 2 -- yields 3.626860
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the hyperbolic sine of the value
			that is passed to it.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">sqrt</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put sqrt(opposite^2 + adjacent^2) into hypotenuse
		</scr>
	</examples>
	<description>
		<p>
			The <a>fn:sqrt</a> function returns the square root of its argument.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the <a>dt:integer</a> or
			<a>dt:number</a> is negative, <a>cn:NaN</a> is returned.
			To get a <a>dt:complex</a> result, convert the argument to a
			<a>dt:complex</a>.
		</p>
		<p>
			If the argument is a <a>dt:complex</a>, a <a>dt:complex</a>
			is returned.
		</p>
	</description>
	<see-also>
		fn:cbrt
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">sstddev</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			get sstddev(1,2,3,4)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the sample standard deviation
			of a list of numeric values passed to it.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:stddev, fn:svariance
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">strcmp</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields a <a>dt:string</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <a>fn:strcmp</a> function compares the two given
			<a>dt:string</a>s by Unicode code point. If the first string
			comes before the second, a negative <a>dt:integer</a> is returned.
			If the first string comes after the second, a positive
			<a>dt:integer</a> is returned. If the two strings are equal,
			<a>cn:zero</a> is returned.
		</p>
		<p>
			The <a>fn:strcmp</a> function is case-insensitive. For a
			case-sensitive version of this function, see <a>fn:csStrcmp</a>.
			For a regular expression-based version of this function, see
			<a>fn:regMatch</a>.
		</p>
	</description>
	<see-also>
		fn:csStrcmp, fn:regMatch, fn:trMatch
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">substr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>,
			<mv>offset</mv><opt>, <mv>length</mv></opt> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>,
			<mv>offset</mv><opt>, <mv>length</mv></opt> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Offset</mv> and
			<mv>length</mv> yield <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <mv>length</mv> characters of the
			specified <mv>string</mv> starting at the specified <mv>offset</mv>.
			The first character of the string is at offset 1.
		</p>
		<p>
			If no <mv>length</mv> is specified, all characters of the string
			starting at the specified <mv>offset</mv> are returned.
		</p>
	</description>
	<notes>
		<p>
			If <mv>length</mv> is zero or negative, or <mv>offset</mv> is
			greater than the length of the <mv>string</mv>, <a>cn:empty</a>
			is returned. If <mv>offset</mv> is zero or negative, the leftmost
			<mv>length</mv>+<mv>offset</mv>-1 characters of the <mv>string</mv>
			are returned.
		</p>
	</notes>
	<see-also>
		fn:mid, fn:substring
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">substring</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>,
			<mv>begin</mv><opt>, <mv>end</mv></opt> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>,
			<mv>begin</mv><opt>, <mv>end</mv></opt> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Begin</mv> and
			<mv>end</mv> yield <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <mv>end</mv>-<mv>begin</mv> characters
			of the specified <mv>string</mv> starting at <mv>begin</mv>. The
			first character of the string is at offset 1.
		</p>
		<p>
			If no <mv>end</mv> is specified, all characters of the string
			starting at <mv>begin</mv> are returned.
		</p>
	</description>
	<notes>
		<p>
			If <mv>end</mv> is less than or equal to <mv>begin</mv>,
			<a>cn:empty</a> is returned.
		</p>
	</notes>
	<see-also>
		fn:mid, fn:substr
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">sum</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			get sum(1,2,3,4)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the sum of a list of numeric values
			passed to it.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:+</a> operator.
		</p>
	</notes>
	<see-also>
		op:+, fn:product, fn:pow
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">svariance</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:integers</a>, <a>dt:numbers</a>, or <a>dt:complexes</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			get svariance(1,2,3,4)
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the sample variance of a list
			of numeric values passed to it.
		</p>
		<p>
			If all the values are <a>dt:integer</a>s or <a>dt:number</a>s,
			a <a>dt:number</a> is returned. If any value is a <a>dt:complex</a>,
			a <a>dt:complex</a> is returned.
		</p>
	</description>
	<see-also>
		fn:variance, fn:sstddev
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">systemName</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the systemName
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the name of the operating system.
			You might use this to determine whether a script will run correctly
			under that operating system.
		</p>
	</description>
	<notes>
		<p>
			OpenXION gets the value of this function from the
			<code>os.name</code> system property.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security key
			is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">systemVersion</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the systemVersion
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the version of the operating system.
			You might use this to determine whether a script will run correctly
			under that version of the operating system.
		</p>
	</description>
	<notes>
		<p>
			In HyperTalk, the resulting value of this function is a <a>dt:number</a>.
			In XION, the resulting value of this function cannot be guaranteed
			to be anything other than a <a>dt:string</a>.
		</p>
		<p>
			OpenXION gets the value of this function from the
			<code>os.version</code> system property.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security key
			is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">tail</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns all but the first element of a list.
		</p>
	</description>
	<see-also>
		fn:head
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">tan</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the tan of 2 -- yields -2.185040
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the tangent of the angle
			that is passed to it. The angle must be expressed in radians.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
	<notes>
		<p>
			Radians can be converted to degrees with the <a>fn:toDegrees</a>
			function, or by multiplying by 180 and dividing by <a>cn:pi</a>.
			Degrees can be converted to radians with the <a>fn:toRadians</a>
			function, or by multiplying by <a>cn:pi</a> and dividing by 180.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">tanh</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<scr>
			put the tanh of 2 -- yields 0.964027
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the hyperbolic tangent of the value
			that is passed to it.
		</p>
		<p>
			If the argument is an <a>dt:integer</a> or a <a>dt:number</a>,
			a <a>dt:number</a> is returned. If the argument is a
			<a>dt:complex</a>, a <a>dt:complex</a> is returned.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">tcase</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function converts the specified <a>dt:string</a> to
			title case and returns the resulting <a>dt:string</a>. Letters
			are converted to lowercase if they are preceded by a letter, and
			converted to uppercase if they are preceded by a non-letter.
			For example, <code>tcase("Hello, my name is Rebecca. But you can
			call me Beckie.") = "Hello, My Name Is Rebecca. But You Can Call
			Me Beckie."</code>.
		</p>
	</description>
	<see-also>
		fn:ucase, fn:lcase
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">theta</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>
			or a <a>dt:number</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put theta(bill, steve) into andy
		</scr>
	</examples>
	<description>
		<p>
			The <a>fn:theta</a> function returns the angle, in radians,
			of the specified coordinates from the positive x-axis. The
			first argument is the x coordinate, and the second argument
			is the y coordinate.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to the <a>fn:atan2</a> function,
			but the arguments are in opposite order. It is also similar
			to the <a>fn:arg</a> function, but it takes two arguments
			rather than one.
		</p>
	</notes>
	<see-also>
		fn:atan2, fn:arg, fn:xcoord, fn:ycoord, fn:radius
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">ticks</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the ticks into dog
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the number of ticks (sixtieths of
			a second) since an implementation-specific reference point in time.
		</p>
	</description>
	<notes>
		<p>
			In HyperTalk, the reference point is the last time the computer
			was turned on or restarted. In OpenXION 1.3 and earlier, the
			reference point is roughly the release date of the interpreter.
			In OpenXION 1.4 and later, the reference point is the time when
			the JVM was started. The XION Scripting Language Standard states
			only that the reference point must remain constant during the
			same instance of the interpreter program.
		</p>
	</notes>
	<see-also>
		fn:date, fn:dateItems, fn:seconds, fn:time
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">time</name>
	<syntax>
		<syn>
			the <opt><mv>modifier</mv></opt> <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
		<p>
			<mv>Modifier</mv> is <a>kw:short</a>, <a>kw:abbreviated</a>,
			<a>kw:long</a>, or <a>kw:English</a>. The default is <a>kw:short</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put the time
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a <a>dt:date</a> representing the
			current time. There are three forms of the <me/> function:
		</p>
		<table>
			<tr>
				<td><code>the short time</code> or <code>the abbrev time</code></td>
				<td><code>12.34 PM</code></td>
			</tr>
			<tr>
				<td><code>the long time</code></td>
				<td><code>12.34.56 PM</code></td>
			</tr>
			<tr>
				<td><code>the English time</code></td>
				<td><code>12:34:56 PM</code></td>
			</tr>
		</table>
	</description>
	<notes>
		<p>
			The format of the time is dependent on the current locale. This is
			important if you want to write scripts that work anywhere without
			modification. You cannot assume that the <me/> function will always
			return a time in the same format.
		</p>
		<p>
			To prevent issues caused by differing local time formats, use the
			<a>fn:seconds</a> or the <a>fn:dateItems</a> to store and perform
			calculations with dates and times.
		</p>
	</notes>
	<see-also>
		cm:convert, fn:date, fn:dateItems, fn:seconds, fn:ticks
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">toDeg</name>
	<name dialects="xn,oxn" modules="oxns">toDegrees</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield
			<a>dt:integer</a>s or <a>dt:number</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the value passed to it
			converted from radians to degrees.
		</p>
		<p>
			The formula for this function is:
		</p>
		<p>
			<code><me/>(<mv>angle</mv>) = <mv>angle</mv>*180/<a>cn:pi</a></code>
		</p>
		<p>
			The <me/> function is faster, more accurate, and easier
			to remember than using the above formula.
		</p>
	</description>
	<see-also>
		fn:toRadians
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">toRad</name>
	<name dialects="xn,oxn" modules="oxns">toRadians</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield
			<a>dt:integer</a>s or <a>dt:number</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the value passed to it
			converted from degrees to radians.
		</p>
		<p>
			The formula for this function is:
		</p>
		<p>
			<code><me/>(<mv>angle</mv>) = <mv>angle</mv>*<a>cn:pi</a>/180</code>
		</p>
		<p>
			The <me/> function is faster, more accurate, and easier
			to remember than using the above formula.
		</p>
	</description>
	<see-also>
		fn:toDegrees
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">trim</name>
	<syntax>
		<syn>
			the <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<examples>
		<scr>
			put trim("  Hello, world!  ") -- yields "Hello, world!"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function trims all spaces, tabs, line breaks, control
			characters, line separators, and paragraph separators from the
			beginning and end of the given <a>dt:string</a> and returns
			the trimmed string.
		</p>
	</description>
	<see-also>
		fn:ltrim, fn:rtrim
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">trunc</name>
	<name dialects="xn,oxn" modules="oxns">int</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:integer</a>s,
			<a>dt:number</a>s, or <a>dt:complex</a>es.
		</p>
	</syntax>
	<examples>
		<p>
			<code>put <me/>(steve) into bill</code>
		</p>
	</examples>
	<description>
		<p>
			The <me/> function returns the given value rounded towards zero.
			If the given value is an <a>dt:integer</a>, the given value is
			returned. Otherwise, the given value is rounded to the integer
			with the next lowest absolute value and the same sign. In other
			words, the <me/> function returns the integer part of the given
			value, discarding the fractional part, regardless of sign.
		</p>
		<p>
			The following table illustrates the behavior of the <me/> function:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th>result</th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
		<p>
			If the given value is a <a>dt:complex</a>, the real and imaginary
			parts of the complex number are each rounded individually.
		</p>
	</description>
	<notes>
		<p>
			The following table shows the correspondences among the
			various <mv>roundingMethod</mv>s, rounding functions,
			and division operators:
		</p>
		<table>
			<tr>
				<th><code>rounding</code> parameter</th>
				<th>function</th>
				<th>operator</th>
				<th><code>java.math.RoundingMode</code></th>
			</tr>
			<tr>
				<td><code>to ceiling</code></td>
				<td><a>fn:ceil</a></td>
				<td></td>
				<td><code>CEILING</code></td>
			</tr>
			<tr>
				<td><code>to floor</code></td>
				<td><a>fn:floor</a></td>
				<td><a>op:div</a> / <a>op:mod</a></td>
				<td><code>FLOOR</code></td>
			</tr>
			<tr>
				<td><code>up</code> / <code>to infinity</code></td>
				<td><a>fn:aug</a></td>
				<td></td>
				<td><code>UP</code></td>
			</tr>
			<tr>
				<td><code>down</code> / <code>to zero</code></td>
				<td><a>fn:trunc</a></td>
				<td><a>op:quot</a> / <a>op:rem</a></td>
				<td><code>DOWN</code></td>
			</tr>
			<tr>
				<td><code>to nearest</code></td>
				<td><a>fn:round</a></td>
				<td></td>
				<td><code>HALF_UP</code></td>
			</tr>
			<tr>
				<td><code>to even</code></td>
				<td><a>fn:rint</a></td>
				<td></td>
				<td><code>HALF_EVEN</code></td>
			</tr>
		</table>
		<p>
			The following table illustrates the behavior of the rounding
			functions side-by-side:
		</p>
		<table>
			<tr>
				<th>argument</th>
				<th><a>fn:ceil</a></th>
				<th><a>fn:floor</a></th>
				<th><a>fn:aug</a></th>
				<th><a>fn:trunc</a></th>
				<th><a>fn:round</a></th>
				<th><a>fn:rint</a></th>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.75</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.5</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>1.25</td>
				<td>2</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.25</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.5</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>-0.75</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
				<td>0</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.25</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-1</td>
				<td>-1</td>
			</tr>
			<tr>
				<td>-1.5</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-1.75</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
				<td>-1</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
			<tr>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
				<td>-2</td>
			</tr>
		</table>
	</notes>
	<see-also>
		fn:ceil, fn:floor, fn:aug, fn:round, fn:rint, fn:frac
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">ucase</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function converts all the letters in the specified
			<a>dt:string</a> to uppercase and returns the resulting
			<a>dt:string</a>. For example, <code>ucase("Hello, my name is
			Rebecca. But you can call me Beckie.") = "HELLO, MY NAME IS
			REBECCA. BUT YOU CAN CALL ME BECKIE."</code>.
		</p>
	</description>
	<see-also>
		fn:tcase, fn:lcase
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">uniToBin</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield a <a>dt:string</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put the uniToBin of "αβ" -- yields "CEB1CEB2"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a <a>dt:binary</a> of the string
			passed to it encoded in the UTF-8 text encoding.
		</p>
	</description>
	<see-also>
		fn:binToChar, fn:binToUni, fn:charToBin, fn:charToNum,
		fn:numToChar, fn:numToUni, fn:uniToNum
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">uniToNum</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield a character.
		</p>
	</syntax>
	<examples>
		<scr>
			put the uniToNum of "α" -- yields 945
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the Unicode code point
			of the character passed to it.
		</p>
	</description>
	<notes>
		<p>
			If more than one character is passed,
			<me/> returns the value of the first character.
		</p>
	</notes>
	<see-also>
		fn:binToChar, fn:binToUni, fn:charToBin, fn:charToNum,
		fn:numToChar, fn:numToUni, fn:uniToBin
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">value</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield any <a>dt:string</a>.
		</p>
	</syntax>
	<examples>
		<scr>
			put the value of myFormula into myResult
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function evaluates the string passed to it
			as an XION expression. The string is evaluated as if it were
			inserted inside parentheses in place of the <me/> function call.
		</p>
		<p>
			If the string does not form a single valid expression,
			the string itself is returned.
		</p>
	</description>
	<scripts>
		<p>
			The following example demonstrates the <me/> function:
		</p>
		<scr>
			on demoValue
			  put "3 + 4" into expression
			  put expression -- yields "3 + 4"
			  put the value of expression -- yields 7
			end demoValue
		</scr>
	</scripts>
	<security>
		<p>
			To evaluate arbitrary XION expressions with this function,
			OpenXION's security settings must allow the
			<code>DO_AND_VALUE</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cs:do
	</see-also>
</function>

<function>
	<name dialects="xn,oxn,hyp" modules="oxns">version</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield some object
			or the name of some component that has a version number.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the version number of an object
			or component.
		</p>
	</description>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security
			key is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">xcoord</name>
	<syntax>
		<syn>
			the <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>
			or a <a>dt:number</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the x coordinate of the specified
			polar coordinates. The first argument is the distance from the
			origin and the second argument is the angle from the positive
			x-axis in radians.
		</p>
		<p>
			The formula for the <me/> function is:
		</p>
		<p>
			<code><me/>(<mv>r</mv>, <mv>th</mv>) = <mv>r</mv>*cos(<mv>th</mv>)</code>
		</p>
		<p>
			The <me/> function is faster and more accurate than using
			the above formula.
		</p>
	</description>
	<see-also>
		fn:ycoord, fn:radius, fn:theta
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">xionName</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the xionName
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the name of the XION interpreter.
			You might use this to determine whether a script will run correctly
			under that interpreter.
		</p>
	</description>
	<notes>
		<p>
			OpenXION returns the <a>dt:string</a> <code>"OpenXION"</code>.
		</p>
	</notes>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">xionVersion</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the xionVersion
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the version of the XION interpreter.
			You might use this to determine whether a script will run correctly
			under that version of the interpreter.
		</p>
	</description>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">xor</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:list</a>s
			of <a>dt:booleans</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if an odd
			number of its arguments are <a>cn:true</a>. If an even number
			of arguments are <a>cn:true</a>, it returns <a>cn:false</a>.
		</p>
	</description>
	<notes>
		<p>
			This is the infinite-arity version of the <a>op:xor</a> operator.
		</p>
	</notes>
	<see-also>
		op:xor, op:^^^, fn:and, fn:or
	</see-also>
</function>

<function>
	<name dialects="xn,oxn" modules="oxns">ycoord</name>
	<syntax>
		<syn>
			the <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields an <a>dt:integer</a>
			or a <a>dt:number</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the y coordinate of the specified
			polar coordinates. The first argument is the distance from the
			origin and the second argument is the angle from the positive
			x-axis in radians.
		</p>
		<p>
			The formula for the <me/> function is:
		</p>
		<p>
			<code><me/>(<mv>r</mv>, <mv>th</mv>) = <mv>r</mv>*sin(<mv>th</mv>)</code>
		</p>
		<p>
			The <me/> function is faster and more accurate than
			using the above formula.
		</p>
	</description>
	<see-also>
		fn:xcoord, fn:radius, fn:theta
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">atob</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>text</mv>
		</syn>
		<syn>
			<opt>the</opt> <me/> of ( <mv>text</mv>, <mv>algorithm</mv> )
		</syn>
		<syn>
			<me/> ( <mv>text</mv><opt>, <mv>algorithm</mv></opt> )
		</syn>
		<p>
			<mv>Text</mv> yields a <a>dt:string</a>. <mv>Algorithm</mv>
			yields the name of an ASCII-to-binary decoding algorithm.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function decodes ASCII <mv>text</mv> back into
			binary data using the specified <mv>algorithm</mv>.
			If the <mv>algorithm</mv> is not specified, <code>base64</code>
			is the default.
		</p>
		<p>
			The <me/> function supports the following <mv>algorithm</mv>s:
		</p>
		<table>
			<tr>
				<td><code>b64</code>, <code>base64</code></td>
				<td>
					The Base64 encoding scheme. Must provide the raw text
					without headers or footers. Whitespace is ignored.
				</td>
			</tr>
			<tr>
				<td><code>uu</code>, <code>uud</code>, <code>uudecode</code></td>
				<td>
					The <code>uuencode</code>/<code>uudecode</code> encoding
					scheme. Headers and footers are optional; if the header
					is provided, the footer must be as well, and vice versa.
				</td>
			</tr>
			<tr>
				<td><code>xx</code>, <code>xxd</code>, <code>xxdecode</code></td>
				<td>
					The <code>xxencode</code>/<code>xxdecode</code> encoding
					scheme. Headers and footers are optional; if the header
					is provided, the footer must be as well, and vice versa.
				</td>
			</tr>
			<tr>
				<td><code>hqx</code>, <code>binhex</code></td>
				<td>
					The encoding scheme used by BinHex, including run-length
					encoding. The beginning and ending colons are optional.
					Must provide the raw text without headers. Returns the
					raw binary data as encoded (separating out metadata, forks,
					and CRCs must be done manually).
				</td>
			</tr>
			<tr>
				<td><code>a85</code>, <code>ascii85</code></td>
				<td>
					The ASCII85 encoding scheme. The <code>&lt;~</code> and
					<code>~&gt;</code> markers are optional. The <code>y</code>
					character for a string of four spaces is supported.
				</td>
			</tr>
			<tr>
				<td><code>k85</code>, <code>kreative85</code></td>
				<td>
					A variant of the ASCII85 encoding scheme that uses a
					different alphabet. Must provide the raw text without
					markers.
				</td>
			</tr>
			<tr>
				<td><code>l85</code>, <code>legacy85</code></td>
				<td>
					Something Resplendence calls Base85.
					Don't use this.
				</td>
			</tr>
		</table>
	</description>
	<see-also>
		fn:btoa
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.4" modules="onxe&ge;1.4">bitMingle</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			Both <mv>expression</mv>s yield <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns an <a>dt:integer</a> produced by
			alternating the bits of the two's complement representations of
			the two given <a>dt:integer</a>s. For example,
			<code>bitMingle(15,0)</code> will produce binary 10101010 or
			decimal 170, while <code>bitMingle(0,15)</code> will produce
			binary 01010101 or decimal 85.
		</p>
		<p>
			If both given values are positive, the result will be positive.
			If both given values are negative, the result will be negative.
			If one value is positive and the other value is negative,
			<a>cn:NaN</a> is returned.
		</p>
	</description>
	<see-also>
		fn:bitSelect, op:bitand, op:bitor, op:bitxor
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.4" modules="onxe&ge;1.4">bitSelect</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>expression</mv> )
		</syn>
		<p>
			Both <mv>expression</mv>s yield <a>dt:integer</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function takes the bits from the first given
			<a>dt:integer</a> corresponding to the set bits in the
			second <a>dt:integer</a> and packs them to the right.
			For example, <code>bitSelect(179,201)</code> (10110011
			and 11001001 in binary) will produce 9 (1001 in binary).
		</p>
		<p>
			If both given values are negative, the result will be negative.
			Otherwise, the result will be positive.
		</p>
	</description>
	<see-also>
		fn:bitMingle, op:bitand, op:bitor, op:bitxor
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">btoa</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>data</mv>
		</syn>
		<syn>
			<opt>the</opt> <me/> of ( <mv>data</mv>, <mv>algorithm</mv> )
		</syn>
		<syn>
			<me/> ( <mv>data</mv><opt>, <mv>algorithm</mv></opt> )
		</syn>
		<p>
			<mv>Data</mv> yields a <a>dt:binary</a>. <mv>Algorithm</mv>
			yields the name of a binary-to-ASCII encoding algorithm.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function encodes binary <mv>data</mv> into ASCII text
			using the specified <mv>algorithm</mv>. If the <mv>algorithm</mv>
			is not specified, <code>base64</code> is the default.
		</p>
		<p>
			The <me/> function supports the following <mv>algorithm</mv>s:
		</p>
		<table>
			<tr>
				<td><code>b64</code>, <code>base64</code></td>
				<td>
					The Base64 encoding scheme. Does not produce any headers,
					footers, or line breaks; they must be added manually.
				</td>
			</tr>
			<tr>
				<td><code>uu</code>, <code>uue</code>, <code>uuencode</code></td>
				<td>
					The <code>uuencode</code>/<code>uudecode</code> encoding
					scheme. Produces line breaks every 45 bytes. Does not
					produce any headers or footers; they must be added manually.
				</td>
			</tr>
			<tr>
				<td><code>xx</code>, <code>xxe</code>, <code>xxencode</code></td>
				<td>
					The <code>xxencode</code>/<code>xxdecode</code> encoding
					scheme. Produces line breaks every 45 bytes. Does not
					produce any headers or footers; they must be added manually.
				</td>
			</tr>
			<tr>
				<td><code>hqx</code>, <code>binhex</code></td>
				<td>
					The encoding scheme used by BinHex, including run-length
					encoding. Produces the beginning and ending colons.
					Does not produce any headers; they must be added manually.
					Assumes binary data is already structured appropriately
					(metadata, resource fork, and CRCs must be added manually).
				</td>
			</tr>
			<tr>
				<td><code>a85</code>, <code>ascii85</code></td>
				<td>
					The ASCII85 encoding scheme. Produces the <code>&lt;~</code>
					and <code>~&gt;</code> markers. Does not produce the
					<code>y</code> character for a string of four spaces.
				</td>
			</tr>
			<tr>
				<td><code>k85</code>, <code>kreative85</code></td>
				<td>
					A variant of the ASCII85 encoding scheme that uses a
					different alphabet. Does not produce any markers.
				</td>
			</tr>
			<tr>
				<td><code>l85</code>, <code>legacy85</code></td>
				<td>
					Something Resplendence calls Base85.
					Don't use this.
				</td>
			</tr>
		</table>
	</description>
	<see-also>
		fn:atob
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.4" modules="oxne&ge;1.4">getenv</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the value of the specified
			environment variable. If no environment variable is specified,
			the <me/> function returns a list of environment variable names.
		</p>
	</description>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security key
			is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="oxn,hyp" modules="oxne">heapSpace</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the heapSpace into heapOFun
		</scr>
	</examples>
	<description>
		<p>
			In OpenXION, the <me/> function returns the number of bytes
			of heap space currently available to the Java virtual machine.
		</p>
		<p>
			In HyperTalk, the <me/> function returns the number of bytes
			of heap space currently available to HyperCard.
		</p>
	</description>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security key
			is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="oxn" modules="oxne">htmlDecode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function decodes any HTML entities in the specified
			string and returns the decoded string.
		</p>
		<p>
			The <me/> function recognizes the sequences
			<code>&amp;#<mv>dec</mv>;</code> and
			<code>&amp;#x<mv>hex</mv>;</code> where <mv>dec</mv>
			is a decimal integer and <mv>hex</mv> is a hexadecimal
			integer representing a Unicode code point, as
			well as the following named sequences:
		</p>
		<table>
			<tr>
				<td><code>&amp;amp;</code></td>
				<td>&amp;</td>
				<td><code>&amp;Ucirc;</code></td>
				<td>&#x00DB;</td>
				<td><code>&amp;Upsilon;</code></td>
				<td>&#x03A5;</td>
				<td><code>&amp;alefsym;</code></td>
				<td>&#x2135;</td>
			</tr>
			<tr>
				<td><code>&amp;lt;</code></td>
				<td>&lt;</td>
				<td><code>&amp;Uuml;</code></td>
				<td>&#x00DC;</td>
				<td><code>&amp;Phi;</code></td>
				<td>&#x03A6;</td>
				<td><code>&amp;larr;</code></td>
				<td>&#x2190;</td>
			</tr>
			<tr>
				<td><code>&amp;gt;</code></td>
				<td>&gt;</td>
				<td><code>&amp;Yacute;</code></td>
				<td>&#x00DD;</td>
				<td><code>&amp;Chi;</code></td>
				<td>&#x03A7;</td>
				<td><code>&amp;uarr;</code></td>
				<td>&#x2191;</td>
			</tr>
			<tr>
				<td><code>&amp;quot;</code></td>
				<td>&quot;</td>
				<td><code>&amp;THORN;</code></td>
				<td>&#x00DE;</td>
				<td><code>&amp;Psi;</code></td>
				<td>&#x03A8;</td>
				<td><code>&amp;rarr;</code></td>
				<td>&#x2192;</td>
			</tr>
			<tr>
				<td><code>&amp;apos;</code></td>
				<td>&apos;</td>
				<td><code>&amp;szlig;</code></td>
				<td>&#x00DF;</td>
				<td><code>&amp;Omega;</code></td>
				<td>&#x03A9;</td>
				<td><code>&amp;darr;</code></td>
				<td>&#x2193;</td>
			</tr>
			<tr>
				<td><code>&amp;nbsp;</code></td>
				<td>&#x00A0;</td>
				<td><code>&amp;agrave;</code></td>
				<td>&#x00E0;</td>
				<td><code>&amp;alpha;</code></td>
				<td>&#x03B1;</td>
				<td><code>&amp;harr;</code></td>
				<td>&#x2194;</td>
			</tr>
			<tr>
				<td><code>&amp;iexcl;</code></td>
				<td>&#x00A1;</td>
				<td><code>&amp;aacute;</code></td>
				<td>&#x00E1;</td>
				<td><code>&amp;beta;</code></td>
				<td>&#x03B2;</td>
				<td><code>&amp;crarr;</code></td>
				<td>&#x21B5;</td>
			</tr>
			<tr>
				<td><code>&amp;cent;</code></td>
				<td>&#x00A2;</td>
				<td><code>&amp;acirc;</code></td>
				<td>&#x00E2;</td>
				<td><code>&amp;gamma;</code></td>
				<td>&#x03B3;</td>
				<td><code>&amp;lArr;</code></td>
				<td>&#x21D0;</td>
			</tr>
			<tr>
				<td><code>&amp;pound;</code></td>
				<td>&#x00A3;</td>
				<td><code>&amp;atilde;</code></td>
				<td>&#x00E3;</td>
				<td><code>&amp;delta;</code></td>
				<td>&#x03B4;</td>
				<td><code>&amp;uArr;</code></td>
				<td>&#x21D1;</td>
			</tr>
			<tr>
				<td><code>&amp;curren;</code></td>
				<td>&#x00A4;</td>
				<td><code>&amp;auml;</code></td>
				<td>&#x00E4;</td>
				<td><code>&amp;epsilon;</code></td>
				<td>&#x03B5;</td>
				<td><code>&amp;rArr;</code></td>
				<td>&#x21D2;</td>
			</tr>
			<tr>
				<td><code>&amp;yen;</code></td>
				<td>&#x00A5;</td>
				<td><code>&amp;aring;</code></td>
				<td>&#x00E5;</td>
				<td><code>&amp;zeta;</code></td>
				<td>&#x03B6;</td>
				<td><code>&amp;dArr;</code></td>
				<td>&#x21D3;</td>
			</tr>
			<tr>
				<td><code>&amp;brvbar;</code></td>
				<td>&#x00A6;</td>
				<td><code>&amp;aelig;</code></td>
				<td>&#x00E6;</td>
				<td><code>&amp;eta;</code></td>
				<td>&#x03B7;</td>
				<td><code>&amp;hArr;</code></td>
				<td>&#x21D4;</td>
			</tr>
			<tr>
				<td><code>&amp;sect;</code></td>
				<td>&#x00A7;</td>
				<td><code>&amp;ccedil;</code></td>
				<td>&#x00E7;</td>
				<td><code>&amp;theta;</code></td>
				<td>&#x03B8;</td>
				<td><code>&amp;forall;</code></td>
				<td>&#x2200;</td>
			</tr>
			<tr>
				<td><code>&amp;uml;</code></td>
				<td>&#x00A8;</td>
				<td><code>&amp;egrave;</code></td>
				<td>&#x00E8;</td>
				<td><code>&amp;iota;</code></td>
				<td>&#x03B9;</td>
				<td><code>&amp;part;</code></td>
				<td>&#x2202;</td>
			</tr>
			<tr>
				<td><code>&amp;copy;</code></td>
				<td>&#x00A9;</td>
				<td><code>&amp;eacute;</code></td>
				<td>&#x00E9;</td>
				<td><code>&amp;kappa;</code></td>
				<td>&#x03BA;</td>
				<td><code>&amp;exist;</code></td>
				<td>&#x2203;</td>
			</tr>
			<tr>
				<td><code>&amp;ordf;</code></td>
				<td>&#x00AA;</td>
				<td><code>&amp;ecirc;</code></td>
				<td>&#x00EA;</td>
				<td><code>&amp;lambda;</code></td>
				<td>&#x03BB;</td>
				<td><code>&amp;empty;</code></td>
				<td>&#x2205;</td>
			</tr>
			<tr>
				<td><code>&amp;laquo;</code></td>
				<td>&#x00AB;</td>
				<td><code>&amp;euml;</code></td>
				<td>&#x00EB;</td>
				<td><code>&amp;mu;</code></td>
				<td>&#x03BC;</td>
				<td><code>&amp;nabla;</code></td>
				<td>&#x2207;</td>
			</tr>
			<tr>
				<td><code>&amp;not;</code></td>
				<td>&#x00AC;</td>
				<td><code>&amp;igrave;</code></td>
				<td>&#x00EC;</td>
				<td><code>&amp;nu;</code></td>
				<td>&#x03BD;</td>
				<td><code>&amp;isin;</code></td>
				<td>&#x2208;</td>
			</tr>
			<tr>
				<td><code>&amp;shy;</code></td>
				<td>&#x00AD;</td>
				<td><code>&amp;iacute;</code></td>
				<td>&#x00ED;</td>
				<td><code>&amp;xi;</code></td>
				<td>&#x03BE;</td>
				<td><code>&amp;notin;</code></td>
				<td>&#x2209;</td>
			</tr>
			<tr>
				<td><code>&amp;reg;</code></td>
				<td>&#x00AE;</td>
				<td><code>&amp;icirc;</code></td>
				<td>&#x00EE;</td>
				<td><code>&amp;omicron;</code></td>
				<td>&#x03BF;</td>
				<td><code>&amp;ni;</code></td>
				<td>&#x220B;</td>
			</tr>
			<tr>
				<td><code>&amp;macr;</code></td>
				<td>&#x00AF;</td>
				<td><code>&amp;iuml;</code></td>
				<td>&#x00EF;</td>
				<td><code>&amp;pi;</code></td>
				<td>&#x03C0;</td>
				<td><code>&amp;prod;</code></td>
				<td>&#x220F;</td>
			</tr>
			<tr>
				<td><code>&amp;deg;</code></td>
				<td>&#x00B0;</td>
				<td><code>&amp;eth;</code></td>
				<td>&#x00F0;</td>
				<td><code>&amp;rho;</code></td>
				<td>&#x03C1;</td>
				<td><code>&amp;sum;</code></td>
				<td>&#x2211;</td>
			</tr>
			<tr>
				<td><code>&amp;plusmn;</code></td>
				<td>&#x00B1;</td>
				<td><code>&amp;ntilde;</code></td>
				<td>&#x00F1;</td>
				<td><code>&amp;sigmaf;</code></td>
				<td>&#x03C2;</td>
				<td><code>&amp;minus;</code></td>
				<td>&#x2212;</td>
			</tr>
			<tr>
				<td><code>&amp;sup2;</code></td>
				<td>&#x00B2;</td>
				<td><code>&amp;ograve;</code></td>
				<td>&#x00F2;</td>
				<td><code>&amp;sigma;</code></td>
				<td>&#x03C3;</td>
				<td><code>&amp;lowast;</code></td>
				<td>&#x2217;</td>
			</tr>
			<tr>
				<td><code>&amp;sup3;</code></td>
				<td>&#x00B3;</td>
				<td><code>&amp;oacute;</code></td>
				<td>&#x00F3;</td>
				<td><code>&amp;tau;</code></td>
				<td>&#x03C4;</td>
				<td><code>&amp;radic;</code></td>
				<td>&#x221A;</td>
			</tr>
			<tr>
				<td><code>&amp;acute;</code></td>
				<td>&#x00B4;</td>
				<td><code>&amp;ocirc;</code></td>
				<td>&#x00F4;</td>
				<td><code>&amp;upsilon;</code></td>
				<td>&#x03C5;</td>
				<td><code>&amp;prop;</code></td>
				<td>&#x221D;</td>
			</tr>
			<tr>
				<td><code>&amp;micro;</code></td>
				<td>&#x00B5;</td>
				<td><code>&amp;otilde;</code></td>
				<td>&#x00F5;</td>
				<td><code>&amp;phi;</code></td>
				<td>&#x03C6;</td>
				<td><code>&amp;infin;</code></td>
				<td>&#x221E;</td>
			</tr>
			<tr>
				<td><code>&amp;para;</code></td>
				<td>&#x00B6;</td>
				<td><code>&amp;ouml;</code></td>
				<td>&#x00F6;</td>
				<td><code>&amp;chi;</code></td>
				<td>&#x03C7;</td>
				<td><code>&amp;ang;</code></td>
				<td>&#x2220;</td>
			</tr>
			<tr>
				<td><code>&amp;middot;</code></td>
				<td>&#x00B7;</td>
				<td><code>&amp;divide;</code></td>
				<td>&#x00F7;</td>
				<td><code>&amp;psi;</code></td>
				<td>&#x03C8;</td>
				<td><code>&amp;and;</code></td>
				<td>&#x2227;</td>
			</tr>
			<tr>
				<td><code>&amp;cedil;</code></td>
				<td>&#x00B8;</td>
				<td><code>&amp;oslash;</code></td>
				<td>&#x00F8;</td>
				<td><code>&amp;omega;</code></td>
				<td>&#x03C9;</td>
				<td><code>&amp;or;</code></td>
				<td>&#x2228;</td>
			</tr>
			<tr>
				<td><code>&amp;sup1;</code></td>
				<td>&#x00B9;</td>
				<td><code>&amp;ugrave;</code></td>
				<td>&#x00F9;</td>
				<td><code>&amp;thetasym;</code></td>
				<td>&#x03D1;</td>
				<td><code>&amp;cap;</code></td>
				<td>&#x2229;</td>
			</tr>
			<tr>
				<td><code>&amp;ordm;</code></td>
				<td>&#x00BA;</td>
				<td><code>&amp;uacute;</code></td>
				<td>&#x00FA;</td>
				<td><code>&amp;upsih;</code></td>
				<td>&#x03D2;</td>
				<td><code>&amp;cup;</code></td>
				<td>&#x222A;</td>
			</tr>
			<tr>
				<td><code>&amp;raquo;</code></td>
				<td>&#x00BB;</td>
				<td><code>&amp;ucirc;</code></td>
				<td>&#x00FB;</td>
				<td><code>&amp;piv;</code></td>
				<td>&#x03D6;</td>
				<td><code>&amp;int;</code></td>
				<td>&#x222B;</td>
			</tr>
			<tr>
				<td><code>&amp;frac14;</code></td>
				<td>&#x00BC;</td>
				<td><code>&amp;uuml;</code></td>
				<td>&#x00FC;</td>
				<td><code>&amp;ensp;</code></td>
				<td>&#x2002;</td>
				<td><code>&amp;there4;</code></td>
				<td>&#x2234;</td>
			</tr>
			<tr>
				<td><code>&amp;frac12;</code></td>
				<td>&#x00BD;</td>
				<td><code>&amp;yacute;</code></td>
				<td>&#x00FD;</td>
				<td><code>&amp;emsp;</code></td>
				<td>&#x2003;</td>
				<td><code>&amp;sim;</code></td>
				<td>&#x223C;</td>
			</tr>
			<tr>
				<td><code>&amp;frac34;</code></td>
				<td>&#x00BE;</td>
				<td><code>&amp;thorn;</code></td>
				<td>&#x00FE;</td>
				<td><code>&amp;thinsp;</code></td>
				<td>&#x2009;</td>
				<td><code>&amp;cong;</code></td>
				<td>&#x2245;</td>
			</tr>
			<tr>
				<td><code>&amp;iquest;</code></td>
				<td>&#x00BF;</td>
				<td><code>&amp;yuml;</code></td>
				<td>&#x00FF;</td>
				<td><code>&amp;zwnj;</code></td>
				<td>&#x200C;</td>
				<td><code>&amp;asymp;</code></td>
				<td>&#x2248;</td>
			</tr>
			<tr>
				<td><code>&amp;Agrave;</code></td>
				<td>&#x00C0;</td>
				<td><code>&amp;OElig;</code></td>
				<td>&#x0152;</td>
				<td><code>&amp;zwj;</code></td>
				<td>&#x200D;</td>
				<td><code>&amp;ne;</code></td>
				<td>&#x2260;</td>
			</tr>
			<tr>
				<td><code>&amp;Aacute;</code></td>
				<td>&#x00C1;</td>
				<td><code>&amp;oelig;</code></td>
				<td>&#x0153;</td>
				<td><code>&amp;lrm;</code></td>
				<td>&#x200E;</td>
				<td><code>&amp;equiv;</code></td>
				<td>&#x2261;</td>
			</tr>
			<tr>
				<td><code>&amp;Acirc;</code></td>
				<td>&#x00C2;</td>
				<td><code>&amp;Scaron;</code></td>
				<td>&#x0160;</td>
				<td><code>&amp;rlm;</code></td>
				<td>&#x200F;</td>
				<td><code>&amp;le;</code></td>
				<td>&#x2264;</td>
			</tr>
			<tr>
				<td><code>&amp;Atilde;</code></td>
				<td>&#x00C3;</td>
				<td><code>&amp;scaron;</code></td>
				<td>&#x0161;</td>
				<td><code>&amp;ndash;</code></td>
				<td>&#x2013;</td>
				<td><code>&amp;ge;</code></td>
				<td>&#x2265;</td>
			</tr>
			<tr>
				<td><code>&amp;Auml;</code></td>
				<td>&#x00C4;</td>
				<td><code>&amp;Yuml;</code></td>
				<td>&#x0178;</td>
				<td><code>&amp;mdash;</code></td>
				<td>&#x2014;</td>
				<td><code>&amp;sub;</code></td>
				<td>&#x2282;</td>
			</tr>
			<tr>
				<td><code>&amp;Aring;</code></td>
				<td>&#x00C5;</td>
				<td><code>&amp;fnof;</code></td>
				<td>&#x0192;</td>
				<td><code>&amp;lsquo;</code></td>
				<td>&#x2018;</td>
				<td><code>&amp;sup;</code></td>
				<td>&#x2283;</td>
			</tr>
			<tr>
				<td><code>&amp;AElig;</code></td>
				<td>&#x00C6;</td>
				<td><code>&amp;circ;</code></td>
				<td>&#x02C6;</td>
				<td><code>&amp;rsquo;</code></td>
				<td>&#x2019;</td>
				<td><code>&amp;nsub;</code></td>
				<td>&#x2284;</td>
			</tr>
			<tr>
				<td><code>&amp;Ccedil;</code></td>
				<td>&#x00C7;</td>
				<td><code>&amp;tilde;</code></td>
				<td>&#x02DC;</td>
				<td><code>&amp;sbquo;</code></td>
				<td>&#x201A;</td>
				<td><code>&amp;sube;</code></td>
				<td>&#x2286;</td>
			</tr>
			<tr>
				<td><code>&amp;Egrave;</code></td>
				<td>&#x00C8;</td>
				<td><code>&amp;Alpha;</code></td>
				<td>&#x0391;</td>
				<td><code>&amp;ldquo;</code></td>
				<td>&#x201C;</td>
				<td><code>&amp;supe;</code></td>
				<td>&#x2287;</td>
			</tr>
			<tr>
				<td><code>&amp;Eacute;</code></td>
				<td>&#x00C9;</td>
				<td><code>&amp;Beta;</code></td>
				<td>&#x0392;</td>
				<td><code>&amp;rdquo;</code></td>
				<td>&#x201D;</td>
				<td><code>&amp;oplus;</code></td>
				<td>&#x2295;</td>
			</tr>
			<tr>
				<td><code>&amp;Ecirc;</code></td>
				<td>&#x00CA;</td>
				<td><code>&amp;Gamma;</code></td>
				<td>&#x0393;</td>
				<td><code>&amp;bdquo;</code></td>
				<td>&#x201E;</td>
				<td><code>&amp;otimes;</code></td>
				<td>&#x2297;</td>
			</tr>
			<tr>
				<td><code>&amp;Euml;</code></td>
				<td>&#x00CB;</td>
				<td><code>&amp;Delta;</code></td>
				<td>&#x0394;</td>
				<td><code>&amp;dagger;</code></td>
				<td>&#x2020;</td>
				<td><code>&amp;perp;</code></td>
				<td>&#x22A5;</td>
			</tr>
			<tr>
				<td><code>&amp;Igrave;</code></td>
				<td>&#x00CC;</td>
				<td><code>&amp;Epsilon;</code></td>
				<td>&#x0395;</td>
				<td><code>&amp;Dagger;</code></td>
				<td>&#x2021;</td>
				<td><code>&amp;sdot;</code></td>
				<td>&#x22C5;</td>
			</tr>
			<tr>
				<td><code>&amp;Iacute;</code></td>
				<td>&#x00CD;</td>
				<td><code>&amp;Zeta;</code></td>
				<td>&#x0396;</td>
				<td><code>&amp;bull;</code></td>
				<td>&#x2022;</td>
				<td><code>&amp;lceil;</code></td>
				<td>&#x2308;</td>
			</tr>
			<tr>
				<td><code>&amp;Icirc;</code></td>
				<td>&#x00CE;</td>
				<td><code>&amp;Eta;</code></td>
				<td>&#x0397;</td>
				<td><code>&amp;hellip;</code></td>
				<td>&#x2026;</td>
				<td><code>&amp;rceil;</code></td>
				<td>&#x2309;</td>
			</tr>
			<tr>
				<td><code>&amp;Iuml;</code></td>
				<td>&#x00CF;</td>
				<td><code>&amp;Theta;</code></td>
				<td>&#x0398;</td>
				<td><code>&amp;permil;</code></td>
				<td>&#x2030;</td>
				<td><code>&amp;lfloor;</code></td>
				<td>&#x230A;</td>
			</tr>
			<tr>
				<td><code>&amp;ETH;</code></td>
				<td>&#x00D0;</td>
				<td><code>&amp;Iota;</code></td>
				<td>&#x0399;</td>
				<td><code>&amp;prime;</code></td>
				<td>&#x2032;</td>
				<td><code>&amp;rfloor;</code></td>
				<td>&#x230B;</td>
			</tr>
			<tr>
				<td><code>&amp;Ntilde;</code></td>
				<td>&#x00D1;</td>
				<td><code>&amp;Kappa;</code></td>
				<td>&#x039A;</td>
				<td><code>&amp;Prime;</code></td>
				<td>&#x2033;</td>
				<td><code>&amp;lang;</code></td>
				<td>&#x2329;</td>
			</tr>
			<tr>
				<td><code>&amp;Ograve;</code></td>
				<td>&#x00D2;</td>
				<td><code>&amp;Lambda;</code></td>
				<td>&#x039B;</td>
				<td><code>&amp;lsaquo;</code></td>
				<td>&#x2039;</td>
				<td><code>&amp;rang;</code></td>
				<td>&#x232A;</td>
			</tr>
			<tr>
				<td><code>&amp;Oacute;</code></td>
				<td>&#x00D3;</td>
				<td><code>&amp;Mu;</code></td>
				<td>&#x039C;</td>
				<td><code>&amp;rsaquo;</code></td>
				<td>&#x203A;</td>
				<td><code>&amp;loz;</code></td>
				<td>&#x25CA;</td>
			</tr>
			<tr>
				<td><code>&amp;Ocirc;</code></td>
				<td>&#x00D4;</td>
				<td><code>&amp;Nu;</code></td>
				<td>&#x039D;</td>
				<td><code>&amp;oline;</code></td>
				<td>&#x203E;</td>
				<td><code>&amp;spades;</code></td>
				<td>&#x2660;</td>
			</tr>
			<tr>
				<td><code>&amp;Otilde;</code></td>
				<td>&#x00D5;</td>
				<td><code>&amp;Xi;</code></td>
				<td>&#x039E;</td>
				<td><code>&amp;frasl;</code></td>
				<td>&#x2044;</td>
				<td><code>&amp;clubs;</code></td>
				<td>&#x2663;</td>
			</tr>
			<tr>
				<td><code>&amp;Ouml;</code></td>
				<td>&#x00D6;</td>
				<td><code>&amp;Omicron;</code></td>
				<td>&#x039F;</td>
				<td><code>&amp;euro;</code></td>
				<td>&#x20AC;</td>
				<td><code>&amp;hearts;</code></td>
				<td>&#x2665;</td>
			</tr>
			<tr>
				<td><code>&amp;times;</code></td>
				<td>&#x00D7;</td>
				<td><code>&amp;Pi;</code></td>
				<td>&#x03A0;</td>
				<td><code>&amp;image;</code></td>
				<td>&#x2111;</td>
				<td><code>&amp;diams;</code></td>
				<td>&#x2666;</td>
			</tr>
			<tr>
				<td><code>&amp;Oslash;</code></td>
				<td>&#x00D8;</td>
				<td><code>&amp;Rho;</code></td>
				<td>&#x03A1;</td>
				<td><code>&amp;weierp;</code></td>
				<td>&#x2118;</td>
				<td></td>
				<td></td>
			</tr>
			<tr>
				<td><code>&amp;Ugrave;</code></td>
				<td>&#x00D9;</td>
				<td><code>&amp;Sigma;</code></td>
				<td>&#x03A3;</td>
				<td><code>&amp;real;</code></td>
				<td>&#x211C;</td>
				<td></td>
				<td></td>
			</tr>
			<tr>
				<td><code>&amp;Uacute;</code></td>
				<td>&#x00DA;</td>
				<td><code>&amp;Tau;</code></td>
				<td>&#x03A4;</td>
				<td><code>&amp;trade;</code></td>
				<td>&#x2122;</td>
				<td></td>
				<td></td>
			</tr>
		</table>
	</description>
	<see-also>
		fn:htmlEncode, fn:urlEncode, fn:urlDecode
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">htmlEncode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function encodes XML tag characters, control characters,
			and non-ASCII characters in the specified string as HTML entities
			and returns the encoded string.
		</p>
		<p>
			The characters <code>&amp;</code>, <code>&lt;</code>,
			<code>&gt;</code>, <code>&quot;</code>, <code>&#39;</code>,
			and non-breaking space are encoded as <code>&amp;amp;</code>,
			<code>&amp;lt;</code>, <code>&amp;gt;</code>,
			<code>&amp;quot;</code>, <code>&amp;#39;</code>, and
			<code>&amp;nbsp;</code>, respectively. Control characters
			and non-ASCII characters are encoded as
			<code>&amp;#<mv>codepoint</mv>;</code> where <mv>codepoint</mv>
			is the decimal integer representing that character's
			Unicode code point.
		</p>
	</description>
	<see-also>
		fn:htmlDecode, fn:urlEncode, fn:urlDecode
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">javaName</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the javaName
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the name of the Java runtime environment.
			You might use this to determine whether a script will run correctly
			under that runtime environment.
		</p>
	</description>
	<notes>
		<p>
			OpenXION gets the value of this function from the
			<code>java.name</code> system property.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security key
			is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="oxn" modules="oxne">javaVersion</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the javaVersion
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the version of the Java runtime environment.
			You might use this to determine whether a script will run correctly
			under that version of the runtime environment.
		</p>
	</description>
	<notes>
		<p>
			OpenXION gets the value of this function from the
			<code>java.version</code> system property.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security key
			is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="oxn&ge;1.2" modules="oxne&ge;1.2">pack</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>format</mv>,
			<mv>value</mv><opt>, <mv>value</mv><opt>, <mv>...</mv></opt></opt> )
		</syn>
		<syn>
			<me/> ( <mv>format</mv>,
			<mv>value</mv><opt>, <mv>value</mv><opt>, <mv>...</mv></opt></opt> )
		</syn>
		<p>
			<mv>Format</mv> yields a <a>dt:string</a> describing a binary
			data structure. <mv>Value</mv> yields an appropriate
			<a>dt:variant</a> for the corresponding field.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function packs the given <mv>value</mv>s into a
			<a>dt:binary</a> according to the binary data structure specified
			by <mv>format</mv>. It is inspired by the <code>pack</code>
			functions in Perl and PHP, but has a much more powerful syntax.
		</p>
		<p>
			The <mv>format</mv> string can be specified in one of two ways.
			Using the short format, each field in the binary data structure
			is specified using the following syntax:
		</p>
		<syn>
			<mv>type</mv> <opt><mv>size</mv></opt>
			<opt><mv>elaboration</mv></opt> <opt><mv>count</mv></opt>
			<opt><mv>name</mv></opt> <opt><mv>description</mv></opt>
		</syn>
		<p>
			Only <mv>type</mv> is required. The <mv>type</mv> is a single
			character from the table below. Uppercase indicates big-endian
			values, and lowercase indicates little-endian values. The
			<mv>size</mv> is the number of bits. The <mv>elaboration</mv>
			is a type-specific string that must be enclosed in braces; for
			further details, see the table below. If a <mv>count</mv> is
			specified, the unpacked <mv>value</mv> is a <a>dt:list</a>,
			and the <mv>count</mv> must be a number enclosed in brackets
			indicating the number of elements in the list; otherwise, the
			unpacked <mv>value</mv> is a single value. (Except for the
			<code>*</code> and <code>@</code> types, where the <mv>count</mv>
			is the number of bytes and the offset, respectively.) The
			<mv>name</mv> is a string enclosed in backticks (<code>`</code>).
			The <mv>description</mv> is a string enclosed in quotes. The
			<mv>name</mv> and <mv>description</mv> have no effect on the
			packing or unpacking of the data. Whitespace in the format
			string is ignored except for inside quotes and as a token
			separator.
		</p>
		<p>
			Using the long format, each field in the binary data structure
			is specified using the following syntax:
		</p>
		<syn>
			<mv>type</mv> <opt><mv>size</mv></opt>
			<opt><mv>endianness</mv></opt> <opt><mv>elaboration</mv></opt>
			<opt><mv>count</mv></opt> <opt><mv>name</mv></opt>
			<opt><mv>description</mv></opt> ;
		</syn>
		<p>
			Only <mv>type</mv> is required. The <mv>type</mv> is a type name
			from the table below. The <mv>size</mv> is the number of bits.
			The <mv>endianness</mv> is <code>be</code> for big-endian or
			<code>le</code> for little-endian; if <mv>endianness</mv> is not
			specified, big-endian is assumed. The <mv>elaboration</mv> is a
			type-specific string that must be enclosed in braces; for further
			details, see the table below. If a <mv>count</mv> is specified,
			the unpacked <mv>value</mv> is a <a>dt:list</a>, and the
			<mv>count</mv> must be a number enclosed in brackets indicating
			the number of elements in the list; otherwise, the unpacked
			<mv>value</mv> is a single value. (Except for the
			<code>binary</code> and <code>offset</code> types, where the
			<mv>count</mv> is the number of bytes and the offset,
			respectively.) The <mv>name</mv> is either a sequence of
			alphanumeric characters, or a string enclosed in backticks
			(<code>`</code>). The <mv>description</mv> is a string enclosed
			in quotes, or any sequence of characters following the name and
			preceding the terminating semicolon. The <mv>name</mv> and
			<mv>description</mv> have no effect on the packing or unpacking
			of the data. Whitespace in the format string is ignored except
			for inside quotes and as a token separator.
		</p>
		<p>
			The possible field <mv>type</mv>s are:
		</p>
		<table>
			<tr>
				<td><code>T</code>, <code>t</code></td>
				<td><code>bool</code>, <code>boolean</code></td>
				<td>
					A boolean value (<code>T</code> for "truth value").
					The unpacked <mv>value</mv> is <a>cn:false</a> for a
					packed value of zero or <a>cn:true</a> for a packed
					value of one (or any other value when unpacking).
				</td>
			</tr>
			<tr>
				<td><code>E</code>, <code>e</code></td>
				<td><code>enum</code></td>
				<td>
					An enumeration. The <mv>elaboration</mv> is a list
					of key-value pairs, delimited by semicolons, with the
					key and value separated by an equals sign. Each key
					is an integer representing a possible packed value
					and each value is a string. The unpacked <mv>value</mv>
					is one of those strings.
				</td>
			</tr>
			<tr>
				<td><code>J</code>, <code>j</code></td>
				<td><code>bitfield</code></td>
				<td>
					A bit field (<code>J</code> for "jumper"). The
					<mv>elaboration</mv> is a list of key-value pairs,
					delimited by semicolons, with the key and value
					separated by an equals sign. Each key is an integer
					representing a bit in the packed value (from 0 for
					the least-significant bit to <mv>size</mv>-1 for the
					most-significant bit) and each value is a string.
					The unpacked <mv>value</mv> is a comma-delimited
					list of such strings.
				</td>
			</tr>
			<tr>
				<td><code>B</code>, <code>b</code></td>
				<td><code>bint</code></td>
				<td>
					An unsigned integer in binary. The unpacked <mv>value</mv>
					is a <a>dt:string</a> of binary digits.
				</td>
			</tr>
			<tr>
				<td><code>O</code>, <code>o</code></td>
				<td><code>oint</code></td>
				<td>
					An unsigned integer in octal. The unpacked <mv>value</mv>
					is a <a>dt:string</a> of octal digits.
				</td>
			</tr>
			<tr>
				<td><code>H</code>, <code>h</code></td>
				<td><code>hint</code></td>
				<td>
					An unsigned integer in hexadecimal. The unpacked
					<mv>value</mv> is a <a>dt:string</a> of hexadecimal
					digits.
				</td>
			</tr>
			<tr>
				<td><code>U</code>, <code>u</code></td>
				<td><code>uint</code></td>
				<td>
					An unsigned integer. The unpacked <mv>value</mv>
					is an <a>dt:integer</a>.
				</td>
			</tr>
			<tr>
				<td><code>I</code>, <code>i</code></td>
				<td><code>int</code>, <code>sint</code></td>
				<td>
					A signed integer. The unpacked <mv>value</mv>
					is an <a>dt:integer</a>.
				</td>
			</tr>
			<tr>
				<td><code>R</code>, <code>r</code></td>
				<td><code>ufixed</code></td>
				<td>
					An unsigned fixed-point number (<code>R</code> for
					"ratio"). The radix point is fixed in the center of
					the packed value (e.g., at bit 8 if the <mv>size</mv>
					is 16). The unpacked <mv>value</mv> is a
					<a>dt:number</a>.
				</td>
			</tr>
			<tr>
				<td><code>Q</code>, <code>q</code></td>
				<td><code>fixed</code>, <code>sfixed</code></td>
				<td>
					A signed fixed-point number (<code>Q</code> for
					"quotient"). The radix point is fixed in the center
					of the packed value (e.g., at bit 8 if the <mv>size</mv>
					is 16). The unpacked <mv>value</mv> is a
					<a>dt:number</a>.
				</td>
			</tr>
			<tr>
				<td><code>F</code>, <code>f</code></td>
				<td><code>float</code></td>
				<td>
					A floating-point number. The <mv>elaboration</mv> is
					the number of sign bits, the number of exponent bits,
					the number of mantissa bits, and the exponent bias,
					separated by periods. If the <mv>elaboration</mv>
					is not specified, a best guess is made at the appropriate
					number of bits and the appropriate bias based on the
					<mv>size</mv>. For <mv>size</mv>s of 16, 32, 64, and
					128 bits, this "best guess" is guaranteed to be
					<code>1.5.10.15</code>, <code>1.8.23.127</code>,
					<code>1.11.52.1023</code>, and <code>1.15.112.16383</code>,
					respectively, corresponding to IEEE half-, single-,
					double-, and quad-precision floating-point numbers.
					The unpacked <mv>value</mv> is a <a>dt:number</a>.
				</td>
			</tr>
			<tr>
				<td><code>K</code>, <code>k</code></td>
				<td><code>complex</code></td>
				<td>
					A complex number, composed of two floating-point numbers
					(the real part followed by the imaginary part). The
					<mv>size</mv> is the number of bits per part, rather
					than total. The <mv>elaboration</mv> is the same as for
					<code>float</code> above. The unpacked <mv>value</mv>
					is a <a>dt:complex</a>.
				</td>
			</tr>
			<tr>
				<td><code>C</code>, <code>c</code></td>
				<td><code>char</code>, <code>character</code></td>
				<td>
					A character constant. The <mv>size</mv> must be a
					multiple of 8. The <mv>elaboration</mv> is the name
					of a text encoding. If the <mv>elaboration</mv> is
					unspecified, <code>ISO-8859-1</code> is assumed.
					The unpacked <mv>value</mv> is a <a>dt:string</a>.
				</td>
			</tr>
			<tr>
				<td><code>P</code>, <code>p</code></td>
				<td><code>pstring</code></td>
				<td>
					A Pascal-style string. The <mv>size</mv> is the number
					of bits in the count preceding the actual string data.
					The <mv>elaboration</mv> is the name of a text encoding.
					If the <mv>elaboration</mv> is unspecified,
					<code>ISO-8859-1</code> is assumed. The unpacked
					<mv>value</mv> is a <a>dt:string</a>.
				</td>
			</tr>
			<tr>
				<td><code>S</code>, <code>s</code></td>
				<td><code>string</code>, <code>cstring</code></td>
				<td>
					A C-style string. The <mv>size</mv> is the number of
					zero bits following the actual string data and must
					be a multiple of 8. The <mv>elaboration</mv> is the
					name of a text encoding. If the <mv>elaboration</mv>
					is unspecified, <code>ISO-8859-1</code> is assumed.
					The unpacked <mv>value</mv> is a <a>dt:string</a>.
				</td>
			</tr>
			<tr>
				<td><code>D</code>, <code>d</code></td>
				<td><code>date</code>, <code>time</code>, <code>datetime</code></td>
				<td>
					A date. The <mv>elaboration</mv> is the year, month,
					day, hour, minute, and second of the epoch, and the
					scale (0 for seconds, -3 for milliseconds, -6 for
					microseconds, etc.), each delimited by commas.
					If the <mv>elaboration</mv> is unspecified,
					<code>1970,1,1,0,0,0,0</code> is assumed,
					corresponding to the number of seconds since
					January 1, 1970 (the Unix epoch). To use the Macintosh
					epoch, use <code>1904,1,1,0,0,0,0</code>. For
					milliseconds, replace the last number with -3.
					The unpacked <mv>value</mv> is a <a>dt:date</a>.
				</td>
			</tr>
			<tr>
				<td><code>X</code>, <code>x</code></td>
				<td><code>color</code>, <code>colour</code></td>
				<td>
					A color (<code>X</code> for Greek <mv>χρώμα</mv>,
					<mv>chroma</mv>, meaning "color"). The
					<mv>elaboration</mv> is a string determining the
					color model and the order and width of the color
					channels. The default is true color with alpha in
					ARGB order with <mv>size</mv>/4 bits per channel.
					For a <mv>size</mv> of 32 bits, this would be
					equivalent to an <mv>elaboration</mv> of
					<code>a8r8g8b8</code>. The unpacked <mv>value</mv>
					is a <a>dt:color</a>.
				</td>
			</tr>
			<tr>
				<td><code>Z</code>, <code>z</code></td>
				<td><code>filler</code></td>
				<td>
					A series of <mv>size</mv> filler bits (<code>Z</code>
					for "zero"). When packing, <mv>size</mv> bits are filled
					with zero. When unpacking, <mv>size</mv> bits are skipped
					and ignored. There is no unpacked <mv>value</mv> for
					this data type.
				</td>
			</tr>
			<tr>
				<td><code>M</code>, <code>m</code></td>
				<td><code>magic</code></td>
				<td>
					The <mv>elaboration</mv> is a magic number. When
					packing, the resulting packed value is the magic number.
					When unpacking, the packed value is checked against
					the magic number; if they don't match, a script error
					is triggered. There is no unpacked <mv>value</mv>
					for this data type.
				</td>
			</tr>
			<tr>
				<td><code>A</code>, <code>a</code></td>
				<td><code>align</code></td>
				<td>
					Alignment to a multiple of <mv>size</mv> bits. There
					is no unpacked <mv>value</mv> for this data type.
				</td>
			</tr>
			<tr>
				<td><code>*</code></td>
				<td><code>blob</code>, <code>binary</code></td>
				<td>
					The <mv>size</mv>, <mv>endianness</mv>, and
					<mv>elaboration</mv> are ignored. The <mv>count</mv>
					is the number of bytes to pack or unpack.
					If the <mv>count</mv> is unspecified when unpacking,
					zero bytes are unpacked. If the <mv>count</mv> is
					unspecified when packing, however many bytes are
					in the unpacked <mv>value</mv> are packed. The
					unpacked <mv>value</mv> is a <a>dt:binary</a>.
				</td>
			</tr>
			<tr>
				<td><code>$</code></td>
				<td><code>struct</code></td>
				<td>
					A substructure. The <mv>elaboration</mv> is a format
					string describing the binary data substructure.
					The unpacked <mv>value</mv> is a <a>dt:list</a> of
					unpacked <mv>value</mv>s from the specified substructure.
				</td>
			</tr>
			<tr>
				<td><code>@</code></td>
				<td><code>offset</code></td>
				<td>
					The <mv>size</mv>, <mv>endianness</mv>, and
					<mv>elaboration</mv> are ignored. The <mv>count</mv>
					is an offset from the beginning of the packed
					<a>dt:binary</a> where future values are packed to
					or unpacked from. When unpacking, the offset may be
					anywhere in the <a>dt:binary</a>. When packing, the
					offset must be greater than or equal to the number
					of bytes already packed.
				</td>
			</tr>
		</table>
		<p>
			In addition to the type names listed above, the following
			special type names are allowed in a long-format <mv>format</mv>
			string. These special type names specify a size and, for some,
			an endianness and an <mv>elaboration</mv> in addition to a
			data type.
		</p>
		<table>
			<tr>
				<td><code>bbyte</code></td>
				<td>alias for <code>bint8</code></td>
			</tr>
			<tr>
				<td><code>obyte</code></td>
				<td>alias for <code>oint8</code></td>
			</tr>
			<tr>
				<td><code>hbyte</code></td>
				<td>alias for <code>hint8</code></td>
			</tr>
			<tr>
				<td><code>ubyte</code></td>
				<td>alias for <code>uint8</code></td>
			</tr>
			<tr>
				<td><code>sbyte</code></td>
				<td>alias for <code>sint8</code></td>
			</tr>
			<tr>
				<td><code>byte</code></td>
				<td>alias for <code>int8</code></td>
			</tr>
			<tr>
				<td><code>bshort</code></td>
				<td>alias for <code>bint16</code></td>
			</tr>
			<tr>
				<td><code>oshort</code></td>
				<td>alias for <code>oint16</code></td>
			</tr>
			<tr>
				<td><code>hshort</code></td>
				<td>alias for <code>hint16</code></td>
			</tr>
			<tr>
				<td><code>ushort</code></td>
				<td>alias for <code>uint16</code></td>
			</tr>
			<tr>
				<td><code>sshort</code></td>
				<td>alias for <code>sint16</code></td>
			</tr>
			<tr>
				<td><code>short</code></td>
				<td>alias for <code>int16</code></td>
			</tr>
			<tr>
				<td><code>blong</code></td>
				<td>alias for <code>bint64</code></td>
			</tr>
			<tr>
				<td><code>olong</code></td>
				<td>alias for <code>oint64</code></td>
			</tr>
			<tr>
				<td><code>hlong</code></td>
				<td>alias for <code>hint64</code></td>
			</tr>
			<tr>
				<td><code>ulong</code></td>
				<td>alias for <code>uint64</code></td>
			</tr>
			<tr>
				<td><code>slong</code></td>
				<td>alias for <code>sint64</code></td>
			</tr>
			<tr>
				<td><code>long</code></td>
				<td>alias for <code>int64</code></td>
			</tr>
			<tr>
				<td><code>half</code></td>
				<td>alias for <code>float16</code></td>
			</tr>
			<tr>
				<td><code>single</code></td>
				<td>alias for <code>float32</code></td>
			</tr>
			<tr>
				<td><code>real</code></td>
				<td>alias for <code>float32</code></td>
			</tr>
			<tr>
				<td><code>double</code></td>
				<td>alias for <code>float64</code></td>
			</tr>
			<tr>
				<td><code>quad</code></td>
				<td>alias for <code>float128</code></td>
			</tr>
			<tr>
				<td><code>onecc</code></td>
				<td>alias for <code>char8</code></td>
			</tr>
			<tr>
				<td><code>occ</code></td>
				<td>alias for <code>char8</code></td>
			</tr>
			<tr>
				<td><code>twocc</code></td>
				<td>alias for <code>char16</code></td>
			</tr>
			<tr>
				<td><code>tcc</code></td>
				<td>alias for <code>char16</code></td>
			</tr>
			<tr>
				<td><code>fourcc</code></td>
				<td>alias for <code>char32</code></td>
			</tr>
			<tr>
				<td><code>fcc</code></td>
				<td>alias for <code>char32</code></td>
			</tr>
			<tr>
				<td><code>eightcc</code></td>
				<td>alias for <code>char64</code></td>
			</tr>
			<tr>
				<td><code>ecc</code></td>
				<td>alias for <code>char64</code></td>
			</tr>
			<tr>
				<td><code>wstring</code></td>
				<td>alias for <code>pstring16</code></td>
			</tr>
			<tr>
				<td><code>lstring</code></td>
				<td>alias for <code>pstring32</code></td>
			</tr>
			<tr>
				<td><code>wchar</code></td>
				<td>alias for <code>char16be&#123;UTF-16&#125;</code></td>
			</tr>
			<tr>
				<td><code>wcharbe</code></td>
				<td>alias for <code>char16be&#123;UTF-16&#125;</code></td>
			</tr>
			<tr>
				<td><code>wcharle</code></td>
				<td>alias for <code>char16le&#123;UTF-16&#125;</code></td>
			</tr>
			<tr>
				<td><code>ostype</code></td>
				<td>alias for <code>char32be&#123;MacRoman&#125;</code></td>
			</tr>
			<tr>
				<td><code>symbol</code></td>
				<td>alias for <code>char64be&#123;ISO-8859-1&#125;</code></td>
			</tr>
			<tr>
				<td><code>point</code></td>
				<td>alias for <code>struct&#123;sint16be y; sint16be x;&#125;</code></td>
			</tr>
			<tr>
				<td><code>rect</code></td>
				<td>alias for <code>struct&#123;sint16be top; sint16be left; sint16be bottom; sint16be right;&#125;</code></td>
			</tr>
			<tr>
				<td><code>rectangle</code></td>
				<td>alias for <code>struct&#123;sint16be top; sint16be left; sint16be bottom; sint16be right;&#125;</code></td>
			</tr>
			<tr>
				<td><code>rgbcolor</code></td>
				<td>alias for <code>struct&#123;uint16be red; uint16be green; uint16be blue;&#125;</code></td>
			</tr>
			<tr>
				<td><code>rgbcolour</code></td>
				<td>alias for <code>struct&#123;uint16be red; uint16be green; uint16be blue;&#125;</code></td>
			</tr>
		</table>
	</description>
	<notes>
		<p>
			If the <mv>format</mv> string is not properly formed,
			a script error is triggered.
		</p>
		<p>
			If any <mv>value</mv> is not of an appropriate type
			for its corresponding field, a script error is triggered.
		</p>
		<p>
			If there are fewer <mv>value</mv>s passed to the function than are
			specified by the <mv>format</mv>, the missing <mv>value</mv>s are
			assumed to be <a>cn:empty</a>. If the corresponding fields are,
			e.g., <code>char</code> or <code>string</code>, this will have no
			ill effect, but if the corresponding fields are, e.g.,
			<code>boolean</code> or <code>date</code>, this will trigger
			a script error.
		</p>
		<p>
			If there are more <mv>value</mv>s passed to the function than are
			specified by the format, the extra <mv>value</mv>s are ignored.
		</p>
		<p>
			The <mv>value</mv>s to be packed must be passed directly as
			parameters to the <me/> function. If you already have the
			<mv>value</mv>s you need in a <a>dt:list</a>, either
			<a>cm:put</a> the format string <a>kw:before</a> the
			<a>dt:list</a> then pass the <a>dt:list</a> to the <me/>
			function, or pass the <a>dt:list</a> as the <mv>value</mv>
			for a <code>struct</code> whose <mv>elaboration</mv> is
			the original format string.
		</p>
	</notes>
	<see-also>
		fn:unpack
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regCountFields</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>String</mv>. yields any <a>dt:string</a>. <mv>Delimiter</mv>
			yields a <a>dt:string</a> describing a regular expression.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the number of chunks in the specified
			<mv>string</mv> delimited by the specified <mv>delimiter</mv>,
			not including any trailing empty chunks.
		</p>
		<p>
			The <mv>delimiter</mv> is a regular expression. For a literal
			version of this function, see <a>fn:countFields</a> or
			<a>fn:csCountFields</a>.
		</p>
	</description>
	<see-also>
		fn:countFields, fn:csCountFields, fn:trCountFields,
		fn:nthField, fn:csNthField, fn:regNthField, fn:trNthField
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regExplode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Delimiter</mv>
			yields a <a>dt:string</a> describing a regular expression.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a <a>dt:list</a> of the chunks
			in the specified <mv>string</mv> delimited by the specified
			<mv>delimiter</mv>, not including any trailing empty chunks.
		</p>
		<p>
			The <mv>delimiter</mv> is a regular expression. For a literal
			version of this function, see <a>fn:explode</a> or
			<a>fn:csExplode</a>.
		</p>
	</description>
	<see-also>
		fn:explode, fn:csExplode, fn:trExplode, fn:implode
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regInstr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Needle</mv>
			yields a <a>dt:string</a> describing a regular expression.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the first appearance of
			the regular expression <mv>needle</mv> in the string
			<mv>haystack</mv>, starting at 1. If <mv>needle</mv> cannot be
			found in <mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is regular expression-based. For a literal version
			of this function, see <a>fn:instr</a> or <a>fn:csInstr</a>.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to <a>fn:regOffset</a>,
			but the arguments are in reverse order.
		</p>
	</notes>
	<see-also>
		fn:instr, fn:csInstr, fn:trInstr,
		fn:offset, fn:csOffset, fn:regOffset, fn:trOffset,
		fn:rinstr, fn:csRinstr, fn:regRinstr, fn:trRinstr
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regMatch</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>pattern</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>pattern</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields a <a>dt:string</a>. <mv>Pattern</mv>
			yields a string describing a regular expression.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if
			the specified <mv>expression</mv> matches the regular expression
			specified by <mv>pattern</mv>.
		</p>
		<p>
			<mv>Pattern</mv> is a regular expression. For a literal version
			of this function, see <a>fn:strcmp</a> or <a>fn:csStrcmp</a>.
		</p>
	</description>
	<see-also>
		fn:strcmp, fn:csStrcmp, fn:trMatch
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regNthField</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv>, <mv>index</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv>, <mv>index</mv> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Delimiter</mv>
			yields a <a>dt:string</a> describing a regular expression.
			<mv>Index</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a chunk of the specified
			<mv>string</mv> delimited by the specified <mv>delimiter</mv>.
			<mv>Index</mv> starts at 1.
		</p>
		<p>
			If <mv>index</mv> is less than 1 or greater than
			<code><a>fn:regCountFields</a>(<mv>string</mv>, <mv>delimiter</mv>)</code>,
			<a>cn:empty</a> is returned.
		</p>
		<p>
			The <mv>delimiter</mv> is a regular expression. For a literal
			version of this function, see <a>fn:nthField</a> or
			<a>fn:csNthField</a>.
		</p>
	</description>
	<see-also>
		fn:nthField, fn:csNthField, fn:trNthField,
		fn:countFields, fn:csCountFields, fn:regCountFields, fn:trCountFields
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regOffset</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>needle</mv>, <mv>haystack</mv> )
		</syn>
		<syn>
			<me/> ( <mv>needle</mv>, <mv>haystack</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Needle</mv>
			yields a <a>dt:string</a> describing a regular expression.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the first appearance of
			the regular expression <mv>needle</mv> in the string
			<mv>haystack</mv>, starting at 1. If <mv>needle</mv> cannot be
			found in <mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is regular expression-based. For a literal version
			of this function, see <a>fn:offset</a> or <a>fn:csOffset</a>.
		</p>
	</description>
	<notes>
		<p>
			This function is similar to <a>fn:regInstr</a>,
			but the arguments are in reverse order.
		</p>
	</notes>
	<see-also>
		fn:offset, fn:csOffset, fn:trOffset,
		fn:instr, fn:csInstr, fn:regInstr, fn:trInstr,
		fn:rinstr, fn:csRinstr, fn:regRinstr, fn:trRinstr
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regReplace</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Needle</mv>
			yields a <a>dt:string</a> describing a regular expression.
			<mv>Noodle</mv> yields a <a>dt:string</a> describing a
			replacement expression.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string <mv>haystack</mv>
			with the first occurrence of the regular expression <mv>needle</mv>
			replaced with the replacement expression <mv>noodle</mv>.
		</p>
		<p>
			<mv>Needle</mv> is a regular expression. <mv>Noodle</mv> is
			more-or-less a literal string; however, backslashes or dollar
			signs in <mv>noodle</mv> will refer to groups in the found
			expression rather than literal backslashes or dollar signs.
			For a literal version of this function, see <a>fn:replace</a>
			or <a>fn:csReplace</a>.
		</p>
	</description>
	<see-also>
		fn:regReplaceAll, fn:replace, fn:csReplace, fn:trReplace
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regReplaceAll</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Needle</mv>
			yields a <a>dt:string</a> describing a regular expression.
			<mv>Noodle</mv> yields a <a>dt:string</a> describing a
			replacement expression.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the string <mv>haystack</mv>
			with every occurrence of the regular expression <mv>needle</mv>
			replaced with the replacement expression <mv>noodle</mv>.
		</p>
		<p>
			<mv>Needle</mv> is a regular expression. <mv>Noodle</mv> is
			more-or-less a literal string; however, backslashes or dollar
			signs in <mv>noodle</mv> will refer to groups in the found
			expression rather than literal backslashes or dollar signs.
			For a literal version of this function, see <a>fn:replaceAll</a>
			or <a>fn:csReplaceAll</a>.
		</p>
	</description>
	<see-also>
		fn:regReplace, fn:replaceAll, fn:csReplaceAll, fn:trReplaceAll
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">regRinstr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Needle</mv>
			yields a <a>dt:string</a> describing a regular expression.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the last appearance of
			the regular expression <mv>needle</mv> in the string
			<mv>haystack</mv>, starting at 1. If <mv>needle</mv> cannot be
			found in <mv>haystack</mv>, <a>cn:zero</a> is returned.
		</p>
		<p>
			This function is regular expression-based. For a literal version
			of this function, see <a>fn:rinstr</a> or <a>fn:csRinstr</a>.
		</p>
	</description>
	<see-also>
		fn:rinstr, fn:csRinstr, fn:trRinstr,
		fn:instr, fn:csInstr, fn:regInstr, fn:trInstr,
		fn:offset, fn:csOffset, fn:regOffset, fn:trOffset
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trCountFields</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Delimiter</mv>
			yields a <a>dt:string</a> describing a set of characters.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the number of chunks in the specified
			<mv>string</mv> delimited by any of the characters in the specified
			<mv>delimiter</mv>, not including any trailing empty chunks.
		</p>
		<p>
			<mv>Delimiter</mv> describes a set of characters, not a string.
			A range of characters can be specified by putting a hyphen
			between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
	</description>
	<see-also>
		fn:countFields, fn:csCountFields, fn:trCountFields,
		fn:nthField, fn:csNthField, fn:regNthField, fn:trNthField
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trExplode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Delimiter</mv>
			yields a <a>dt:string</a> describing a set of characters.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a <a>dt:list</a> of the chunks
			in the specified <mv>string</mv> delimited by any of the
			characters in the specified <mv>delimiter</mv>, not including
			any trailing empty chunks.
		</p>
		<p>
			<mv>Delimiter</mv> describes a set of characters, not a string.
			A range of characters can be specified by putting a hyphen
			between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
	</description>
	<see-also>
		fn:explode, fn:csExplode, fn:regExplode, fn:implode
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trInstr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Needle</mv>
			yields a <a>dt:string</a> describing a set of characters.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the first appearance of
			any of the characters in <mv>needle</mv> in the string
			<mv>haystack</mv>, starting at 1. If none of the characters in
			<mv>needle</mv> can be found in <mv>haystack</mv>, <a>cn:zero</a>
			is returned.
		</p>
		<p>
			<mv>Needle</mv> describes a set of characters, not a string.
			A range of characters can be specified by putting a hyphen
			between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
	</description>
	<notes>
		<p>
			This function is similar to <a>fn:trOffset</a>,
			but the arguments are in reverse order.
		</p>
	</notes>
	<see-also>
		fn:instr, fn:csInstr, fn:regInstr,
		fn:offset, fn:csOffset, fn:regOffset, fn:trOffset,
		fn:rinstr, fn:csRinstr, fn:regRinstr, fn:trRinstr
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trMatch</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>expression</mv>, <mv>pattern</mv> )
		</syn>
		<syn>
			<me/> ( <mv>expression</mv>, <mv>pattern</mv> )
		</syn>
		<p>
			<mv>Expression</mv> yields a <a>dt:string</a>. <mv>Pattern</mv>
			yields a string describing a set of characters.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns <a>cn:true</a> if and only if
			the specified <mv>expression</mv> consists solely of characters
			in the specified <mv>pattern</mv>.
		</p>
		<p>
			<mv>Pattern</mv> describes a set of characters, not a string.
			A range of characters can be specified by putting a hyphen
			between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
	</description>
	<see-also>
		fn:strcmp, fn:csStrcmp, fn:regMatch
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trNthField</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>string</mv>, <mv>delimiter</mv>, <mv>index</mv> )
		</syn>
		<syn>
			<me/> ( <mv>string</mv>, <mv>delimiter</mv>, <mv>index</mv> )
		</syn>
		<p>
			<mv>String</mv> yields any <a>dt:string</a>. <mv>Delimiter</mv>
			yields a <a>dt:string</a> describing a set of characters.
			<mv>Index</mv> yields an <a>dt:integer</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns a chunk of the specified
			<mv>string</mv> delimited by any of the characters in the
			specified <mv>delimiter</mv>, not including any trailing
			empty chunks. <mv>Index</mv> starts at 1.
		</p>
		<p>
			<mv>Delimiter</mv> describes a set of characters, not a string.
			A range of characters can be specified by putting a hyphen
			between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
		<p>
			If <mv>index</mv> is less than 1 or greater than
			<code><a>fn:trCountFields</a>(<mv>string</mv>, <mv>delimiter</mv>)</code>,
			<a>cn:empty</a> is returned.
		</p>
	</description>
	<see-also>
		fn:nthField, fn:csNthField, fn:regNthField,
		fn:countFields, fn:csCountFields, fn:regCountFields, fn:trCountFields
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trOffset</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>needle</mv>, <mv>haystack</mv> )
		</syn>
		<syn>
			<me/> ( <mv>needle</mv>, <mv>haystack</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Needle</mv>
			yields a <a>dt:string</a> describing a set of characters.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the first appearance of
			any of the characters in <mv>needle</mv> in the string
			<mv>haystack</mv>, starting at 1. If none of the characters in
			<mv>needle</mv> can be found in <mv>haystack</mv>,
			<a>cn:zero</a> is returned.
		</p>
		<p>
			<mv>Needle</mv> describes a set of characters, not a string.
			A range of characters can be specified by putting a hyphen
			between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
	</description>
	<notes>
		<p>
			This function is similar to <a>fn:trInstr</a>,
			but the arguments are in reverse order.
		</p>
	</notes>
	<see-also>
		fn:offset, fn:csOffset, fn:regOffset,
		fn:instr, fn:csInstr, fn:regInstr, fn:trInstr,
		fn:rinstr, fn:csRinstr, fn:regRinstr, fn:trRinstr
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trReplace</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>options</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>options</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>options</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>options</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Options</mv>
			yields a <a>dt:string</a> starting with a hyphen. <mv>Needle</mv>
			and <mv>noodle</mv> yields <a>dt:string</a>s describing sets of
			characters.
		</p>
	</syntax>
	<description>
		<p>
			In its basic form, the <me/> function returns the string
			<mv>haystack</mv> with the first occurrence of any of the
			characters in <mv>needle</mv> replaced with the corresponding
			character in <mv>noodle</mv>.
		</p>
		<p>
			If <mv>options</mv> contains <code>s</code> but not
			<code>d</code>, then <mv>noodle</mv> is optional.
			If <mv>noodle</mv> is specified, the first occurrence
			of any of the characters in <mv>needle</mv> is replaced
			with the corresponding character in <mv>noodle</mv>,
			then any consecutive occurrences of that character
			are removed. If <mv>noodle</mv> is not specified,
			the first run of consecutive occurrences of any one character
			in <mv>needle</mv> are replaced with a single occurrence.
		</p>
		<p>
			If <mv>options</mv> contains <code>d</code> but not
			<code>s</code>, only <mv>needle</mv> must be specified.
			The first occurrence of any character in <mv>needle</mv>
			is removed from <mv>haystack</mv>.
		</p>
		<p>
			If <mv>options</mv> contains both <code>d</code> and
			<code>s</code>, both <mv>needle</mv> and <mv>noodle</mv>
			must be specified. The first occurrence of any character
			in <mv>needle</mv> is removed from <mv>haystack</mv>.
			The first run of consecutive occurrences of any one character
			in <mv>noodle</mv> are replaced with a single occurrence.
		</p>
		<p>
			If <mv>options</mv> contains the character <code>c</code>,
			the complement of <mv>needle</mv> is taken, so that characters
			not in <mv>needle</mv> will be matched instead.
		</p>
		<p>
			<mv>Needle</mv> and <mv>noodle</mv> describe sets of characters,
			not strings. A range of characters can be specified by putting
			a hyphen between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
	</description>
	<see-also>
		fn:trReplaceAll, fn:replace, fn:csReplace, fn:regReplace
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trReplaceAll</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>options</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>options</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>options</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>options</mv>, <mv>needle</mv>, <mv>noodle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Options</mv>
			yields a <a>dt:string</a> starting with a hyphen. <mv>Needle</mv>
			and <mv>noodle</mv> yields <a>dt:string</a>s describing sets of
			characters.
		</p>
	</syntax>
	<description>
		<p>
			In its basic form, the <me/> function returns the string
			<mv>haystack</mv> with every occurrence of any of the characters
			in <mv>needle</mv> replaced with the corresponding character in
			<mv>noodle</mv>.
		</p>
		<p>
			If <mv>options</mv> contains <code>s</code> but not
			<code>d</code>, then <mv>noodle</mv> is optional.
			If <mv>noodle</mv> is specified, every occurrence of
			any of the characters in <mv>needle</mv> is replaced
			with the corresponding character in <mv>noodle</mv>,
			then multiple consecutive occurrences of any one character
			in <mv>noodle</mv> are replaced with a single occurrence.
			If <mv>noodle</mv> is not specified, multiple consecutive
			occurrences of any one character in <mv>needle</mv> are
			replaced with a single occurrence.
		</p>
		<p>
			If <mv>options</mv> contains <code>d</code> but not
			<code>s</code>, only <mv>needle</mv> must be specified.
			Every occurrence of any character in <mv>needle</mv>
			is removed from <mv>haystack</mv>.
		</p>
		<p>
			If <mv>options</mv> contains both <code>d</code> and
			<code>s</code>, both <mv>needle</mv> and <mv>noodle</mv>
			must be specified. Every occurrence of any character in
			<mv>needle</mv> is removed from <mv>haystack</mv>.
			Multiple consecutive occurrences of any one character in
			<mv>noodle</mv> are replaced with a single occurrence.
		</p>
		<p>
			If <mv>options</mv> contains the character <code>c</code>,
			the complement of <mv>needle</mv> is taken, so that
			characters not in <mv>needle</mv> will be matched instead.
		</p>
		<p>
			<mv>Needle</mv> and <mv>noodle</mv> describe sets of characters,
			not strings. A range of characters can be specified by putting
			a hyphen between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
	</description>
	<see-also>
		fn:trReplace, fn:replaceAll, fn:csReplaceAll, fn:regReplaceAll
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">trRinstr</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<syn>
			<me/> ( <mv>haystack</mv>, <mv>needle</mv> )
		</syn>
		<p>
			<mv>Haystack</mv> yields any <a>dt:string</a>. <mv>Needle</mv>
			yields a <a>dt:string</a> describing a set of characters.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function returns the index of the last appearance of
			any of the characters in <mv>needle</mv> in the string
			<mv>haystack</mv>, starting at 1. If none of the characters in
			<mv>needle</mv> can be found in <mv>haystack</mv>,
			<a>cn:zero</a> is returned.
		</p>
		<p>
			<mv>Needle</mv> describes a set of characters, not a string.
			A range of characters can be specified by putting a hyphen
			between two characters; to match a literal hyphen, put a
			hyphen at the beginning or end. For example, the following
			pattern matches all numbers and basic Latin letters, as well
			as hyphens: <code>A-Za-z0-9-</code>
		</p>
	</description>
	<see-also>
		fn:rinstr, fn:csRinstr, fn:regRinstr,
		fn:instr, fn:csInstr, fn:regInstr, fn:trInstr,
		fn:offset, fn:csOffset, fn:regOffset, fn:trOffset
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.2" modules="oxne&ge;1.2">unpack</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of ( <mv>format</mv>, <mv>data</mv> )
		</syn>
		<syn>
			<me/> ( <mv>format</mv>, <mv>data</mv> )
		</syn>
		<p>
			<mv>Format</mv> yields a <a>dt:string</a> describing a binary
			data structure. <mv>Data</mv> yields a <a>dt:binary</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function unpacks values from a <a>dt:binary</a>
			according to the binary data structure specified by
			<mv>format</mv>. It is inspired by the <code>unpack</code>
			functions in Perl and PHP, but has a much more powerful syntax.
		</p>
		<p>
			The <mv>format</mv> string can be specified in one of two ways.
			Using the short format, each field in the binary data structure
			is specified using the following syntax:
		</p>
		<syn>
			<mv>type</mv> <opt><mv>size</mv></opt>
			<opt><mv>elaboration</mv></opt> <opt><mv>count</mv></opt>
			<opt><mv>name</mv></opt> <opt><mv>description</mv></opt>
		</syn>
		<p>
			Only <mv>type</mv> is required. The <mv>type</mv> is a single
			character from the table below. Uppercase indicates big-endian
			values, and lowercase indicates little-endian values. The
			<mv>size</mv> is the number of bits. The <mv>elaboration</mv>
			is a type-specific string that must be enclosed in braces; for
			further details, see the table below. If a <mv>count</mv> is
			specified, the unpacked <mv>value</mv> is a <a>dt:list</a>,
			and the <mv>count</mv> must be a number enclosed in brackets
			indicating the number of elements in the list; otherwise, the
			unpacked <mv>value</mv> is a single value. (Except for the
			<code>*</code> and <code>@</code> types, where the <mv>count</mv>
			is the number of bytes and the offset, respectively.) The
			<mv>name</mv> is a string enclosed in backticks (<code>`</code>).
			The <mv>description</mv> is a string enclosed in quotes. The
			<mv>name</mv> and <mv>description</mv> have no effect on the
			packing or unpacking of the data. Whitespace in the format
			string is ignored except for inside quotes and as a token
			separator.
		</p>
		<p>
			Using the long format, each field in the binary data structure
			is specified using the following syntax:
		</p>
		<syn>
			<mv>type</mv> <opt><mv>size</mv></opt>
			<opt><mv>endianness</mv></opt> <opt><mv>elaboration</mv></opt>
			<opt><mv>count</mv></opt> <opt><mv>name</mv></opt>
			<opt><mv>description</mv></opt> ;
		</syn>
		<p>
			Only <mv>type</mv> is required. The <mv>type</mv> is a type name
			from the table below. The <mv>size</mv> is the number of bits.
			The <mv>endianness</mv> is <code>be</code> for big-endian or
			<code>le</code> for little-endian; if <mv>endianness</mv> is not
			specified, big-endian is assumed. The <mv>elaboration</mv> is a
			type-specific string that must be enclosed in braces; for further
			details, see the table below. If a <mv>count</mv> is specified,
			the unpacked <mv>value</mv> is a <a>dt:list</a>, and the
			<mv>count</mv> must be a number enclosed in brackets indicating
			the number of elements in the list; otherwise, the unpacked
			<mv>value</mv> is a single value. (Except for the
			<code>binary</code> and <code>offset</code> types, where the
			<mv>count</mv> is the number of bytes and the offset,
			respectively.) The <mv>name</mv> is either a sequence of
			alphanumeric characters, or a string enclosed in backticks
			(<code>`</code>). The <mv>description</mv> is a string enclosed
			in quotes, or any sequence of characters following the name and
			preceding the terminating semicolon. The <mv>name</mv> and
			<mv>description</mv> have no effect on the packing or unpacking
			of the data. Whitespace in the format string is ignored except
			for inside quotes and as a token separator.
		</p>
		<p>
			The possible field <mv>type</mv>s are:
		</p>
		<table>
			<tr>
				<td><code>T</code>, <code>t</code></td>
				<td><code>bool</code>, <code>boolean</code></td>
				<td>
					A boolean value (<code>T</code> for "truth value").
					The unpacked <mv>value</mv> is <a>cn:false</a> for a
					packed value of zero or <a>cn:true</a> for a packed
					value of one (or any other value when unpacking).
				</td>
			</tr>
			<tr>
				<td><code>E</code>, <code>e</code></td>
				<td><code>enum</code></td>
				<td>
					An enumeration. The <mv>elaboration</mv> is a list
					of key-value pairs, delimited by semicolons, with the
					key and value separated by an equals sign. Each key
					is an integer representing a possible packed value
					and each value is a string. The unpacked <mv>value</mv>
					is one of those strings.
				</td>
			</tr>
			<tr>
				<td><code>J</code>, <code>j</code></td>
				<td><code>bitfield</code></td>
				<td>
					A bit field (<code>J</code> for "jumper"). The
					<mv>elaboration</mv> is a list of key-value pairs,
					delimited by semicolons, with the key and value
					separated by an equals sign. Each key is an integer
					representing a bit in the packed value (from 0 for
					the least-significant bit to <mv>size</mv>-1 for the
					most-significant bit) and each value is a string.
					The unpacked <mv>value</mv> is a comma-delimited
					list of such strings.
				</td>
			</tr>
			<tr>
				<td><code>B</code>, <code>b</code></td>
				<td><code>bint</code></td>
				<td>
					An unsigned integer in binary. The unpacked <mv>value</mv>
					is a <a>dt:string</a> of binary digits.
				</td>
			</tr>
			<tr>
				<td><code>O</code>, <code>o</code></td>
				<td><code>oint</code></td>
				<td>
					An unsigned integer in octal. The unpacked <mv>value</mv>
					is a <a>dt:string</a> of octal digits.
				</td>
			</tr>
			<tr>
				<td><code>H</code>, <code>h</code></td>
				<td><code>hint</code></td>
				<td>
					An unsigned integer in hexadecimal. The unpacked
					<mv>value</mv> is a <a>dt:string</a> of hexadecimal
					digits.
				</td>
			</tr>
			<tr>
				<td><code>U</code>, <code>u</code></td>
				<td><code>uint</code></td>
				<td>
					An unsigned integer. The unpacked <mv>value</mv>
					is an <a>dt:integer</a>.
				</td>
			</tr>
			<tr>
				<td><code>I</code>, <code>i</code></td>
				<td><code>int</code>, <code>sint</code></td>
				<td>
					A signed integer. The unpacked <mv>value</mv>
					is an <a>dt:integer</a>.
				</td>
			</tr>
			<tr>
				<td><code>R</code>, <code>r</code></td>
				<td><code>ufixed</code></td>
				<td>
					An unsigned fixed-point number (<code>R</code> for
					"ratio"). The radix point is fixed in the center of
					the packed value (e.g., at bit 8 if the <mv>size</mv>
					is 16). The unpacked <mv>value</mv> is a
					<a>dt:number</a>.
				</td>
			</tr>
			<tr>
				<td><code>Q</code>, <code>q</code></td>
				<td><code>fixed</code>, <code>sfixed</code></td>
				<td>
					A signed fixed-point number (<code>Q</code> for
					"quotient"). The radix point is fixed in the center
					of the packed value (e.g., at bit 8 if the <mv>size</mv>
					is 16). The unpacked <mv>value</mv> is a
					<a>dt:number</a>.
				</td>
			</tr>
			<tr>
				<td><code>F</code>, <code>f</code></td>
				<td><code>float</code></td>
				<td>
					A floating-point number. The <mv>elaboration</mv> is
					the number of sign bits, the number of exponent bits,
					the number of mantissa bits, and the exponent bias,
					separated by periods. If the <mv>elaboration</mv>
					is not specified, a best guess is made at the appropriate
					number of bits and the appropriate bias based on the
					<mv>size</mv>. For <mv>size</mv>s of 16, 32, 64, and
					128 bits, this "best guess" is guaranteed to be
					<code>1.5.10.15</code>, <code>1.8.23.127</code>,
					<code>1.11.52.1023</code>, and <code>1.15.112.16383</code>,
					respectively, corresponding to IEEE half-, single-,
					double-, and quad-precision floating-point numbers.
					The unpacked <mv>value</mv> is a <a>dt:number</a>.
				</td>
			</tr>
			<tr>
				<td><code>K</code>, <code>k</code></td>
				<td><code>complex</code></td>
				<td>
					A complex number, composed of two floating-point numbers
					(the real part followed by the imaginary part). The
					<mv>size</mv> is the number of bits per part, rather
					than total. The <mv>elaboration</mv> is the same as for
					<code>float</code> above. The unpacked <mv>value</mv>
					is a <a>dt:complex</a>.
				</td>
			</tr>
			<tr>
				<td><code>C</code>, <code>c</code></td>
				<td><code>char</code>, <code>character</code></td>
				<td>
					A character constant. The <mv>size</mv> must be a
					multiple of 8. The <mv>elaboration</mv> is the name
					of a text encoding. If the <mv>elaboration</mv> is
					unspecified, <code>ISO-8859-1</code> is assumed.
					The unpacked <mv>value</mv> is a <a>dt:string</a>.
				</td>
			</tr>
			<tr>
				<td><code>P</code>, <code>p</code></td>
				<td><code>pstring</code></td>
				<td>
					A Pascal-style string. The <mv>size</mv> is the number
					of bits in the count preceding the actual string data.
					The <mv>elaboration</mv> is the name of a text encoding.
					If the <mv>elaboration</mv> is unspecified,
					<code>ISO-8859-1</code> is assumed. The unpacked
					<mv>value</mv> is a <a>dt:string</a>.
				</td>
			</tr>
			<tr>
				<td><code>S</code>, <code>s</code></td>
				<td><code>string</code>, <code>cstring</code></td>
				<td>
					A C-style string. The <mv>size</mv> is the number of
					zero bits following the actual string data and must
					be a multiple of 8. The <mv>elaboration</mv> is the
					name of a text encoding. If the <mv>elaboration</mv>
					is unspecified, <code>ISO-8859-1</code> is assumed.
					The unpacked <mv>value</mv> is a <a>dt:string</a>.
				</td>
			</tr>
			<tr>
				<td><code>D</code>, <code>d</code></td>
				<td><code>date</code>, <code>time</code>, <code>datetime</code></td>
				<td>
					A date. The <mv>elaboration</mv> is the year, month,
					day, hour, minute, and second of the epoch, and the
					scale (0 for seconds, -3 for milliseconds, -6 for
					microseconds, etc.), each delimited by commas.
					If the <mv>elaboration</mv> is unspecified,
					<code>1970,1,1,0,0,0,0</code> is assumed,
					corresponding to the number of seconds since
					January 1, 1970 (the Unix epoch). To use the Macintosh
					epoch, use <code>1904,1,1,0,0,0,0</code>. For
					milliseconds, replace the last number with -3.
					The unpacked <mv>value</mv> is a <a>dt:date</a>.
				</td>
			</tr>
			<tr>
				<td><code>X</code>, <code>x</code></td>
				<td><code>color</code>, <code>colour</code></td>
				<td>
					A color (<code>X</code> for Greek <mv>χρώμα</mv>,
					<mv>chroma</mv>, meaning "color"). The
					<mv>elaboration</mv> is a string determining the
					color model and the order and width of the color
					channels. The default is true color with alpha in
					ARGB order with <mv>size</mv>/4 bits per channel.
					For a <mv>size</mv> of 32 bits, this would be
					equivalent to an <mv>elaboration</mv> of
					<code>a8r8g8b8</code>. The unpacked <mv>value</mv>
					is a <a>dt:color</a>.
				</td>
			</tr>
			<tr>
				<td><code>Z</code>, <code>z</code></td>
				<td><code>filler</code></td>
				<td>
					A series of <mv>size</mv> filler bits (<code>Z</code>
					for "zero"). When packing, <mv>size</mv> bits are filled
					with zero. When unpacking, <mv>size</mv> bits are skipped
					and ignored. There is no unpacked <mv>value</mv> for
					this data type.
				</td>
			</tr>
			<tr>
				<td><code>M</code>, <code>m</code></td>
				<td><code>magic</code></td>
				<td>
					The <mv>elaboration</mv> is a magic number. When
					packing, the resulting packed value is the magic number.
					When unpacking, the packed value is checked against
					the magic number; if they don't match, a script error
					is triggered. There is no unpacked <mv>value</mv>
					for this data type.
				</td>
			</tr>
			<tr>
				<td><code>A</code>, <code>a</code></td>
				<td><code>align</code></td>
				<td>
					Alignment to a multiple of <mv>size</mv> bits. There
					is no unpacked <mv>value</mv> for this data type.
				</td>
			</tr>
			<tr>
				<td><code>*</code></td>
				<td><code>blob</code>, <code>binary</code></td>
				<td>
					The <mv>size</mv>, <mv>endianness</mv>, and
					<mv>elaboration</mv> are ignored. The <mv>count</mv>
					is the number of bytes to pack or unpack.
					If the <mv>count</mv> is unspecified when unpacking,
					zero bytes are unpacked. If the <mv>count</mv> is
					unspecified when packing, however many bytes are
					in the unpacked <mv>value</mv> are packed. The
					unpacked <mv>value</mv> is a <a>dt:binary</a>.
				</td>
			</tr>
			<tr>
				<td><code>$</code></td>
				<td><code>struct</code></td>
				<td>
					A substructure. The <mv>elaboration</mv> is a format
					string describing the binary data substructure.
					The unpacked <mv>value</mv> is a <a>dt:list</a> of
					unpacked <mv>value</mv>s from the specified substructure.
				</td>
			</tr>
			<tr>
				<td><code>@</code></td>
				<td><code>offset</code></td>
				<td>
					The <mv>size</mv>, <mv>endianness</mv>, and
					<mv>elaboration</mv> are ignored. The <mv>count</mv>
					is an offset from the beginning of the packed
					<a>dt:binary</a> where future values are packed to
					or unpacked from. When unpacking, the offset may be
					anywhere in the <a>dt:binary</a>. When packing, the
					offset must be greater than or equal to the number
					of bytes already packed.
				</td>
			</tr>
		</table>
		<p>
			In addition to the type names listed above, the following
			special type names are allowed in a long-format <mv>format</mv>
			string. These special type names specify a size and, for some,
			an endianness and an <mv>elaboration</mv> in addition to a
			data type.
		</p>
		<table>
			<tr>
				<td><code>bbyte</code></td>
				<td>alias for <code>bint8</code></td>
			</tr>
			<tr>
				<td><code>obyte</code></td>
				<td>alias for <code>oint8</code></td>
			</tr>
			<tr>
				<td><code>hbyte</code></td>
				<td>alias for <code>hint8</code></td>
			</tr>
			<tr>
				<td><code>ubyte</code></td>
				<td>alias for <code>uint8</code></td>
			</tr>
			<tr>
				<td><code>sbyte</code></td>
				<td>alias for <code>sint8</code></td>
			</tr>
			<tr>
				<td><code>byte</code></td>
				<td>alias for <code>int8</code></td>
			</tr>
			<tr>
				<td><code>bshort</code></td>
				<td>alias for <code>bint16</code></td>
			</tr>
			<tr>
				<td><code>oshort</code></td>
				<td>alias for <code>oint16</code></td>
			</tr>
			<tr>
				<td><code>hshort</code></td>
				<td>alias for <code>hint16</code></td>
			</tr>
			<tr>
				<td><code>ushort</code></td>
				<td>alias for <code>uint16</code></td>
			</tr>
			<tr>
				<td><code>sshort</code></td>
				<td>alias for <code>sint16</code></td>
			</tr>
			<tr>
				<td><code>short</code></td>
				<td>alias for <code>int16</code></td>
			</tr>
			<tr>
				<td><code>blong</code></td>
				<td>alias for <code>bint64</code></td>
			</tr>
			<tr>
				<td><code>olong</code></td>
				<td>alias for <code>oint64</code></td>
			</tr>
			<tr>
				<td><code>hlong</code></td>
				<td>alias for <code>hint64</code></td>
			</tr>
			<tr>
				<td><code>ulong</code></td>
				<td>alias for <code>uint64</code></td>
			</tr>
			<tr>
				<td><code>slong</code></td>
				<td>alias for <code>sint64</code></td>
			</tr>
			<tr>
				<td><code>long</code></td>
				<td>alias for <code>int64</code></td>
			</tr>
			<tr>
				<td><code>half</code></td>
				<td>alias for <code>float16</code></td>
			</tr>
			<tr>
				<td><code>single</code></td>
				<td>alias for <code>float32</code></td>
			</tr>
			<tr>
				<td><code>real</code></td>
				<td>alias for <code>float32</code></td>
			</tr>
			<tr>
				<td><code>double</code></td>
				<td>alias for <code>float64</code></td>
			</tr>
			<tr>
				<td><code>quad</code></td>
				<td>alias for <code>float128</code></td>
			</tr>
			<tr>
				<td><code>onecc</code></td>
				<td>alias for <code>char8</code></td>
			</tr>
			<tr>
				<td><code>occ</code></td>
				<td>alias for <code>char8</code></td>
			</tr>
			<tr>
				<td><code>twocc</code></td>
				<td>alias for <code>char16</code></td>
			</tr>
			<tr>
				<td><code>tcc</code></td>
				<td>alias for <code>char16</code></td>
			</tr>
			<tr>
				<td><code>fourcc</code></td>
				<td>alias for <code>char32</code></td>
			</tr>
			<tr>
				<td><code>fcc</code></td>
				<td>alias for <code>char32</code></td>
			</tr>
			<tr>
				<td><code>eightcc</code></td>
				<td>alias for <code>char64</code></td>
			</tr>
			<tr>
				<td><code>ecc</code></td>
				<td>alias for <code>char64</code></td>
			</tr>
			<tr>
				<td><code>wstring</code></td>
				<td>alias for <code>pstring16</code></td>
			</tr>
			<tr>
				<td><code>lstring</code></td>
				<td>alias for <code>pstring32</code></td>
			</tr>
			<tr>
				<td><code>wchar</code></td>
				<td>alias for <code>char16be&#123;UTF-16&#125;</code></td>
			</tr>
			<tr>
				<td><code>wcharbe</code></td>
				<td>alias for <code>char16be&#123;UTF-16&#125;</code></td>
			</tr>
			<tr>
				<td><code>wcharle</code></td>
				<td>alias for <code>char16le&#123;UTF-16&#125;</code></td>
			</tr>
			<tr>
				<td><code>ostype</code></td>
				<td>alias for <code>char32be&#123;MacRoman&#125;</code></td>
			</tr>
			<tr>
				<td><code>symbol</code></td>
				<td>alias for <code>char64be&#123;ISO-8859-1&#125;</code></td>
			</tr>
			<tr>
				<td><code>point</code></td>
				<td>alias for <code>struct&#123;sint16be y; sint16be x;&#125;</code></td>
			</tr>
			<tr>
				<td><code>rect</code></td>
				<td>alias for <code>struct&#123;sint16be top; sint16be left; sint16be bottom; sint16be right;&#125;</code></td>
			</tr>
			<tr>
				<td><code>rectangle</code></td>
				<td>alias for <code>struct&#123;sint16be top; sint16be left; sint16be bottom; sint16be right;&#125;</code></td>
			</tr>
			<tr>
				<td><code>rgbcolor</code></td>
				<td>alias for <code>struct&#123;uint16be red; uint16be green; uint16be blue;&#125;</code></td>
			</tr>
			<tr>
				<td><code>rgbcolour</code></td>
				<td>alias for <code>struct&#123;uint16be red; uint16be green; uint16be blue;&#125;</code></td>
			</tr>
		</table>
	</description>
	<notes>
		<p>
			If the <mv>format</mv> string is not properly formed,
			a script error is triggered.
		</p>
		<p>
			If the <mv>data</mv> are shorter than required by the
			<mv>format</mv>, the missing bytes are assumed to be zero.
			If the <mv>data</mv> are longer than required by the
			<mv>format</mv>, the extra bytes are ignored.
		</p>
	</notes>
	<see-also>
		fn:pack
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">urlDecode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function decodes any sequences of the form
			<code>%<mv>XX</mv></code> in the specified string,
			replaces plus signs with spaces, and returns the
			decoded string. The string is decoded in the same
			way that posted data from an HTML form is decoded.
		</p>
		<p>
			The decoding of sequences for non-ASCII characters is
			determined by the text encoding specified by the
			<a>pr:textEncoding</a> property.
		</p>
	</description>
	<see-also>
		fn:urlEncode, fn:urlQueryDecode, fn:urlQueryEncode,
		fn:htmlEncode, fn:htmlDecode
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">urlEncode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function encodes non-alphabetic characters (other
			than hyphen, underscore, and period), control characters, and
			non-ASCII characters in the specified string as a percent sign
			followed by two hexadecimal digits, and spaces in the specified
			string as plus signs, and returns the encoded string. The string
			is encoded in the same way that posted data from an HTML form
			is encoded.
		</p>
		<p>
			The encoding for non-ASCII characters is determined by the
			text encoding specified by the <a>pr:textEncoding</a> property.
		</p>
	</description>
	<see-also>
		fn:urlDecode, fn:urlQueryEncode, fn:urlQueryDecode,
		fn:htmlEncode, fn:htmlDecode
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.4" modules="oxne&ge;1.4">urlQueryDecode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:string</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function takes a URL query string and produces a
			<a>dt:dictionary</a> with corresponding keys and values.
		</p>
		<p>
			The decoding of sequences for non-ASCII characters is determined by
			the text encoding specified by the <a>pr:textEncoding</a> property.
		</p>
	</description>
	<see-also>
		fn:urlQueryEncode, fn:urlDecode, fn:urlEncode
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.4" modules="oxne&ge;1.4">urlQueryEncode</name>
	<syntax>
		<syn>
			<opt>the</opt> <me/> of <mv>factor</mv>
		</syn>
		<syn>
			<me/> ( <mv>expression</mv> )
		</syn>
		<p>
			<mv>Factor</mv> and <mv>expression</mv> yield <a>dt:dictionary</a>s.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function takes a <a>dt:dictionary</a> and produces
			a URL query string with corresponding keys and values.
		</p>
		<p>
			The encoding for non-ASCII characters is determined by the
			text encoding specified by the <a>pr:textEncoding</a> property.
		</p>
	</description>
	<see-also>
		fn:urlQueryDecode, fn:urlEncode, fn:urlDecode
	</see-also>
</function>

<function>
	<name dialects="oxn" modules="oxne">vmName</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the vmName
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the name of the Java virtual machine.
			You might use this to determine whether a script will run correctly
			under that virtual machine.
		</p>
	</description>
	<notes>
		<p>
			OpenXION gets the value of this function from the
			<code>java.vm.name</code> system property.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security key
			is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="oxn" modules="oxne">vmVersion</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the vmVersion
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the version of the Java virtual machine.
			You might use this to determine whether a script will run correctly
			under that version of the virtual machine.
		</p>
	</description>
	<notes>
		<p>
			OpenXION gets the value of this function from the
			<code>java.vm.version</code> system property.
		</p>
	</notes>
	<security>
		<p>
			To use this function, OpenXION's security settings must allow the
			<code>SYSTEM_INFO</code> security key. If the required security key
			is denied, a script error will be triggered.
		</p>
	</security>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">ygnDecode</name>
	<syntax>
		<syn>
			the <me/> of <mv>text</mv>
		</syn>
		<syn>
			the <me/> of ( <mv>text</mv>, <mv>collapseBackslashes</mv> )
		</syn>
		<syn>
			<me/> ( <mv>text</mv><opt>, <mv>collapseBackslashes</mv></opt> )
		</syn>
		<p>
			<mv>Text</mv> yields a <a>dt:string</a>.
			<mv>CollapseBackslashes</mv> yields a <a>dt:boolean</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function decodes sequences of the forms
			<code>=X<mv>hex</mv>=</code> and <code>=<mv>L</mv>=</code>
			in the specified string and returns the decoded string.
		</p>
		<p>
			A sequence of the form <code>=X<mv>hex</mv>=</code>, where
			<mv>hex</mv> is a hexadecimal integer using capital letters
			representing a Unicode code point, is decoded as the character
			at that code point.
		</p>
		<p>
			A sequence of the form <code>=<mv>L</mv>=</code>, where
			<mv>L</mv> is a single capital letter, is decoded as one
			of the following symbols:
		</p>
		<table>
			<tr>
				<td><code>=A=</code></td>
				<td>apostrophe</td>
			</tr>
			<tr>
				<td><code>=B=</code></td>
				<td>backslash</td>
			</tr>
			<tr>
				<td><code>=C=</code></td>
				<td>colon</td>
			</tr>
			<tr>
				<td><code>=D=</code></td>
				<td>dollar sign</td>
			</tr>
			<tr>
				<td><code>=E=</code></td>
				<td>equals sign</td>
			</tr>
			<tr>
				<td><code>=F=</code></td>
				<td>slash (mnemonic: "fraction")</td>
			</tr>
			<tr>
				<td><code>=G=</code></td>
				<td>greater-than</td>
			</tr>
			<tr>
				<td><code>=H=</code></td>
				<td>question mark (mnemonic: "help")</td>
			</tr>
			<tr>
				<td><code>=I=</code></td>
				<td>opening bracket</td>
			</tr>
			<tr>
				<td><code>=J=</code></td>
				<td>closing bracket</td>
			</tr>
			<tr>
				<td><code>=K=</code></td>
				<td>semicolon</td>
			</tr>
			<tr>
				<td><code>=L=</code></td>
				<td>less-than</td>
			</tr>
			<tr>
				<td><code>=M=</code></td>
				<td>ampersand</td>
			</tr>
			<tr>
				<td><code>=N=</code></td>
				<td>plus sign</td>
			</tr>
			<tr>
				<td><code>=O=</code></td>
				<td>pound sign (mnemonic: "octothorpe")</td>
			</tr>
			<tr>
				<td><code>=P=</code></td>
				<td>percent</td>
			</tr>
			<tr>
				<td><code>=Q=</code></td>
				<td>quotation mark</td>
			</tr>
			<tr>
				<td><code>=R=</code></td>
				<td>caret (mnemonic: "raise")</td>
			</tr>
			<tr>
				<td><code>=S=</code></td>
				<td>asterisk (mnemonic: "star")</td>
			</tr>
			<tr>
				<td><code>=T=</code></td>
				<td>tilde</td>
			</tr>
			<tr>
				<td><code>=U=</code></td>
				<td>underscore</td>
			</tr>
			<tr>
				<td><code>=V=</code></td>
				<td>vertical bar</td>
			</tr>
			<tr>
				<td><code>=W=</code></td>
				<td>grave accent (mnemonic: "which," as in
				<code>`which gcc` hello.c</code>)</td>
			</tr>
			<tr>
				<td><code>=X=</code></td>
				<td>exclamation point</td>
			</tr>
			<tr>
				<td><code>=Y=</code></td>
				<td>opening brace</td>
			</tr>
			<tr>
				<td><code>=Z=</code></td>
				<td>closing brace</td>
			</tr>
		</table>
		<p>
			If <mv>collapseBackslashes</mv> is <a>cn:true</a>, any
			<code>=B=</code> sequences immediately preceding a
			<code>=B=</code>, <code>=A=</code>, or <code>=Q=</code>
			sequence are ignored.
		</p>
	</description>
	<see-also>
		fn:ygnEncode, fn:urlEncode, fn:urlDecode, fn:htmlEncode, fn:htmlDecode
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.3" modules="oxne&ge;1.3">ygnEncode</name>
	<syntax>
		<syn>
			the <me/> of <mv>text</mv>
		</syn>
		<syn>
			the <me/> of ( <mv>text</mv><opt>, <mv>level</mv><opt>,
			<mv>collapseBackslashes</mv></opt></opt> )
		</syn>
		<syn>
			<me/> ( <mv>text</mv><opt>, <mv>level</mv><opt>,
			<mv>collapseBackslashes</mv></opt></opt> )
		</syn>
		<p>
			<mv>Text</mv> yields a <a>dt:string</a>. <mv>Level</mv> yields
			an <a>dt:integer</a>. <mv>CollapseBackslashes</mv> yields a
			<a>dt:boolean</a>.
		</p>
	</syntax>
	<description>
		<p>
			The <me/> function encodes backslashes, apostrophes, quotation
			marks, and equals signs in the specified string as the sequences
			<code>=B=</code>, <code>=A=</code>, <code>=Q=</code>, and
			<code>=E=</code>, respectively, and returns the encoded string.
		</p>
		<p>
			If <mv>level</mv> is zero or greater, the <me/> function also
			encodes percent signs, underscores, question marks, and asterisks
			as the sequences <code>=P=</code>, <code>=U=</code>, <code>=H=</code>,
			and <code>=S=</code>, respectively, effectively masking off
			commonly-used and SQL-specific wildcard characters.
		</p>
		<p>
			If <mv>level</mv> is one or greater, the <me/> function also
			encodes less-than signs, greater-than signs, and ampersands
			as the sequences <code>=L=</code>, <code>=G=</code>, and
			<code>=M=</code>, respectively, effectively masking off XML
			tag characters.
		</p>
		<p>
			If <mv>level</mv> is two or greater, the <me/> function also
			encodes the following symbols thusly:
		</p>
		<table>
			<tr>
				<td>exclamation point</td>
				<td><code>=X=</code></td>
			</tr>
			<tr>
				<td>pound sign</td>
				<td><code>=O=</code> (mnemonic: "octothorpe")</td>
			</tr>
			<tr>
				<td>dollar sign</td>
				<td><code>=D=</code></td>
			</tr>
			<tr>
				<td>plus sign</td>
				<td><code>=N=</code></td>
			</tr>
			<tr>
				<td>slash</td>
				<td><code>=F=</code> (mnemonic: "fraction")</td>
			</tr>
			<tr>
				<td>colon</td>
				<td><code>=C=</code></td>
			</tr>
			<tr>
				<td>semicolon</td>
				<td><code>=K=</code></td>
			</tr>
			<tr>
				<td>opening bracket</td>
				<td><code>=I=</code></td>
			</tr>
			<tr>
				<td>closing bracket</td>
				<td><code>=J=</code></td>
			</tr>
			<tr>
				<td>caret</td>
				<td><code>=R=</code> (mnemonic: "raise")</td>
			</tr>
			<tr>
				<td>grave accent</td>
				<td><code>=W=</code> (mnemonic: "which," as in
				<code>`which gcc` hello.c</code>)</td>
			</tr>
			<tr>
				<td>opening brace</td>
				<td><code>=Y=</code></td>
			</tr>
			<tr>
				<td>closing brace</td>
				<td><code>=Z=</code></td>
			</tr>
			<tr>
				<td>vertical bar</td>
				<td><code>=V=</code></td>
			</tr>
			<tr>
				<td>tilde</td>
				<td><code>=T=</code></td>
			</tr>
		</table>
		<p>
			Finally, if <mv>level</mv> is three or greater, the <me/>
			function also encodes control characters and non-ASCII characters
			as the sequence <code>=X<mv>hex</mv>=</code>, where <mv>hex</mv>
			is a hexadecimal integer using capital letters representing
			the Unicode code point of the character.
		</p>
		<p>
			If <mv>collapseBackslashes</mv> is <a>cn:true</a>, any backslashes
			immediately preceding a backslash, apostrophe, or quotation mark
			are ignored.
		</p>
	</description>
	<see-also>
		fn:ygnDecode, fn:urlEncode, fn:urlDecode, fn:htmlEncode, fn:htmlDecode
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">serialPorts</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the serialPorts
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a <a>pr:lineEnding</a>-delimited
			list of communications ports. These are the possible values
			of the <a>pr:dialingPort</a> property, which determines the
			port used to dial phone numbers with a modem.
		</p>
	</description>
	<notes>
		<p>
			In HyperTalk, this function existed but was undocumented.
		</p>
	</notes>
	<security>
		<p>
			To use the <me/> function, OpenXION's security settings must allow
			the <code>SYSTEM_INFO</code> security key. If the required security
			key is denied, a script error will be triggered.
		</p>
	</security>
	<see-also>
		cm:dial, pr:dialingPort
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">sound</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the sound
		</scr>
		<scr>
			wait until the sound is "done"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the name of the instrument currently
			playing on the current <a>pr:soundChannel</a>, or the string
			<code>"done"</code> if no instrument is currently playing.
		</p>
	</description>
	<notes>
		<p>
			The <code>"done"</code> string is a literal; it is not a constant
			like <a>cn:zero</a> or <a>cn:true</a>. In HyperTalk code, the
			<code>"done"</code> literal is often left unquoted, but in XION
			this is highly discouraged.
		</p>
	</notes>
	<see-also>
		cm:play, fn:sounds
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.2" modules="oxna&ge;1.2">sounds</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the sounds
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a <a>pr:lineEnding</a>-delimited
			list of instrument names currently available for use with
			the <a>cm:play</a> command.
		</p>
	</description>
	<see-also>
		cm:play, fn:sound
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">speech</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the speech
		</scr>
		<scr>
			wait until the speech is "done"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the currently generated speech text,
			or the string <code>"done"</code> if no speech is currently
			being generated.
		</p>
	</description>
	<notes>
		<p>
			The <code>"done"</code> string is a literal; it is not a constant
			like <a>cn:zero</a> or <a>cn:true</a>. In HyperTalk code, the
			<code>"done"</code> literal is often left unquoted, but in XION
			this is highly discouraged.
		</p>
	</notes>
	<see-also>
		cm:speak, fn:voice
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.2" modules="oxna&ge;1.2">tone</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the tone
		</scr>
		<scr>
			wait until the tone is "done"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the frequency of the tone currently
			being generated by the <a>cm:tone</a> command, or the string
			<code>"done"</code> if no tone is currently playing.
		</p>
	</description>
	<notes>
		<p>
			The <code>"done"</code> string is a literal; it is not a constant
			like <a>cn:zero</a> or <a>cn:true</a>. In HyperTalk code, the
			<code>"done"</code> literal is often left unquoted, but in XION
			this is highly discouraged.
		</p>
	</notes>
	<see-also>
		cm:tone
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.2" modules="oxna&ge;1.2">voice</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the voice
		</scr>
		<scr>
			wait until the voice is "done"
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns the name of the voice currently
			speaking, or the string <code>"done"</code> if no speech is
			currently being generated.
		</p>
	</description>
	<notes>
		<p>
			The <code>"done"</code> string is a literal; it is not a constant
			like <a>cn:zero</a> or <a>cn:true</a>. In HyperTalk code, the
			<code>"done"</code> literal is often left unquoted, but in XION
			this is highly discouraged.
		</p>
	</notes>
	<see-also>
		cm:speak, fn:speech, fn:voices
	</see-also>
</function>

<function>
	<name dialects="oxn&ge;1.2,hyp" modules="oxna&ge;1.2">voices</name>
	<syntax>
		<syn>
			the <me/>
		</syn>
		<syn>
			<me/>()
		</syn>
	</syntax>
	<examples>
		<scr>
			put the voices
		</scr>
	</examples>
	<description>
		<p>
			The <me/> function returns a <a>pr:lineEnding</a>-delimited
			list of voices currently available for use with the
			<a>cm:speak</a> command.
		</p>
	</description>
	<see-also>
		cm:speak, fn:voice
	</see-also>
</function>

<iomanager>
	<name dialects="xn,oxn,hyp" modules="oxns">file</name>
	<examples>
		<scr>
			open file "XION.tex"
		</scr>
		<scr>
			open file "XION.tex" as "ISO-8859-1"
		</scr>
		<scr>
			open file "XION.tex" as "UTF-8"
		</scr>
		<scr>
			open file "Resources.dff" as "binary"
		</scr>
	</examples>
	<description>
		<p>
			The <a>mg:file</a> I/O manager allows reading and writing to
			<a>dt:file</a>s using the I/O commands <a>cm:open</a>,
			<a>cm:read</a>, <a>cm:write</a>, <a>cm:truncate</a>, and
			<a>cm:close</a>. See the documentation for each I/O command
			for more information.
		</p>
	</description>
	<notes>
		<p>
			If no I/O method is given, the <a>mg:file</a> I/O manager
			assumes the <a>mt:text</a> I/O method using the current value of
			the <a>pr:textEncoding</a> property as the text encoding to use.
		</p>
	</notes>
	<security>
		<p>
			To open files, OpenXION's security settings must allow one
			or both of the <code>FILE_SYSTEM_READ</code> and
			<code>FILE_SYSTEM_WRITE</code> security keys. To read from
			files, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_READ</code> security key. To write to
			files, OpenXION's security settings must allow the
			<code>FILE_SYSTEM_WRITE</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<compatibility>
		<p>
			HyperTalk does not support the <kwd>as</kwd> keyword.
			HyperTalk assumes the MacRoman text encoding.
		</p>
	</compatibility>
	<see-also>
		cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</iomanager>

<iomanager>
	<name dialects="oxn,hyp" modules="oxne">URL</name>
	<examples>
		<scr>
			open URL "http://www.openxion.org"
		</scr>
		<scr>
			open URL "http://www.openxion.org" as "text"
		</scr>
	</examples>
	<description>
		<p>
			If <i>no</i> I/O method is given, the <a>mg:URL</a> I/O manager
			will open the specified URL with the user's default web browser.
		</p>
		<p>
			If an I/O method <i>is</i> given, the <a>mg:URL</a> I/O manager
			allows reading and writing to <a>dt:URL</a>s using the I/O commands
			<a>cm:open</a>, <a>cm:read</a>, <a>cm:write</a>, <a>cm:truncate</a>,
			and <a>cm:close</a>. See the documentation for each I/O command
			for more information.
		</p>
	</description>
	<security>
		<p>
			To launch URLs, OpenXION's security settings must allow the
			<code>BROWSER_LAUNCH</code> security key. To read from or
			write to URLs, OpenXION's security settings must allow the
			<code>INTERNET_ACCESS</code> security key. If the required
			security key is denied, a script error will be triggered.
		</p>
	</security>
	<compatibility>
		<p>
			HyperTalk does not support the <kwd>as</kwd> keyword. HyperTalk
			can only launch URLs, and cannot read from or write to them.
		</p>
	</compatibility>
	<see-also>
		cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</iomanager>

<iomethod>
	<name dialects="xn,oxn" modules="oxns">binary</name>
	<examples>
		<scr>
			open file "logo.png" as "binary"
		</scr>
	</examples>
	<description>
		<p>
			The <a>mt:binary</a> I/O method allows reading and writing as
			binary data. The <a>dt:variant</a>s read and written will be
			<a>dt:binary</a>s.
		</p>
	</description>
	<notes>
		<p>
			<a>cm:Read</a>ing something opened as <a>mt:binary</a> without
			specifying a length will result in reading all the remaining data.
		</p>
	</notes>
	<see-also>
		cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</iomethod>

<iomethod>
	<name dialects="xn,oxn" modules="oxns">text</name>
	<examples>
		<scr>
			open file "readme.txt" as "text"
		</scr>
		<scr>
			open file "My To-Do List" as "MacRoman"
		</scr>
		<scr>
			open file "AUTOEXEC.BAT" as "CP437"
		</scr>
	</examples>
	<description>
		<p>
			The <a>mt:text</a> I/O method allows reading and writing as text.
			The <a>dt:variant</a>s read and written will be <a>dt:string</a>s.
		</p>
	</description>
	<notes>
		<p>
			If the I/O method is specified as simply <code>"text"</code>, the
			value of the <a>pr:textEncoding</a> property is used to determine
			the text encoding to use. Otherwise, the name specified as the
			I/O method is used to determine the text encoding to use.
		</p>
		<p>
			<a>cm:Read</a>ing something opened as <a>mt:text</a> without
			specifying a length will result in reading characters up to and
			including the next line break. The <a>mt:text</a> I/O method uses
			<a>cn:return</a><a>op:&amp;</a><a>cn:newline</a>, <a>cn:newline</a>,
			<a>cn:return</a>, <a>cn:linesep</a>, and <a>cn:parasep</a> as
			possible line endings.
		</p>
	</notes>
	<see-also>
		cm:open, cm:read, cm:write, cm:truncate, cm:close
	</see-also>
</iomethod>

<extlang>
	<name dialects="oxn,hyp" modules="oxnb">hyperTalk</name>
	<name dialects="oxn" modules="oxnb">xion</name>
	<name dialects="oxn" modules="oxnb">openxion</name>
	<description>
		<p>
			Executes the specified text as a script. The string is executed
			as though it were inserted in place of the <a>cs:do</a> statement.
		</p>
	</description>
	<compatibility>
		<p>
			In OpenXION, the <a>xl:hyperTalk</a> "language" is provided
			as a synonym of <a>xl:xion</a> and <a>xl:openxion</a> for
			compatibility purposes.
		</p>
	</compatibility>
	<see-also>
		cs:do
	</see-also>
</extlang>

<extlang>
	<name dialects="oxn,hyp" modules="oxne">appleScript</name>
	<description>
		<p>
			Executes the specified text as an AppleScript script.
		</p>
	</description>
	<notes>
		<p>
			This external language is only available when OpenXION
			is running under Mac OS X.
		</p>
		<p>
			In OpenXION 1.2 and later, the output of the script, if any,
			can be retrieved using the <a>fn:result</a> function.
			(OpenXION 1.0 and 1.1 did not capture any output.)
		</p>
	</notes>
	<see-also>
		cs:do
	</see-also>
</extlang>

<extlang>
	<name dialects="oxn&ge;1.1" modules="oxne&ge;1.1">vbScript</name>
	<description>
		<p>
			Executes the specified text as a VBScript script.
		</p>
	</description>
	<notes>
		<p>
			This external language is only available when OpenXION
			is running under Windows.
		</p>
		<p>
			In OpenXION 1.2 and later, the output of the script, if any,
			can be retrieved using the <a>fn:result</a> function.
			(OpenXION 1.0 and 1.1 did not capture any output.)
		</p>
	</notes>
	<see-also>
		cs:do
	</see-also>
</extlang>

<extlang>
	<name dialects="oxn" modules="oxne">bash</name>
	<description>
		<p>
			Executes the specified text as a <code>bash</code> script.
		</p>
	</description>
	<notes>
		<p>
			This external language is only available when OpenXION
			is running under a system other than Windows.
		</p>
		<p>
			In OpenXION 1.2 and later, the output of the script, if any,
			can be retrieved using the <a>fn:result</a> function.
			(OpenXION 1.0 and 1.1 did not capture any output.)
		</p>
	</notes>
	<see-also>
		cs:do
	</see-also>
</extlang>

<extlang>
	<name dialects="oxn" modules="oxne">perl</name>
	<description>
		<p>
			Executes the specified text as a Perl script.
		</p>
	</description>
	<notes>
		<p>
			This external language is only available when OpenXION
			is running under a system other than Windows.
		</p>
		<p>
			In OpenXION 1.2 and later, the output of the script, if any,
			can be retrieved using the <a>fn:result</a> function.
			(OpenXION 1.0 and 1.1 did not capture any output.)
		</p>
	</notes>
	<see-also>
		cs:do
	</see-also>
</extlang>

<extlang>
	<name dialects="oxn" modules="oxne">php</name>
	<description>
		<p>
			Executes the specified text as a PHP script.
		</p>
	</description>
	<notes>
		<p>
			This external language is only available when OpenXION
			is running under a system other than Windows.
		</p>
		<p>
			In OpenXION 1.2 and later, the output of the script, if any,
			can be retrieved using the <a>fn:result</a> function.
			(OpenXION 1.0 and 1.1 did not capture any output.)
		</p>
	</notes>
	<see-also>
		cs:do
	</see-also>
</extlang>

<extlang>
	<name dialects="oxn" modules="oxne">python</name>
	<description>
		<p>
			Executes the specified text as a Python script.
		</p>
	</description>
	<notes>
		<p>
			This external language is only available when OpenXION
			is running under a system other than Windows.
		</p>
		<p>
			In OpenXION 1.2 and later, the output of the script, if any,
			can be retrieved using the <a>fn:result</a> function.
			(OpenXION 1.0 and 1.1 did not capture any output.)
		</p>
	</notes>
	<see-also>
		cs:do
	</see-also>
</extlang>

<extlang>
	<name dialects="oxn" modules="oxne">ruby</name>
	<description>
		<p>
			Executes the specified text as a Ruby script.
		</p>
	</description>
	<notes>
		<p>
			This external language is only available when OpenXION
			is running under a system other than Windows.
		</p>
		<p>
			In OpenXION 1.2 and later, the output of the script, if any,
			can be retrieved using the <a>fn:result</a> function.
			(OpenXION 1.0 and 1.1 did not capture any output.)
		</p>
	</notes>
	<see-also>
		cs:do
	</see-also>
</extlang>

<version>
	<name dialects="oxn" modules="oxns">standardModule</name>
	<description>
		<p>
			The version number of the OpenXION Standard Module.
		</p>
	</description>
</version>

<version>
	<name dialects="xn,oxn" modules="oxns">interpreter</name>
	<name dialects="xn,oxn" modules="oxns">xion</name>
	<name dialects="oxn" modules="oxns">openxion</name>
	<description>
		<p>
			The version number of the XION interpreter.
		</p>
	</description>
	<see-also>
		dt:interpreter, fn:xionName, fn:xionVersion
	</see-also>
</version>

<version>
	<name dialects="xn,oxn" modules="oxns">system</name>
	<name dialects="xn,oxn" modules="oxns">operatingSystem</name>
	<name dialects="xn,oxn" modules="oxns">opSys</name>
	<name dialects="xn,oxn" modules="oxns">os</name>
	<description>
		<p>
			The version number of the operating system.
		</p>
	</description>
	<see-also>
		fn:systemName, fn:systemVersion
	</see-also>
</version>

<version>
	<name dialects="oxn" modules="oxne">extendedModule</name>
	<description>
		<p>
			The version number of the OpenXION Extended Module.
		</p>
	</description>
</version>

<version>
	<name dialects="oxn" modules="oxne">java</name>
	<description>
		<p>
			The version number of the Java Runtime Environment.
		</p>
	</description>
	<see-also>
		vr:javavm, fn:javaName, fn:javaVersion
	</see-also>
</version>

<version>
	<name dialects="oxn" modules="oxne">javavm</name>
	<name dialects="oxn" modules="oxne">vm</name>
	<description>
		<p>
			The version number of the Java Virtual Machine.
		</p>
	</description>
	<see-also>
		vr:java, fn:vmName, fn:vmVersion
	</see-also>
</version>

<version>
	<name dialects="oxn&ge;1.2" modules="oxna&ge;1.2">audioModule</name>
	<description>
		<p>
			The version number of the OpenXION Audio Module.
		</p>
	</description>
</version>

<article>
	<name>keywords</name>
	<title>Keywords at a Glance</title>
	<summary>
		An at-a-glance view of all the control structures
		and other keywords available in OpenXION.
	</summary>
	<content>
		<h3>Includes</h3>
		<table>
			<tr>
				<td><a>cs:include</a></td>
				<td><a>cs:require</a></td>
				<td><a>cs:use</a></td>
			</tr>
		</table>
		<h3>Declarations</h3>
		<table>
			<tr>
				<td><a>cs:global</a></td>
				<td><a>cs:shared</a></td>
				<td><a>cs:static</a></td>
				<td><a>cs:local</a></td>
				<td><a>cs:const</a></td>
				<td><a>cs:ordinal</a></td>
			</tr>
		</table>
		<h3>Conditionals</h3>
		<table>
			<tr>
				<td><a>cs:if</a></td>
				<td><a>cs:then</a></td>
				<td><a>cs:else</a></td>
				<td><a>cs:exit</a></td>
				<td><a>cs:end</a></td>
			</tr>
			<tr>
				<td><a>cs:switch</a></td>
				<td><a>cs:case</a></td>
				<td><a>cs:default</a></td>
				<td><a>cs:next</a></td>
				<td><a>cs:exit</a></td>
				<td><a>cs:end</a></td>
			</tr>
		</table>
		<h3>Loops</h3>
		<table>
			<tr>
				<td><a>cs:repeat</a></td>
				<td><a>cs:repeat for</a></td>
				<td><a>cs:repeat for each</a></td>
				<td><a>cs:repeat foreach</a></td>
			</tr>
			<tr>
				<td><a>cs:repeat until</a></td>
				<td><a>cs:repeat while</a></td>
				<td><a>cs:repeat with</a></td>
			</tr>
			<tr>
				<td><a>cs:then</a></td>
				<td><a>cs:else</a></td>
				<td><a>cs:lastly</a></td>
			</tr>
			<tr>
				<td><a>cs:next</a></td>
				<td><a>cs:exit</a></td>
				<td><a>cs:end</a></td>
			</tr>
		</table>
		<h3>Exceptions</h3>
		<table>
			<tr>
				<td><a>cs:try</a></td>
				<td><a>cs:throw</a></td>
				<td><a>cs:catch</a></td>
				<td><a>cs:finally</a></td>
				<td><a>cs:exit</a></td>
				<td><a>cs:end</a></td>
			</tr>
		</table>
		<h3>Messages &amp; Handlers</h3>
		<table>
			<tr>
				<td><a>cs:on</a></td>
				<td><a>cs:function</a></td>
				<td><a>cs:return</a></td>
			</tr>
			<tr>
				<td><a>cs:pass</a></td>
				<td><a>cs:exit</a></td>
				<td><a>cs:end</a></td>
			</tr>
			<tr>
				<td><a>cs:do</a></td>
				<td><a>cs:send</a></td>
				<td><a>cs:tell</a></td>
			</tr>
		</table>
		<h3>Objects</h3>
		<table>
			<tr>
				<td><a>cs:object type</a></td>
				<td><a>cs:pl</a></td>
				<td><a>cs:aka</a></td>
				<td><a>cs:extends</a></td>
			</tr>
			<tr>
				<td><a>cs:to create</a></td>
				<td><a>cs:to delete</a></td>
				<td><a>cs:to get</a></td>
				<td><a>cs:to set</a></td>
			</tr>
			<tr>
				<td><a>kw:me</a></td>
				<td><a>kw:super</a></td>
				<td><a>cs:exit</a></td>
				<td><a>cs:end</a></td>
			</tr>
		</table>
		<h3>Adjectives</h3>
		<table>
			<tr>
				<td><a>kw:short</a></td>
				<td><a>kw:med</a></td>
				<td><a>kw:medium</a></td>
				<td><a>kw:abbr</a></td>
			</tr>
			<tr>
				<td><a>kw:abbrev</a></td>
				<td><a>kw:abbreviated</a></td>
				<td><a>kw:long</a></td>
				<td><a>kw:English</a></td>
			</tr>
		</table>
		<h3>Prepositions</h3>
		<table>
			<tr>
				<td><a>kw:into</a></td>
				<td><a>kw:before</a></td>
				<td><a>kw:after</a></td>
			</tr>
		</table>
		<h3>Miscellaneous</h3>
		<table>
			<tr>
				<td><a>kw:in</a></td>
				<td><a>kw:of</a></td>
				<td><a>kw:to</a></td>
				<td><a>kw:thru</a></td>
				<td><a>kw:through</a></td>
				<td><a>kw:the</a></td>
			</tr>
		</table>
		<h3>Macros</h3>
		<table>
			<tr>
				<td><a>kw:__LINE__</a></td>
				<td><a>kw:__FILE__</a></td>
				<td><a>kw:__END__</a></td>
			</tr>
		</table>
	</content>
</article>

<article>
	<name>commands</name>
	<title>Commands at a Glance</title>
	<summary>
		An at-a-glance view of all the commands
		available in OpenXION.
	</summary>
	<content>
		<h3>Basic</h3>
		<table>
			<tr>
				<td><a>cm:get</a></td>
				<td><a>cm:put</a></td>
				<td><a>cm:let</a></td>
				<td><a>cm:set</a></td>
			</tr>
		</table>
		<h3>Arithmetic</h3>
		<table>
			<tr>
				<td><a>cm:add</a></td>
				<td><a>cm:subtract</a></td>
				<td><a>cm:multiply</a></td>
				<td><a>cm:divide</a></td>
				<td><a>cm:modulo</a></td>
			</tr>
		</table>
		<h3>Objects</h3>
		<table>
			<tr>
				<td><a>cm:create</a></td>
				<td><a>cm:delete</a></td>
			</tr>
		</table>
		<h3>Interaction</h3>
		<table>
			<tr>
				<td><a>cm:answer</a></td>
				<td><a>cm:ask</a></td>
				<td><a>cm:beep</a></td>
				<td><a>cm:put</a></td>
			</tr>
		</table>
		<h3>File I/O</h3>
		<table>
			<tr>
				<td><a>cm:open</a></td>
				<td><a>cm:read</a></td>
				<td><a>cm:write</a></td>
				<td><a>cm:truncate</a></td>
				<td><a>cm:close</a></td>
			</tr>
		</table>
		<h3>Sound</h3>
		<table>
			<tr>
				<td><a>cm:beep</a></td>
				<td><a>cm:dial</a></td>
				<td><a>cm:play</a></td>
				<td><a>cm:speak</a></td>
				<td><a>cm:stop</a></td>
				<td><a>cm:tone</a></td>
			</tr>
		</table>
		<h3>Miscellaneous</h3>
		<table>
			<tr>
				<td><a>cm:convert</a></td>
				<td><a>cm:sort</a></td>
				<td><a>cm:sql</a></td>
				<td><a>cm:wait</a></td>
			</tr>
		</table>
	</content>
</article>

<article>
	<name>functions</name>
	<title>Functions at a Glance</title>
	<summary>
		An at-a-glance view of all the functions
		available in OpenXION.
	</summary>
	<content>
		<h2>Mathematical Functions</h2>
		<h3>Basic</h3>
		<table>
			<tr>
				<td><a>fn:abs</a></td>
				<td><a>fn:arg</a></td>
				<td><a>fn:conj</a></td>
				<td><a>fn:Re</a></td>
				<td><a>fn:Im</a></td>
			</tr>
			<tr>
				<td><a>fn:sgn</a></td>
				<td><a>fn:signum</a></td>
				<td><a>fn:sqrt</a></td>
				<td><a>fn:cbrt</a></td>
			</tr>
			<tr>
				<td><a>fn:toDeg</a></td>
				<td><a>fn:toDegrees</a></td>
				<td><a>fn:toRad</a></td>
				<td><a>fn:toRadians</a></td>
			</tr>
			<tr>
				<td><a>fn:isFinite</a></td>
				<td><a>fn:isInfinite</a></td>
				<td><a>fn:isNaN</a></td>
			</tr>
			<tr>
				<td><a>fn:sum</a></td>
				<td><a>fn:prod</a></td>
				<td><a>fn:product</a></td>
				<td><a>fn:rsr</a></td>
				<td><a>fn:rms</a></td>
			</tr>
			<tr>
				<td><a>fn:random</a></td>
				<td><a>fn:randomRange</a></td>
				<td colspan="2"><a>fn:randomDecimal</a></td>
			</tr>
		</table>
		<h3>Rounding</h3>
		<table>
			<tr>
				<td><a>fn:ceil</a></td>
				<td><a>fn:floor</a></td>
			</tr>
			<tr>
				<td><a>fn:aug</a></td>
				<td><a>fn:trunc</a></td>
			</tr>
			<tr>
				<td><a>fn:round</a></td>
				<td><a>fn:rint</a></td>
			</tr>
			<tr>
				<td><a>fn:int</a></td>
				<td><a>fn:frac</a></td>
			</tr>
		</table>
		<h3>Logarithms &amp; Exponentials</h3>
		<table>
			<tr>
				<td><a>fn:exp</a></td>
				<td><a>fn:exp1</a></td>
				<td><a>fn:exp2</a></td>
				<td><a>fn:exp10</a></td>
			</tr>
			<tr>
				<td><a>fn:ln</a></td>
				<td><a>fn:ln1</a></td>
				<td><a>fn:log2</a></td>
				<td><a>fn:log10</a></td>
			</tr>
			<tr>
				<td><a>fn:log</a></td>
				<td><a>fn:pow</a></td>
				<td><a>fn:root</a></td>
			</tr>
		</table>
		<h3>Trigonometry</h3>
		<table>
			<tr>
				<td><a>fn:sin</a></td>
				<td><a>fn:cos</a></td>
				<td><a>fn:tan</a></td>
				<td><a>fn:cot</a></td>
				<td><a>fn:sec</a></td>
				<td><a>fn:csc</a></td>
			</tr>
			<tr>
				<td><a>fn:asin</a></td>
				<td><a>fn:acos</a></td>
				<td><a>fn:atan</a></td>
				<td><a>fn:acot</a></td>
				<td><a>fn:asec</a></td>
				<td><a>fn:acsc</a></td>
			</tr>
			<tr>
				<td><a>fn:sinh</a></td>
				<td><a>fn:cosh</a></td>
				<td><a>fn:tanh</a></td>
				<td><a>fn:coth</a></td>
				<td><a>fn:sech</a></td>
				<td><a>fn:csch</a></td>
			</tr>
			<tr>
				<td><a>fn:asinh</a></td>
				<td><a>fn:acosh</a></td>
				<td><a>fn:atanh</a></td>
				<td><a>fn:acoth</a></td>
				<td><a>fn:asech</a></td>
				<td><a>fn:acsch</a></td>
			</tr>
		</table>
		<h3>Coordinate Transformation</h3>
		<table>
			<tr>
				<td><a>fn:hypot</a></td>
				<td><a>fn:atan2</a></td>
			</tr>
			<tr>
				<td><a>fn:radius</a></td>
				<td><a>fn:theta</a></td>
			</tr>
			<tr>
				<td><a>fn:xcoord</a></td>
				<td><a>fn:ycoord</a></td>
			</tr>
		</table>
		<h3>Statistics</h3>
		<table>
			<tr>
				<td><a>fn:avg</a></td>
				<td><a>fn:average</a></td>
			</tr>
			<tr>
				<td><a>fn:geom</a></td>
				<td><a>fn:geomean</a></td>
			</tr>
			<tr>
				<td><a>fn:min</a></td>
				<td><a>fn:minimum</a></td>
			</tr>
			<tr>
				<td><a>fn:max</a></td>
				<td><a>fn:maximum</a></td>
			</tr>
			<tr>
				<td><a>fn:stddev</a></td>
				<td><a>fn:variance</a></td>
			</tr>
			<tr>
				<td><a>fn:pstddev</a></td>
				<td><a>fn:pvariance</a></td>
			</tr>
			<tr>
				<td><a>fn:sstddev</a></td>
				<td><a>fn:svariance</a></td>
			</tr>
		</table>
		<h3>Finance</h3>
		<table>
			<tr>
				<td><a>fn:annuity</a></td>
				<td><a>fn:compound</a></td>
			</tr>
		</table>
		<h3>Factorials &amp; Probability</h3>
		<table>
			<tr>
				<td><a>fn:fact</a></td>
				<td><a>fn:factorial</a></td>
				<td><a>fn:Γ</a></td>
				<td><a>fn:gamma</a></td>
				<td><a>fn:β</a></td>
				<td><a>fn:beta</a></td>
			</tr>
			<tr>
				<td><a>fn:lnfact</a></td>
				<td><a>fn:lnfactorial</a></td>
				<td><a>fn:lnΓ</a></td>
				<td><a>fn:lngamma</a></td>
				<td><a>fn:lnβ</a></td>
				<td><a>fn:lnbeta</a></td>
			</tr>
			<tr>
				<td><a>fn:nCr</a></td>
				<td><a>fn:choose</a></td>
				<td><a>fn:nPr</a></td>
				<td><a>fn:pick</a></td>
			</tr>
		</table>
		<h3>Number Theory &amp; Representation</h3>
		<table>
			<tr>
				<td><a>fn:agm</a></td>
				<td><a>fn:gcd</a></td>
				<td><a>fn:lcm</a></td>
			</tr>
			<tr>
				<td><a>fn:bin</a></td>
				<td><a>fn:oct</a></td>
				<td><a>fn:hex</a></td>
				<td><a>fn:bc</a></td>
			</tr>
			<tr>
				<td colspan="2"><a>fn:reverseBits</a></td>
				<td colspan="2"><a>fn:reverseBytes</a></td>
			</tr>
			<tr>
				<td colspan="2"><a>fn:bitMingle</a></td>
				<td colspan="2"><a>fn:bitSelect</a></td>
			</tr>
		</table>
		<h3>Infinite-arity Relative &amp; Boolean Operators</h3>
		<table>
			<tr>
				<td><a>fn:and</a></td>
				<td><a>fn:or</a></td>
				<td><a>fn:xor</a></td>
				<td><a>fn:equal</a></td>
			</tr>
			<tr>
				<td><a>fn:asc</a></td>
				<td><a>fn:ascending</a></td>
				<td><a>fn:desc</a></td>
				<td><a>fn:descending</a></td>
			</tr>
			<tr>
				<td><a>fn:inc</a></td>
				<td><a>fn:increasing</a></td>
				<td><a>fn:dec</a></td>
				<td><a>fn:decreasing</a></td>
			</tr>
		</table>
		<h2>String Functions</h2>
		<h3>String Manipulation</h3>
		<table>
			<tr>
				<td><a>fn:len</a></td>
				<td><a>fn:length</a></td>
				<td><a>fn:reverse</a></td>
			</tr>
			<tr>
				<td><a>fn:concat</a></td>
				<td><a>fn:concatsp</a></td>
				<td><a>fn:implode</a></td>
			</tr>
			<tr>
				<td><a>fn:strcmp</a></td>
				<td><a>fn:csStrcmp</a></td>
				<td><a>fn:regMatch</a></td>
				<td><a>fn:trMatch</a></td>
			</tr>
			<tr>
				<td><a>fn:offset</a></td>
				<td><a>fn:csOffset</a></td>
				<td><a>fn:regOffset</a></td>
				<td><a>fn:trOffset</a></td>
			</tr>
			<tr>
				<td><a>fn:instr</a></td>
				<td><a>fn:csInstr</a></td>
				<td><a>fn:regInstr</a></td>
				<td><a>fn:trInstr</a></td>
			</tr>
			<tr>
				<td><a>fn:rinstr</a></td>
				<td><a>fn:csRinstr</a></td>
				<td><a>fn:regRinstr</a></td>
				<td><a>fn:trRinstr</a></td>
			</tr>
			<tr>
				<td><a>fn:countFields</a></td>
				<td><a>fn:csCountFields</a></td>
				<td><a>fn:regCountFields</a></td>
				<td><a>fn:trCountFields</a></td>
			</tr>
			<tr>
				<td><a>fn:nthField</a></td>
				<td><a>fn:csNthField</a></td>
				<td><a>fn:regNthField</a></td>
				<td><a>fn:trNthField</a></td>
			</tr>
			<tr>
				<td><a>fn:explode</a></td>
				<td><a>fn:csExplode</a></td>
				<td><a>fn:regExplode</a></td>
				<td><a>fn:trExplode</a></td>
			</tr>
			<tr>
				<td><a>fn:replace</a></td>
				<td><a>fn:csReplace</a></td>
				<td><a>fn:regReplace</a></td>
				<td><a>fn:trReplace</a></td>
			</tr>
			<tr>
				<td><a>fn:replaceAll</a></td>
				<td><a>fn:csReplaceAll</a></td>
				<td><a>fn:regReplaceAll</a></td>
				<td><a>fn:trReplaceAll</a></td>
			</tr>
			<tr>
				<td><a>fn:left</a></td>
				<td><a>fn:center</a></td>
				<td><a>fn:right</a></td>
			</tr>
			<tr>
				<td><a>fn:mid</a></td>
				<td><a>fn:substr</a></td>
				<td><a>fn:substring</a></td>
			</tr>
			<tr>
				<td><a>fn:lpad</a></td>
				<td><a>fn:cpad</a></td>
				<td><a>fn:rpad</a></td>
			</tr>
			<tr>
				<td><a>fn:trim</a></td>
				<td><a>fn:ltrim</a></td>
				<td><a>fn:rtrim</a></td>
			</tr>
			<tr>
				<td><a>fn:ucase</a></td>
				<td><a>fn:tcase</a></td>
				<td><a>fn:lcase</a></td>
			</tr>
			<tr>
				<td><a>fn:'</a></td>
				<td><a>fn:format</a></td>
			</tr>
		</table>
		<h3>Text Encoding</h3>
		<table>
			<tr>
				<td><a>fn:numToChar</a></td>
				<td><a>fn:charToNum</a></td>
			</tr>
			<tr>
				<td><a>fn:numToUni</a></td>
				<td><a>fn:uniToNum</a></td>
			</tr>
			<tr>
				<td><a>fn:binToChar</a></td>
				<td><a>fn:charToBin</a></td>
			</tr>
			<tr>
				<td><a>fn:binToUni</a></td>
				<td><a>fn:uniToBin</a></td>
			</tr>
		</table>
		<h3>Encode &amp; Decode</h3>
		<table>
			<tr>
				<td><a>fn:hash</a></td>
				<td><a>fn:rot13</a></td>
			</tr>
			<tr>
				<td><a>fn:htmlEncode</a></td>
				<td><a>fn:htmlDecode</a></td>
			</tr>
			<tr>
				<td><a>fn:urlEncode</a></td>
				<td><a>fn:urlDecode</a></td>
			</tr>
			<tr>
				<td><a>fn:urlQueryEncode</a></td>
				<td><a>fn:urlQueryDecode</a></td>
			</tr>
			<tr>
				<td><a>fn:ygnEncode</a></td>
				<td><a>fn:ygnDecode</a></td>
			</tr>
		</table>
		<h2>Other Functions</h2>
		<h3>Date &amp; Time</h3>
		<table>
			<tr>
				<td><a>fn:date</a></td>
				<td><a>fn:time</a></td>
				<td><a>fn:dateItems</a></td>
			</tr>
			<tr>
				<td><a>fn:secs</a></td>
				<td><a>fn:seconds</a></td>
				<td><a>fn:ticks</a></td>
			</tr>
		</table>
		<h3>Lists</h3>
		<table>
			<tr>
				<td><a>fn:head</a></td>
				<td><a>fn:tail</a></td>
				<td><a>fn:number</a></td>
			</tr>
			<tr>
				<td><a>fn:lconcat</a></td>
				<td><a>fn:lreverse</a></td>
				<td><a>fn:llength</a></td>
			</tr>
			<tr>
				<td><a>fn:map</a></td>
				<td><a>fn:filter</a></td>
				<td><a>fn:reduce</a></td>
			</tr>
		</table>
		<h3>Binary Data</h3>
		<table>
			<tr>
				<td><a>fn:atob</a></td>
				<td><a>fn:btoa</a></td>
				<td><a>fn:pack</a></td>
				<td><a>fn:unpack</a></td>
			</tr>
		</table>
		<h3>Sound</h3>
		<table>
			<tr>
				<td><a>fn:sound</a></td>
				<td><a>fn:speech</a></td>
				<td><a>fn:voice</a></td>
			</tr>
			<tr>
				<td><a>fn:sounds</a></td>
				<td><a>fn:tone</a></td>
				<td><a>fn:voices</a></td>
			</tr>
		</table>
		<h3>Parameter &amp; Return Value Passing</h3>
		<table>
			<tr>
				<td><a>fn:paramCount</a></td>
				<td><a>fn:param</a></td>
				<td><a>fn:params</a></td>
			</tr>
			<tr>
				<td><a>fn:parent</a></td>
				<td><a>fn:result</a></td>
				<td><a>fn:value</a></td>
			</tr>
		</table>
		<h3>System Information</h3>
		<table>
			<tr>
				<td><a>fn:systemName</a></td>
				<td><a>fn:systemVersion</a></td>
			</tr>
			<tr>
				<td><a>fn:vmName</a></td>
				<td><a>fn:vmVersion</a></td>
			</tr>
			<tr>
				<td><a>fn:javaName</a></td>
				<td><a>fn:javaVersion</a></td>
			</tr>
			<tr>
				<td><a>fn:xionName</a></td>
				<td><a>fn:xionVersion</a></td>
			</tr>
			<tr>
				<td><a>fn:version</a></td>
				<td><a>fn:getenv</a></td>
			</tr>
			<tr>
				<td><a>fn:heapSpace</a></td>
				<td><a>fn:serialPorts</a></td>
			</tr>
		</table>
		<h3>File System</h3>
		<table>
			<tr>
				<td><a>fn:appPath</a></td>
				<td><a>fn:applicationPath</a></td>
				<td><a>fn:progPath</a></td>
				<td><a>fn:programPath</a></td>
			</tr>
			<tr>
				<td><a>fn:appFile</a></td>
				<td><a>fn:applicationFile</a></td>
				<td><a>fn:progFile</a></td>
				<td><a>fn:programFile</a></td>
			</tr>
			<tr>
				<td><a>fn:docPath</a></td>
				<td><a>fn:documentPath</a></td>
				<td><a>fn:docFile</a></td>
				<td><a>fn:documentFile</a></td>
			</tr>
			<tr>
				<td><a>fn:appOrDocPath</a></td>
				<td><a>fn:applicationOrDocumentPath</a></td>
				<td><a>fn:progOrDocPath</a></td>
				<td><a>fn:programOrDocumentPath</a></td>
			</tr>
			<tr>
				<td><a>fn:appOrDocFile</a></td>
				<td><a>fn:applicationOrDocumentFile</a></td>
				<td><a>fn:progOrDocFile</a></td>
				<td><a>fn:programOrDocumentFile</a></td>
			</tr>
			<tr>
				<td><a>fn:includePath</a></td>
				<td><a>fn:includeFile</a></td>
				<td><a>fn:path</a></td>
			</tr>
		</table>
	</content>
</article>

<article>
	<name>datatypes</name>
	<title>Data Types at a Glance</title>
	<summary>
		An at-a-glance view of all the data types
		available in OpenXION.
	</summary>
	<content>
		<h2>Data Types</h2>
		<h3>Primitives</h3>
		<table>
			<tr>
				<td><a>dt:variant</a></td>
				<td><a>dt:variants</a></td>
			</tr>
			<tr>
				<td><a>dt:boolean</a></td>
				<td><a>dt:booleans</a></td>
			</tr>
			<tr>
				<td><a>dt:integer</a></td>
				<td><a>dt:integers</a></td>
			</tr>
			<tr>
				<td><a>dt:number</a></td>
				<td><a>dt:numbers</a></td>
			</tr>
			<tr>
				<td><a>dt:complex</a></td>
				<td><a>dt:complexes</a></td>
			</tr>
			<tr>
				<td><a>dt:string</a></td>
				<td><a>dt:strings</a></td>
			</tr>
			<tr>
				<td><a>dt:binary</a></td>
				<td><a>dt:binaries</a></td>
			</tr>
			<tr>
				<td><a>dt:reference</a></td>
				<td><a>dt:references</a></td>
			</tr>
		</table>
		<h3>Compound Types</h3>
		<table>
			<tr>
				<td><a>dt:point</a></td>
				<td><a>dt:points</a></td>
			</tr>
			<tr>
				<td><a>dt:rect</a></td>
				<td><a>dt:rects</a></td>
			</tr>
			<tr>
				<td><a>dt:rectangle</a></td>
				<td><a>dt:rectangles</a></td>
			</tr>
			<tr>
				<td><a>dt:color</a></td>
				<td><a>dt:colors</a></td>
			</tr>
			<tr>
				<td><a>dt:colour</a></td>
				<td><a>dt:colours</a></td>
			</tr>
			<tr>
				<td><a>dt:date</a></td>
				<td><a>dt:dates</a></td>
			</tr>
		</table>
		<h3>Data Structures</h3>
		<table>
			<tr>
				<td><a>dt:list</a></td>
				<td><a>dt:lists</a></td>
			</tr>
			<tr>
				<td><a>dt:dictionary</a></td>
				<td><a>dt:dictionaries</a></td>
			</tr>
			<tr>
				<td><a>dt:object</a></td>
				<td><a>dt:objects</a></td>
			</tr>
		</table>
		<h2>Chunk Types</h2>
		<h3>String Chunk Types</h3>
		<table>
			<tr>
				<td><a>dt:char</a></td>
				<td><a>dt:chars</a></td>
			</tr>
			<tr>
				<td><a>dt:character</a></td>
				<td><a>dt:characters</a></td>
			</tr>
			<tr>
				<td><a>dt:item</a></td>
				<td><a>dt:items</a></td>
			</tr>
			<tr>
				<td><a>dt:col</a></td>
				<td><a>dt:cols</a></td>
			</tr>
			<tr>
				<td><a>dt:column</a></td>
				<td><a>dt:columns</a></td>
			</tr>
			<tr>
				<td><a>dt:row</a></td>
				<td><a>dt:rows</a></td>
			</tr>
			<tr>
				<td><a>dt:line</a></td>
				<td><a>dt:lines</a></td>
			</tr>
			<tr>
				<td><a>dt:word</a></td>
				<td><a>dt:words</a></td>
			</tr>
			<tr>
				<td><a>dt:sent</a></td>
				<td><a>dt:sents</a></td>
			</tr>
			<tr>
				<td><a>dt:sentence</a></td>
				<td><a>dt:sentences</a></td>
			</tr>
			<tr>
				<td><a>dt:para</a></td>
				<td><a>dt:paras</a></td>
			</tr>
			<tr>
				<td><a>dt:paragraph</a></td>
				<td><a>dt:paragraphs</a></td>
			</tr>
		</table>
		<h3>Binary Chunk Types</h3>
		<table>
			<tr>
				<td><a>dt:byte</a></td>
				<td><a>dt:bytes</a></td>
			</tr>
			<tr>
				<td><a>dt:tinyInt</a></td>
				<td><a>dt:tinyInts</a></td>
			</tr>
			<tr>
				<td><a>dt:shortInt</a></td>
				<td><a>dt:shortInts</a></td>
			</tr>
			<tr>
				<td><a>dt:medInt</a></td>
				<td><a>dt:medInts</a></td>
			</tr>
			<tr>
				<td><a>dt:mediumInt</a></td>
				<td><a>dt:mediumInts</a></td>
			</tr>
			<tr>
				<td><a>dt:longInt</a></td>
				<td><a>dt:longInts</a></td>
			</tr>
			<tr>
				<td><a>dt:halfFloat</a></td>
				<td><a>dt:halfFloats</a></td>
			</tr>
			<tr>
				<td><a>dt:singleFloat</a></td>
				<td><a>dt:singleFloats</a></td>
			</tr>
			<tr>
				<td><a>dt:doubleFloat</a></td>
				<td><a>dt:doubleFloats</a></td>
			</tr>
		</table>
		<h3>Data Structure Chunk Types</h3>
		<table>
			<tr>
				<td><a>dt:element</a></td>
				<td><a>dt:elements</a></td>
			</tr>
			<tr>
				<td><a>dt:entry</a></td>
				<td><a>dt:entries</a></td>
			</tr>
		</table>
		<h2>Built-In Object Types</h2>
		<h3>File System Objects</h3>
		<table>
			<tr>
				<td><a>dt:disk</a></td>
				<td><a>dt:disks</a></td>
			</tr>
			<tr>
				<td><a>dt:volume</a></td>
				<td><a>dt:volumes</a></td>
			</tr>
			<tr>
				<td><a>dt:folder</a></td>
				<td><a>dt:folders</a></td>
			</tr>
			<tr>
				<td><a>dt:directory</a></td>
				<td><a>dt:directories</a></td>
			</tr>
			<tr>
				<td><a>dt:file</a></td>
				<td><a>dt:files</a></td>
			</tr>
			<tr>
				<td><a>dt:fork</a></td>
				<td><a>dt:forks</a></td>
			</tr>
		</table>
		<h3>Miscellaneous Objects</h3>
		<table>
			<tr>
				<td><a>dt:environment</a></td>
				<td><a>dt:environments</a></td>
			</tr>
			<tr>
				<td><a>dt:interpreter</a></td>
				<td><a>dt:interpreters</a></td>
			</tr>
			<tr>
				<td><a>dt:clipboard</a></td>
				<td><a>dt:clipboards</a></td>
			</tr>
			<tr>
				<td><a>dt:URL</a></td>
				<td><a>dt:URLs</a></td>
			</tr>
		</table>
	</content>
</article>

<article>
	<name>properties</name>
	<title>Properties at a Glance</title>
	<summary>
		An at-a-glance view of all the properties
		available in OpenXION.
	</summary>
	<content>
		<h2>Global Properties</h2>
		<h3>Basic Global Properties</h3>
		<table>
			<tr>
				<td><a>pr:textEncoding</a></td>
				<td><a>pr:lineEnding</a></td>
				<td><a>pr:numberFormat</a></td>
			</tr>
			<tr>
				<td><a>pr:mathProcessor</a></td>
				<td><a>pr:precision</a></td>
				<td><a>pr:roundingMode</a></td>
			</tr>
		</table>
		<h3>Chunk Processing Properties</h3>
		<table>
			<tr>
				<td><a>pr:itemDelimiter</a></td>
				<td><a>pr:columnDelimiter</a></td>
				<td><a>pr:rowDelimiter</a></td>
			</tr>
			<tr>
				<td><a>pr:littleEndian</a></td>
				<td><a>pr:unsigned</a></td>
			</tr>
		</table>
		<h3>Audio Properties</h3>
		<table>
			<tr>
				<td><a>pr:dialingPort</a></td>
				<td><a>pr:dialingTime</a></td>
				<td><a>pr:dialingVolume</a></td>
			</tr>
			<tr>
				<td><a>pr:soundChannel</a></td>
				<td><a>pr:toneChannel</a></td>
				<td><a>pr:toneVolume</a></td>
			</tr>
		</table>
		<h3>System Properties</h3>
		<table>
			<tr>
				<td><a>pr:userName</a></td>
			</tr>
			<tr>
				<td><a>pr:applicationPaths</a></td>
				<td><a>pr:programPaths</a></td>
			</tr>
			<tr>
				<td><a>pr:documentPaths</a></td>
				<td><a>pr:includePaths</a></td>
			</tr>
		</table>
		<h2>Data Properties</h2>
		<h3>Rectangle Properties</h3>
		<table>
			<tr>
				<td><a>pr:left</a></td>
				<td><a>pr:top</a></td>
				<td><a>pr:right</a></td>
				<td><a>pr:bottom</a></td>
			</tr>
			<tr>
				<td><a>pr:topLeft</a></td>
				<td><a>pr:topRight</a></td>
				<td><a>pr:botLeft</a></td>
				<td><a>pr:botRight</a></td>
			</tr>
			<tr>
				<td><a>pr:bottomLeft</a></td>
				<td><a>pr:bottomRight</a></td>
				<td><a>pr:width</a></td>
				<td><a>pr:height</a></td>
			</tr>
			<tr>
				<td><a>pr:center</a></td>
				<td><a>pr:loc</a></td>
				<td><a>pr:location</a></td>
			</tr>
		</table>
		<h3>Color Properties</h3>
		<table>
			<tr>
				<td><a>pr:red</a></td>
				<td><a>pr:green</a></td>
				<td><a>pr:blue</a></td>
			</tr>
			<tr>
				<td><a>pr:hue</a></td>
				<td><a>pr:saturation</a></td>
				<td><a>pr:brightness</a></td>
			</tr>
			<tr>
				<td><a>pr:alpha</a></td>
			</tr>
		</table>
		<h3>Dictionary Properties</h3>
		<table>
			<tr>
				<td><a>pr:keys</a></td>
				<td><a>pr:values</a></td>
			</tr>
		</table>
		<h2>Object Properties</h2>
		<h3>Basic Object Properties</h3>
		<table>
			<tr>
				<td><a>pr:name</a></td>
				<td><a>pr:id</a></td>
				<td><a>pr:number</a></td>
			</tr>
		</table>
		<h3>File System Object Properties</h3>
		<table>
			<tr>
				<td><a>pr:path</a></td>
				<td><a>pr:modificationDate</a></td>
				<td><a>pr:count</a></td>
				<td><a>pr:size</a></td>
			</tr>
		</table>
	</content>
</article>

</xiondoc>
